{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Fusion Documentation Suite\n\n\n\n\n\n\nThe Fusion Documentation Suite contains comprehensive user guides and reference materials so that you have all the important information right at your fingertips.  \n\n\nUse the \nSearch Fusion Docs\n in the top right corner of the screen to search any questions you may have. If you can't find the solution to your problem, email us at \nsupport@BoxlightRobotics.com\n.\n\n\n\n\nSelect from the topics below for more information\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbout/Contact Boxlight Robotics", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-the-fusion-documentation-suite", 
            "text": "The Fusion Documentation Suite contains comprehensive user guides and reference materials so that you have all the important information right at your fingertips.    Use the  Search Fusion Docs  in the top right corner of the screen to search any questions you may have. If you can't find the solution to your problem, email us at  support@BoxlightRobotics.com .", 
            "title": "Welcome to the Fusion Documentation Suite"
        }, 
        {
            "location": "/#select-from-the-topics-below-for-more-information", 
            "text": "About/Contact Boxlight Robotics", 
            "title": "Select from the topics below for more information"
        }, 
        {
            "location": "/Getting_Started_Topic/", 
            "text": "Getting Started\n\n\n\n\nThe Fusion Controller is the heart of your MyBot System, and is fully loaded with all the applications, tools, resources, and documentation you need.  \n\n\nTo get started, you will want to connect the browser on your Wi-Fi enabled device to the Fusion's built-in wireless access point so you can log in and access all the built-in documentation.\n\n\nIn the event that you need a little help getting started, here\u2019s some basic guidance:\n\n\n\n\nStep-by-Step\n\n\nStep 1: Attach\n - The brain inside Fusion Controller can be powered from a USB port on your computer using the supplied cable.  You will see a green LED near the microUSB power input connector light-up when power is applied. \nNote that this provides power to the internal electronics and does not provide power for motors, servos, and other devices you may connect to your Fusion Controller.  These are only powered directly from the Battery Pack.\n\n\nStep 2: Power On\n - A press of the PWR button will turn on your Fusion Controller and start the internal boot-up process.  The Green LED near the letter O in Fusi\no\nn will flash while the unit starts.  It will light solid once the system is done with the start up process.\n\n\nStep 3: Connect\n - Connect your Wi-Fi enabled device to the Fusion's internal access point.  The access point will appear as \nFusionAP_ xxxxxx\n, where \nxxxxxx\n is a unique identifier for your particular Fusion.  This value can be found on the inside lid of the Fusion Controller Kit's box, or on a label attached to the side or bottom of the Fusion Controller.  The case-sensitive Passkey is \nmrifusion\n.  (\nNote:\n \nThese credentials are the default values for your Fusion.  Your Admin user may have changed them to simplify robot identification.  If there is not a FusionAP_xxxxxx Wi-Fi signal, check with your your Robot Admin User to see if there are other credentials to use.\n)\n\n\nStep 4: Launch\n - Open the browser on your device and browse to the Address/URL \nmy.bot\n to access the Fusion Interface.  This will open the Fusion Login screen where you can login to your account (or create a new one).  You can also login as a \nGuest User\n to get quick access to the complete Fusion Documentation Suite.  (\nNote:\n \nIf you have an active wired internet connection to your computer, the my.bot URL will not work.  You must enter the following address: http://192.168.50.1:8080 to access the Fusion Interface.\n)\n\n\nThese topics may help you get started with your Fusion.\n\n\n\n\n1. \nConnect USB Power\n\n\n2. \nConnect Battery Power\n\n\n3. \nFind/Connect Fusion Access Point\n\n\n4. \nAccessing the Fusion Web Interface\n\n\n5. \nCreate a new account\n\n\n6. \nAssembling your MyBot Kit\n\n\n7. \nCreate a Blockly Program\n\n\n8. \nCreate an Editor Program\n  \n\n\n\n\nTroubleshooting\n\n\n\n\nStep 1: \nGreen LED does not light when connecting microUSB cable\n\n\nStep 2: \nFusion will not turn on\n\n\nStep 2: \nStatus LED does not stop flashing\n\n\nStep 3: \nCan't find the Fusion Access Point\n\n\nStep 4: \nCannot access Fusion Interface\n  \n\n\n\n\nAdditional Assistance\n\n\n\n\nMissing items from your MyBot Kit\n  \n\n\n\n\nIf you need additional assistance, please email us at Support@BoxlightRobotics.com.", 
            "title": "Getting Started Guide"
        }, 
        {
            "location": "/Getting_Started_Topic/#getting-started", 
            "text": "The Fusion Controller is the heart of your MyBot System, and is fully loaded with all the applications, tools, resources, and documentation you need.    To get started, you will want to connect the browser on your Wi-Fi enabled device to the Fusion's built-in wireless access point so you can log in and access all the built-in documentation.  In the event that you need a little help getting started, here\u2019s some basic guidance:", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Getting_Started_Topic/#step-by-step", 
            "text": "Step 1: Attach  - The brain inside Fusion Controller can be powered from a USB port on your computer using the supplied cable.  You will see a green LED near the microUSB power input connector light-up when power is applied.  Note that this provides power to the internal electronics and does not provide power for motors, servos, and other devices you may connect to your Fusion Controller.  These are only powered directly from the Battery Pack.  Step 2: Power On  - A press of the PWR button will turn on your Fusion Controller and start the internal boot-up process.  The Green LED near the letter O in Fusi o n will flash while the unit starts.  It will light solid once the system is done with the start up process.  Step 3: Connect  - Connect your Wi-Fi enabled device to the Fusion's internal access point.  The access point will appear as  FusionAP_ xxxxxx , where  xxxxxx  is a unique identifier for your particular Fusion.  This value can be found on the inside lid of the Fusion Controller Kit's box, or on a label attached to the side or bottom of the Fusion Controller.  The case-sensitive Passkey is  mrifusion .  ( Note:   These credentials are the default values for your Fusion.  Your Admin user may have changed them to simplify robot identification.  If there is not a FusionAP_xxxxxx Wi-Fi signal, check with your your Robot Admin User to see if there are other credentials to use. )  Step 4: Launch  - Open the browser on your device and browse to the Address/URL  my.bot  to access the Fusion Interface.  This will open the Fusion Login screen where you can login to your account (or create a new one).  You can also login as a  Guest User  to get quick access to the complete Fusion Documentation Suite.  ( Note:   If you have an active wired internet connection to your computer, the my.bot URL will not work.  You must enter the following address: http://192.168.50.1:8080 to access the Fusion Interface. )", 
            "title": "Step-by-Step"
        }, 
        {
            "location": "/Getting_Started_Topic/#these-topics-may-help-you-get-started-with-your-fusion", 
            "text": "1.  Connect USB Power  2.  Connect Battery Power  3.  Find/Connect Fusion Access Point  4.  Accessing the Fusion Web Interface  5.  Create a new account  6.  Assembling your MyBot Kit  7.  Create a Blockly Program  8.  Create an Editor Program", 
            "title": "These topics may help you get started with your Fusion."
        }, 
        {
            "location": "/Getting_Started_Topic/#troubleshooting", 
            "text": "Step 1:  Green LED does not light when connecting microUSB cable  Step 2:  Fusion will not turn on  Step 2:  Status LED does not stop flashing  Step 3:  Can't find the Fusion Access Point  Step 4:  Cannot access Fusion Interface", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/Getting_Started_Topic/#additional-assistance", 
            "text": "Missing items from your MyBot Kit      If you need additional assistance, please email us at Support@BoxlightRobotics.com.", 
            "title": "Additional Assistance"
        }, 
        {
            "location": "/Fusion_Controller_Topic/", 
            "text": "Fusion Controller Reference\n\n\n\n\nThe Fusion Controller is an intelligent backpack board combined with the power of the Raspberry Pi 3, built into a robust and durable housing. The Fusion comes with a wide assortment of ports capable of supporting motors, servos and various types of sensors.  \n\nConnect to the Fusion with a web browser on any device that has Wi-Fi. Program the robot using a visual block programming environment called \nBlockly\n, or test your skills in programming languages such as Python in our \nEditor\n environment.\n\n\nHow To:\n\n\n\n\n1. \nConnect to USB Power\n\n\n2. \nConnect to Battery Power\n\n\n3. \nCharge the Fusion Battery\n\n\n4. \nPower the Fusion On\n\n\n5. \nPower the Fusion Off\n\n\n6. \nRestore the Fusion Access Point\n  \n\n\n\n\nController Layout:\n\n\n\n\n\n\nThe programmable Fusion Controller includes connection ports for a wide variety of motors, sensors, servos and devices.  This section outlines the basic features of the Fusion Controller and provides detailed programming and reference information to help you use each of the different ports in your designs.\n\n\nMore Information:\n \n\n\n\n\n1. \nOnBoard LEDs\n\n\n2. \nDigital Ports\n\n\n3. \nAnalog Ports\n\n\n4. \nI2C Ports\n\n\n5. \nMotor Ports\n\n\n6. \nServo Ports\n\n\n7. \nBattery Port\n\n\n8. \nBattery Charger Port\n\n\n9. \nUSB Power Port\n\n\n10. \nPower Button ON\n\n\n11. \nPower Button OFF\n\n\n12. \nUSB Hub\n\n\n13. \nEthernet Port\n\n\n14. \nWi-Fi\n\n\n15. \nSD Card", 
            "title": "Fusion Controller Guide"
        }, 
        {
            "location": "/Fusion_Controller_Topic/#fusion-controller-reference", 
            "text": "The Fusion Controller is an intelligent backpack board combined with the power of the Raspberry Pi 3, built into a robust and durable housing. The Fusion comes with a wide assortment of ports capable of supporting motors, servos and various types of sensors.   \nConnect to the Fusion with a web browser on any device that has Wi-Fi. Program the robot using a visual block programming environment called  Blockly , or test your skills in programming languages such as Python in our  Editor  environment.", 
            "title": "Fusion Controller Reference"
        }, 
        {
            "location": "/Fusion_Controller_Topic/#how-to", 
            "text": "1.  Connect to USB Power  2.  Connect to Battery Power  3.  Charge the Fusion Battery  4.  Power the Fusion On  5.  Power the Fusion Off  6.  Restore the Fusion Access Point", 
            "title": "How To:"
        }, 
        {
            "location": "/Fusion_Controller_Topic/#controller-layout", 
            "text": "The programmable Fusion Controller includes connection ports for a wide variety of motors, sensors, servos and devices.  This section outlines the basic features of the Fusion Controller and provides detailed programming and reference information to help you use each of the different ports in your designs.  More Information:     1.  OnBoard LEDs  2.  Digital Ports  3.  Analog Ports  4.  I2C Ports  5.  Motor Ports  6.  Servo Ports  7.  Battery Port  8.  Battery Charger Port  9.  USB Power Port  10.  Power Button ON  11.  Power Button OFF  12.  USB Hub  13.  Ethernet Port  14.  Wi-Fi  15.  SD Card", 
            "title": "Controller Layout:"
        }, 
        {
            "location": "/Web_Interface_Topic/", 
            "text": "Web Interface\n\n\n\n\nProgram Development and operation of the Fusion System is all performed through a built-in Web-based Graphical User Interface (WebGUI). This section provides an overview of the Fusion Web Interface features and operations. It also includes links to the reference guides for the various environments you can use to develop programs or change settings on your Fusion.\n\n\n\n\nTitle Bar\n\n\n\n\nThe Title Bar is displayed at the top of every page of Fusion Web Interface:\n\n\n\n\nClicking on the icon in the upper left \n opens the \nHamburger Menu\n:  \n\n\n\n\n\n\n\n\nThe top of the Hamburger menu has the name of the current logged in account. For this example, we are logged in as the account named \nrobot.admin\n.\n\n\nHome\n brings you back to the homepage of the Web Interface.\n\n\nBlockly\n brings you to the \nBlockly\n programming environment.\n\n\nEditor\n brings you to the \nEditor\n text-based programming environment.\n\n\nDocumentation\n opens the \nHome Page\n of the Fusion Documentation Suite.\n\n\nFile Manager\n opens a simple file manager which allows you to perform basic file maintenance such as renaming, moving, and deleting files as well as copying them from the Fusion to your computer.\n\n\nDiagnostic Tool\n opens the Fusion \nDiagnostic Tool\n. This simple interface allows you to manually check the operation of your Fusion, sensors, motors, and other devices as well as obtain system status information.  this tool will almost always be used with the help of a support agent.\n\n\nSettings\n brings your to a page where you can update the Fusion, modify wireless settings and manage users. You must be logged in as Administrator to access this feature.\n\n\nAbout\n gives you \ncontact information\n about Boxlight Robotics and MyBot.\n\n\n\n\n\n\nTo the right of the Hamburger Menu icon is: \n.  The \nMimio MyBot\n text is actually a clickable link which will take you back to the \nFusion Home Page\n.  To the immediate right, the name of the current page is displayed.  \n\n\nOn the far right side of the Title Bar are a series of icons. Clicking these icons provides status on each item:\n\n\n\n\n\n\nThe \nLanguage\n \n indicator shows the current language setting for the interface.  Clicking this indicator allows you to select from the available languages.  (Note that not all screens may be translated into the new language.)\n\n\nThe \nBattery\n \n icon which represents the remaining battery level of the \n6V Fusion Battery\n.\n\n\nThe \nInternet\n icon \n informs you if you have an internet connection.\n\n\nThe \nWireless\n icon \n provides information about the \nwireless network\n your Fusion may be connected to.  This is most valuable when connected to a Classroom Server such as the Mimio MicroCloud, or if an 802.11b/g/n USB Wi-Fi dongle is being used.\n\n\nThe \nProgram Details\n icon is either in Play \n or Stop \n status. Click the icon for additional details.\n\n\nThe \nPower\n icon \n allows you to \nLogout\n, \nPower Off\n or \nRestart\n your Fusion.   \nYou should always use this button to Power Off your Fusion after use\n.  This insures all files are properly saved and prevents data loss. \n\n\n\n\n\n\n\n\nHome Screen\n\n\n\n\nThe Home Screen gives you options to access different parts of the Fusion Web Interface.\n\n\n\n\n\n\nBuild\n brings you to available \nbuilding instructions\n for various Fusion kits.\n\n\nBlockly\n brings you to the \nBlockly\n programming environment.\n\n\nEditor\n brings you to the \nEditor\n text-based programming environment.\n\n\nFusion Documentation\n brings you to the to the \nHome Page\n of the Fusion Documentation.\n\n\nData Logging\n Opens a simple \ndata logging application\n that allows you to take automatic readings of the Fusion Sensors over a period of time and export that information in a delimeted file for analysis..\n\n\nSettings\n brings your to a page where you can update the Fusion, modify wireless settings and manage users. \nYou \nmust\n be logged in as an Admin User to access this feature\n.\n\n\nBlockly Games\n opens a set of game-like activities to help you become familiar with using Blockly.\n\n\n\n\n\n\n\n\nAdditional Help\n\n\n\n\n1. \nFind/Connect Fusion Access Point\n\n\n2. \nAccessing the Fusion Web Interface\n\n\n3. \nCreate a new account\n\n\n4. \nDelete an account\n\n\n5. \nEdit an account\n\n\n6. \nChange Fusion Access Point SSID and Passkey\n\n\n7. \nRestore Fusion Access Point\n\n\n8. \nConnect to the Internet\n\n\n9. \nUpdate the Fusion\n\n\n10. \nHow to use Blockly\n\n\n11. \nHow to use Editor\n\n\n12. \nUsing Autonomous Mode", 
            "title": "Web Interface Guide"
        }, 
        {
            "location": "/Web_Interface_Topic/#web-interface", 
            "text": "Program Development and operation of the Fusion System is all performed through a built-in Web-based Graphical User Interface (WebGUI). This section provides an overview of the Fusion Web Interface features and operations. It also includes links to the reference guides for the various environments you can use to develop programs or change settings on your Fusion.", 
            "title": "Web Interface"
        }, 
        {
            "location": "/Web_Interface_Topic/#title-bar", 
            "text": "The Title Bar is displayed at the top of every page of Fusion Web Interface:   Clicking on the icon in the upper left   opens the  Hamburger Menu :       The top of the Hamburger menu has the name of the current logged in account. For this example, we are logged in as the account named  robot.admin .  Home  brings you back to the homepage of the Web Interface.  Blockly  brings you to the  Blockly  programming environment.  Editor  brings you to the  Editor  text-based programming environment.  Documentation  opens the  Home Page  of the Fusion Documentation Suite.  File Manager  opens a simple file manager which allows you to perform basic file maintenance such as renaming, moving, and deleting files as well as copying them from the Fusion to your computer.  Diagnostic Tool  opens the Fusion  Diagnostic Tool . This simple interface allows you to manually check the operation of your Fusion, sensors, motors, and other devices as well as obtain system status information.  this tool will almost always be used with the help of a support agent.  Settings  brings your to a page where you can update the Fusion, modify wireless settings and manage users. You must be logged in as Administrator to access this feature.  About  gives you  contact information  about Boxlight Robotics and MyBot.    To the right of the Hamburger Menu icon is:  .  The  Mimio MyBot  text is actually a clickable link which will take you back to the  Fusion Home Page .  To the immediate right, the name of the current page is displayed.    On the far right side of the Title Bar are a series of icons. Clicking these icons provides status on each item:    The  Language    indicator shows the current language setting for the interface.  Clicking this indicator allows you to select from the available languages.  (Note that not all screens may be translated into the new language.)  The  Battery    icon which represents the remaining battery level of the  6V Fusion Battery .  The  Internet  icon   informs you if you have an internet connection.  The  Wireless  icon   provides information about the  wireless network  your Fusion may be connected to.  This is most valuable when connected to a Classroom Server such as the Mimio MicroCloud, or if an 802.11b/g/n USB Wi-Fi dongle is being used.  The  Program Details  icon is either in Play   or Stop   status. Click the icon for additional details.  The  Power  icon   allows you to  Logout ,  Power Off  or  Restart  your Fusion.    You should always use this button to Power Off your Fusion after use .  This insures all files are properly saved and prevents data loss.", 
            "title": "Title Bar"
        }, 
        {
            "location": "/Web_Interface_Topic/#home-screen", 
            "text": "The Home Screen gives you options to access different parts of the Fusion Web Interface.    Build  brings you to available  building instructions  for various Fusion kits.  Blockly  brings you to the  Blockly  programming environment.  Editor  brings you to the  Editor  text-based programming environment.  Fusion Documentation  brings you to the to the  Home Page  of the Fusion Documentation.  Data Logging  Opens a simple  data logging application  that allows you to take automatic readings of the Fusion Sensors over a period of time and export that information in a delimeted file for analysis..  Settings  brings your to a page where you can update the Fusion, modify wireless settings and manage users.  You  must  be logged in as an Admin User to access this feature .  Blockly Games  opens a set of game-like activities to help you become familiar with using Blockly.", 
            "title": "Home Screen"
        }, 
        {
            "location": "/Web_Interface_Topic/#additional-help", 
            "text": "1.  Find/Connect Fusion Access Point  2.  Accessing the Fusion Web Interface  3.  Create a new account  4.  Delete an account  5.  Edit an account  6.  Change Fusion Access Point SSID and Passkey  7.  Restore Fusion Access Point  8.  Connect to the Internet  9.  Update the Fusion  10.  How to use Blockly  11.  How to use Editor  12.  Using Autonomous Mode", 
            "title": "Additional Help"
        }, 
        {
            "location": "/Blockly_Topic/", 
            "text": "Blockly Reference\n\n\n\n\nBlockly is a visual programming environment designed for beginner programmers aimed to teach programming techniques. Blocky for Fusion comes with \nBasic\n and \nIntermediate\n modes which adds another level of complexity.\n\nBasic Blockly comes with blocks to control the motors which will drive and rotate the robot. There are also blocks to toggle the on-board yellow and blue LEDs on and off.\n\nIntermediate mode comes with more complex blocks to control motors independently, control servos and our entire range of sensors.\n\n\n\n\n\n1) \nProgram Environment\n  \n\n\n\n\n\n\nThis is the space where blocks are placed and connected to create programs.\n\n\nThere are both vertical and horizontal scrolling bars for navigating larger programs.\n\n\nThe icons in the bottom right are used to help you view your environment and delete blocks.\n\n\n\n\nThe \nreticle\n is used to center the block program within the program environment.\n\n\nThe \n+\n icon is used to zoom in on the program.\n\n\nThe \n-\n icon is used to zoom out from the program. \n\n\nThe \ntrashcan\n icon is used to delete a block or chunk of blocks by dragging the blocks over the trashcan.\n\n\n\n\n\n\n\n\n\n\n\n\n2) \nToolbox\n\n\n\n\n\n\nContains all available programming blocks organized by category.\n\n\n\n\n\n\n3) \nProgram Output\n \n\n\n\n\n\n\nThis window can be toggled on and off.\n\n\nDisplays the output of the program generated using the print block or an error from the Controller.\n\n\n\n\n\n\n4) \nCode Window\n\n\n\n\n\n\nThis window can be toggled on and off.\n\n\nDisplays the Python code that is produced by the blocks. This code can be copied, pasted and run directly from the \nEditor\n.\n\n\n\n\n\n\n5) \nToolbar\n\n\n\n\n\n\nFile\n - Gives the option to Create, Open, Close, Save, Delete and Print a file.\n\n\nView\n - Switch modes between Basic and Intermediate, also to show/hide the Program Output and Code Window.\n\n\nManage\n - Import or Export a file.\n\n\nHelp\n - Access controller and sensor examples as well as a link to the documentation.\n\n\n\nNew File\n - Opens a new file with Fusion import and driver lines in code.\n\n\nOpen File\n - Open a file that exists in the current user's file directory.\n\n\nSave File\n - Save the current file that is highlighted in Working Files.\n\n\nSave All Files\n - Save all the current files the Working Files.\n\n\nRun Program\n - Run the current program that is highlighted in Working Files.\n\n\nStop Program\n - Stop the current running program.\n\n\nToggle Program Output\n - Show and Hide the Program Output at the bottom of the screen.\n\n\nToggle Code Window\n - Show and Hide the Code Window to the right of the Program Environment.\n\n\nOpen Virtual Gamepad\n - Open the Virtual Gamepad in a new tab. (Must run the program first)\n\n\n\n\n\n\n\n\nUse Guide\n\n\n\n\n1. \nCreate a program (Basic \n Intermediate)\n  \n\n\n\n\nBasic Block Reference\n\n\n\n\n1. \nControl Robot\n\n\n2. \nMove Robot\n\n\n3. \nRotate Robot\n  \n\n\n\n\nIntermediate Block Reference\n\n\n\n\n1. \nControl Robot\n\n\n2. \nMotor Control\n\n\n3. \nServo Control\n\n\n4. \nUSB Gamepad\n\n\n5. \nVirtual Gamepad\n\n\n6. \nAnalog/Digital Sensors\n\n\n7. \nCompass (45-2003)\n\n\n8. \nRate Gyro (45-2004)\n\n\n9. \nIntegrating Gyro (45-2005)\n\n\n10. \nOptical Distance Sensor (45-2006)\n\n\n11. \nTouch Sensor (45-2007)\n\n\n12. \nRange Sensor (45-2008)\n\n\n13. \nInfrared Locator 360\u00b0 (45-2009)\n\n\n14. \nLight Sensor (45-2015)\n\n\n15. \nSound Generator (45-2016)\n\n\n16. \nInfrared Seeker V3 (45-2017)\n\n\n17. \nColor Sensor (45-2018)\n\n\n18. \nColor Beacon (45-2019)\n\n\n19. \nMagnetic Sensor(45-2020)\n\n\n20. \nTime\n\n\n21. \nLogic\n\n\n22. \nLoops\n\n\n23. \nText\n\n\n24. \nLists\n\n\n25. \nVariables\n\n\n26. \nFile Handling", 
            "title": "Blockly Topic"
        }, 
        {
            "location": "/Blockly_Topic/#blockly-reference", 
            "text": "Blockly is a visual programming environment designed for beginner programmers aimed to teach programming techniques. Blocky for Fusion comes with  Basic  and  Intermediate  modes which adds another level of complexity. \nBasic Blockly comes with blocks to control the motors which will drive and rotate the robot. There are also blocks to toggle the on-board yellow and blue LEDs on and off. \nIntermediate mode comes with more complex blocks to control motors independently, control servos and our entire range of sensors.   1)  Program Environment       This is the space where blocks are placed and connected to create programs.  There are both vertical and horizontal scrolling bars for navigating larger programs.  The icons in the bottom right are used to help you view your environment and delete blocks.   The  reticle  is used to center the block program within the program environment.  The  +  icon is used to zoom in on the program.  The  -  icon is used to zoom out from the program.   The  trashcan  icon is used to delete a block or chunk of blocks by dragging the blocks over the trashcan.       2)  Toolbox    Contains all available programming blocks organized by category.    3)  Program Output      This window can be toggled on and off.  Displays the output of the program generated using the print block or an error from the Controller.    4)  Code Window    This window can be toggled on and off.  Displays the Python code that is produced by the blocks. This code can be copied, pasted and run directly from the  Editor .    5)  Toolbar    File  - Gives the option to Create, Open, Close, Save, Delete and Print a file.  View  - Switch modes between Basic and Intermediate, also to show/hide the Program Output and Code Window.  Manage  - Import or Export a file.  Help  - Access controller and sensor examples as well as a link to the documentation.  New File  - Opens a new file with Fusion import and driver lines in code.  Open File  - Open a file that exists in the current user's file directory.  Save File  - Save the current file that is highlighted in Working Files.  Save All Files  - Save all the current files the Working Files.  Run Program  - Run the current program that is highlighted in Working Files.  Stop Program  - Stop the current running program.  Toggle Program Output  - Show and Hide the Program Output at the bottom of the screen.  Toggle Code Window  - Show and Hide the Code Window to the right of the Program Environment.  Open Virtual Gamepad  - Open the Virtual Gamepad in a new tab. (Must run the program first)", 
            "title": "Blockly Reference"
        }, 
        {
            "location": "/Blockly_Topic/#use-guide", 
            "text": "1.  Create a program (Basic   Intermediate)", 
            "title": "Use Guide"
        }, 
        {
            "location": "/Blockly_Topic/#basic-block-reference", 
            "text": "1.  Control Robot  2.  Move Robot  3.  Rotate Robot", 
            "title": "Basic Block Reference"
        }, 
        {
            "location": "/Blockly_Topic/#intermediate-block-reference", 
            "text": "1.  Control Robot  2.  Motor Control  3.  Servo Control  4.  USB Gamepad  5.  Virtual Gamepad  6.  Analog/Digital Sensors  7.  Compass (45-2003)  8.  Rate Gyro (45-2004)  9.  Integrating Gyro (45-2005)  10.  Optical Distance Sensor (45-2006)  11.  Touch Sensor (45-2007)  12.  Range Sensor (45-2008)  13.  Infrared Locator 360\u00b0 (45-2009)  14.  Light Sensor (45-2015)  15.  Sound Generator (45-2016)  16.  Infrared Seeker V3 (45-2017)  17.  Color Sensor (45-2018)  18.  Color Beacon (45-2019)  19.  Magnetic Sensor(45-2020)  20.  Time  21.  Logic  22.  Loops  23.  Text  24.  Lists  25.  Variables  26.  File Handling", 
            "title": "Intermediate Block Reference"
        }, 
        {
            "location": "/Editor_Topic/", 
            "text": "Editor Reference\n\n\n\n\nThe Editor is a web-based Integrated Development Environment (IDE) targeted to more advanced users. The programming language Fusion currently supports is Python, but will soon support other languages.  \n\n\nA basic understanding of text-based coding and the syntax for the selected programming language is needed to use the Editor IDE.  \n\n\n\n\n\n\n1) \nProgram Environment\n\n\n\n\n\n\nThis is the space which contains the user code. This space supports syntax highlighting for the selected language.\n\n\n\n\n\n\n2) \nWorking Files\n\n\n\n\n\n\nContains a list of open files. Files can be easily switched between without any loss of data. A * next to s file name indicated that it has not been saved.\n\n\n\n\n\n\n3) \nProgram Output\n \n\n\n\n\n\n\nDisplays the output of the program generated using the print statement or an error from the Controller.\n\n\n\n\n\n\n4) \nToolbar\n\n\n\n\n\n\nFile Name\n - The name of the file that is selected in the Working Files and open in the Program Environment.\n\n\nFile\n - Gives the option to Create, Open, Close, Save, Delete and Print a file.\n\n\nManage\n - Import or Export a file.\n\n\nHelp\n - Access controller and sensor examples as well as a link to the documentation.\n\n\n\nNew File\n - Opens a new file with Fusion import and driver lines in code.\n\n\nOpen File\n - Open a file that exists in the current user's file directory.\n\n\nSave File\n - Save the current file that is highlighted in Working Files.\n\n\nSave All Files\n - Save all the current files the Working Files.\n\n\nRun Program\n - Run the current program that is highlighted in Working Files.\n\n\nStop Program\n - Stop the current running program.\n\n\nOpen Virtual Gamepad\n - Open the Virtual Gamepad in a new tab. (Must run the program first)\n\n\n\n\n\n\n\n\nUse Guide\n\n\n\n\n1. \nCreate a program\n  \n\n\n\n\nPython Library Reference\n\n\n\n\n\n\nThe Fusion Python Library was developed by Boxlight Robotics engineers to control the Fusion Controller, motors, servos and our sensors. All available functions are documented and explained thoroughly in this document. Fusion uses Python 2.7.\n\n\n\n\n1. \nConstants\n\n\n2. \nFusion Driver\n\n\n3. \nMotor Control\n\n\n4. \nServo Control\n\n\n5. \nUSB Gamepad\n\n\n6. \nVirtual Gamepad\n\n\n7. \nCompass (45-2003)\n\n\n8. \nRate Gyro (45-2004)\n\n\n9. \nIntegrating Gyro (45-2005)\n\n\n10. \nOptical Distance Sensor (45-2006)\n\n\n11. \nTouch Sensor (45-2007)\n\n\n12. \nRange Sensor (45-2008)\n\n\n13. \nInfrared Locator 360\u00b0 (45-2009)\n\n\n14. \nLight Sensor (45-2015)\n\n\n15. \nSound Generator (45-2016)\n\n\n16. \nInfrared Seeker V3 (45-2017)\n\n\n17. \nColor Sensor (45-2018)\n\n\n18. \nColor Beacon (45-2019)\n\n\n19. \nMagnetic Sensor(45-2020)", 
            "title": "Editor Topic"
        }, 
        {
            "location": "/Editor_Topic/#editor-reference", 
            "text": "The Editor is a web-based Integrated Development Environment (IDE) targeted to more advanced users. The programming language Fusion currently supports is Python, but will soon support other languages.    A basic understanding of text-based coding and the syntax for the selected programming language is needed to use the Editor IDE.      1)  Program Environment    This is the space which contains the user code. This space supports syntax highlighting for the selected language.    2)  Working Files    Contains a list of open files. Files can be easily switched between without any loss of data. A * next to s file name indicated that it has not been saved.    3)  Program Output      Displays the output of the program generated using the print statement or an error from the Controller.    4)  Toolbar    File Name  - The name of the file that is selected in the Working Files and open in the Program Environment.  File  - Gives the option to Create, Open, Close, Save, Delete and Print a file.  Manage  - Import or Export a file.  Help  - Access controller and sensor examples as well as a link to the documentation.  New File  - Opens a new file with Fusion import and driver lines in code.  Open File  - Open a file that exists in the current user's file directory.  Save File  - Save the current file that is highlighted in Working Files.  Save All Files  - Save all the current files the Working Files.  Run Program  - Run the current program that is highlighted in Working Files.  Stop Program  - Stop the current running program.  Open Virtual Gamepad  - Open the Virtual Gamepad in a new tab. (Must run the program first)", 
            "title": "Editor Reference"
        }, 
        {
            "location": "/Editor_Topic/#use-guide", 
            "text": "1.  Create a program", 
            "title": "Use Guide"
        }, 
        {
            "location": "/Editor_Topic/#python-library-reference", 
            "text": "The Fusion Python Library was developed by Boxlight Robotics engineers to control the Fusion Controller, motors, servos and our sensors. All available functions are documented and explained thoroughly in this document. Fusion uses Python 2.7.   1.  Constants  2.  Fusion Driver  3.  Motor Control  4.  Servo Control  5.  USB Gamepad  6.  Virtual Gamepad  7.  Compass (45-2003)  8.  Rate Gyro (45-2004)  9.  Integrating Gyro (45-2005)  10.  Optical Distance Sensor (45-2006)  11.  Touch Sensor (45-2007)  12.  Range Sensor (45-2008)  13.  Infrared Locator 360\u00b0 (45-2009)  14.  Light Sensor (45-2015)  15.  Sound Generator (45-2016)  16.  Infrared Seeker V3 (45-2017)  17.  Color Sensor (45-2018)  18.  Color Beacon (45-2019)  19.  Magnetic Sensor(45-2020)", 
            "title": "Python Library Reference"
        }, 
        {
            "location": "/Diagnostic_Tool/", 
            "text": "Diagnostic Tool\n\n\n\n\nThe Diagnostic Tool is very useful when trying to find important system information, test ports or sensors and retrieve valuable information that aids the support team in diagnosing the Fusion. In the event that you are having trouble with your Fusion our support team will ask for information gathered from the \nSystem Information\n.\n\n\n\nThis tool is also useful in identifying the behavior and initial values of sensors and servos instead of having to write example programs. Refer to the \nSensor Documentation\n for an explanation of testing sensors without the use of the Blockly or Python libraries.\n\n\nRPi Performance\n\n\n\n\nHere you will get important information about the current condition of the internal Raspberry Pi. The gauges represent some information in the RPi Performance box as a percentage.\n\n\nCPU\n calculates the overall processor usage from all 4 cores of the processor. In the box the processor usage is displayed per core.\n\n\nDisk\n represents the Disk Usage as a percentage to better see how much space you have available on the SD card.\n\n\nMem\n represents the available random access memory on the Raspberry Pi. This is used to store data that is currently being used to run the operating system and any programs or processes.\n\n\nBattery Voltage\n displays the current voltage of the 6V battery. At full charge the battery is at a voltage of approximately 6.4V.\n\n\n\nClicking the \nSystem Information\n button opens a screen that displays useful information that can be used when communicating with the support team. If more information is requested from the support team, click \nFull Support Diagnostic Download\n to download a .zip file. Email this .zip file to \nsupport@BoxlightRobotics.com\n with the subject \nFusion Diagnostic Support Files\n.\n\n\n  \n\n\n\n\nOnBoard LEDs\n\n\n\n\nOn the Fusion there are 2 \nuser controlled LEDs\n. By checking the box the corresponding LED will turn on. uncheck the box to turn the LED off.\n\n\n\n\n\n\nServo Ports\n\n\n\n\nThere are 4 \nServo Ports\n on the Fusion. Checking the check box enables the servo port by supplying power to the connected servo. The port must be enabled in order change values within the box next to it. You can send the servo port a value between \n0\n to \n255\n to move its full range. Uncheck the box to disable the selected servo port and no longer supply power to the connected servo.\n\n\n\n\n\n\nMotor Control\n\n\n\n\nThere are 2 DC \nMotor Ports\n on the Fusion. Each port can take a value between \n-100\n to \n100\n. Enter a value of \n0\n to stop the selected motor or click the \n button to immediately stop both motor ports.\n\n\n\n\n\n\nAnalog Inputs\n\n\n\n\nThere are 8 \nAnalog Ports\n for reading analog inputs. The returned value from an analog port ranges from \n0\n to \n1024\n. You may notice that the value in the next port may increase if no sensor is attached. This is because it is a floating input. Once another sensor is connected to that port the value will not be manipulated by the previous port.\n\n\n\n\n\n\nDigital Ports\n\n\n\n\nThere are 8 \nDigital Ports\n for reading from or writing to a digital sensor. By default the ports are in read mode which will read inputs from digital sensors as either a \n0\n or \n1\n. Checking the check box changes the port to write mode. Then a value of \n0\n or \n1\n can be written to the attached device.\n\n\n\n\n\n\nDigital I2C Ports\n\n\n\n\nThere are 4 \nI2C Ports\n connected to a single I2C Bus on the Fusion. The first step to take when using this section is to click \nRefresh\n on the bottom left. This will populate the list on the left with the connected I2C sensors and their addresses. For a list of sensors and their I2C registers refer to the \nSensor Documentation\n.\n\nIn the first example the Fusion is reading from an Integrating Gyro with address \n0x20\n. The heading data for this sensor is 2 Bytes long, therefore \n0x04\n is entered into the \nlsb\n and \n0x05\n is entered into the \nmsb\n. This will take the values from both registers and concatenate them together. Clicking the \nRead\n button will return the current register value to the \nValue\n field. There are times where it is more efficient to constantly read from the port. To do this, check the \nPoll Read\n check box and the \nValue\n field will be constantly updated with the value read from the registers.\n\nTo read from a single register, only enter the register location into the \nlsb\n field.\n\n\n\nIn this next example the Fusion is writing to the Color Beacon with address \n0x4c\n. Writing to the Color Number(\n0x04\n) register by putting the register location into the \nlsb\n field. Next, a value of \n4\n is entered into the \nValue\n field to produce the color blue. Clicking read will write the \nValue\n to the \nRegister\n. \n\n\n  \n\n\n\n\nChange I2C Address\n\n\n\n\nChanging the I2C address is very important when using two of the same I2C sensors on the same I2C bus. For both sensors to work they must have different I2C address, otherwise they will both communicate at the same time causing garbage data to be returned.\n\nWith only \n1\n of the sensors connected, follow the instructions below to change the I2C address.\n\n\n\n    \n1.\n Click the sensor name to change the I2C address.\n2.\n Follow the on-screen insturctions to change the I2C address of the selected sensor. Click \nOK\n to set the new address to the sensor.\n3.\n Click \nRefresh\n to update the sensor list with the new address.\n\n    \n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Diagnostic Tool", 
            "title": "Diagnostic Tool"
        }, 
        {
            "location": "/Diagnostic_Tool/#diagnostic-tool", 
            "text": "The Diagnostic Tool is very useful when trying to find important system information, test ports or sensors and retrieve valuable information that aids the support team in diagnosing the Fusion. In the event that you are having trouble with your Fusion our support team will ask for information gathered from the  System Information .  \nThis tool is also useful in identifying the behavior and initial values of sensors and servos instead of having to write example programs. Refer to the  Sensor Documentation  for an explanation of testing sensors without the use of the Blockly or Python libraries.", 
            "title": "Diagnostic Tool"
        }, 
        {
            "location": "/Diagnostic_Tool/#rpi-performance", 
            "text": "Here you will get important information about the current condition of the internal Raspberry Pi. The gauges represent some information in the RPi Performance box as a percentage.  CPU  calculates the overall processor usage from all 4 cores of the processor. In the box the processor usage is displayed per core.  Disk  represents the Disk Usage as a percentage to better see how much space you have available on the SD card.  Mem  represents the available random access memory on the Raspberry Pi. This is used to store data that is currently being used to run the operating system and any programs or processes.  Battery Voltage  displays the current voltage of the 6V battery. At full charge the battery is at a voltage of approximately 6.4V.  \nClicking the  System Information  button opens a screen that displays useful information that can be used when communicating with the support team. If more information is requested from the support team, click  Full Support Diagnostic Download  to download a .zip file. Email this .zip file to  support@BoxlightRobotics.com  with the subject  Fusion Diagnostic Support Files .", 
            "title": "RPi Performance"
        }, 
        {
            "location": "/Diagnostic_Tool/#onboard-leds", 
            "text": "On the Fusion there are 2  user controlled LEDs . By checking the box the corresponding LED will turn on. uncheck the box to turn the LED off.", 
            "title": "OnBoard LEDs"
        }, 
        {
            "location": "/Diagnostic_Tool/#servo-ports", 
            "text": "There are 4  Servo Ports  on the Fusion. Checking the check box enables the servo port by supplying power to the connected servo. The port must be enabled in order change values within the box next to it. You can send the servo port a value between  0  to  255  to move its full range. Uncheck the box to disable the selected servo port and no longer supply power to the connected servo.", 
            "title": "Servo Ports"
        }, 
        {
            "location": "/Diagnostic_Tool/#motor-control", 
            "text": "There are 2 DC  Motor Ports  on the Fusion. Each port can take a value between  -100  to  100 . Enter a value of  0  to stop the selected motor or click the   button to immediately stop both motor ports.", 
            "title": "Motor Control"
        }, 
        {
            "location": "/Diagnostic_Tool/#analog-inputs", 
            "text": "There are 8  Analog Ports  for reading analog inputs. The returned value from an analog port ranges from  0  to  1024 . You may notice that the value in the next port may increase if no sensor is attached. This is because it is a floating input. Once another sensor is connected to that port the value will not be manipulated by the previous port.", 
            "title": "Analog Inputs"
        }, 
        {
            "location": "/Diagnostic_Tool/#digital-ports", 
            "text": "There are 8  Digital Ports  for reading from or writing to a digital sensor. By default the ports are in read mode which will read inputs from digital sensors as either a  0  or  1 . Checking the check box changes the port to write mode. Then a value of  0  or  1  can be written to the attached device.", 
            "title": "Digital Ports"
        }, 
        {
            "location": "/Diagnostic_Tool/#digital-i2c-ports", 
            "text": "There are 4  I2C Ports  connected to a single I2C Bus on the Fusion. The first step to take when using this section is to click  Refresh  on the bottom left. This will populate the list on the left with the connected I2C sensors and their addresses. For a list of sensors and their I2C registers refer to the  Sensor Documentation . \nIn the first example the Fusion is reading from an Integrating Gyro with address  0x20 . The heading data for this sensor is 2 Bytes long, therefore  0x04  is entered into the  lsb  and  0x05  is entered into the  msb . This will take the values from both registers and concatenate them together. Clicking the  Read  button will return the current register value to the  Value  field. There are times where it is more efficient to constantly read from the port. To do this, check the  Poll Read  check box and the  Value  field will be constantly updated with the value read from the registers. \nTo read from a single register, only enter the register location into the  lsb  field.  \nIn this next example the Fusion is writing to the Color Beacon with address  0x4c . Writing to the Color Number( 0x04 ) register by putting the register location into the  lsb  field. Next, a value of  4  is entered into the  Value  field to produce the color blue. Clicking read will write the  Value  to the  Register .", 
            "title": "Digital I2C Ports"
        }, 
        {
            "location": "/Diagnostic_Tool/#change-i2c-address", 
            "text": "Changing the I2C address is very important when using two of the same I2C sensors on the same I2C bus. For both sensors to work they must have different I2C address, otherwise they will both communicate at the same time causing garbage data to be returned. \nWith only  1  of the sensors connected, follow the instructions below to change the I2C address.  \n     1.  Click the sensor name to change the I2C address. 2.  Follow the on-screen insturctions to change the I2C address of the selected sensor. Click  OK  to set the new address to the sensor. 3.  Click  Refresh  to update the sensor list with the new address.", 
            "title": "Change I2C Address"
        }, 
        {
            "location": "/Diagnostic_Tool/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Diagnostic Tool", 
            "title": "Questions?"
        }, 
        {
            "location": "/Data_Logging_Tool/", 
            "text": "Data Logging Tool\n\n\n\n\nThe Data Logging Tool feature of the Fusion Controller allows you to collect and store readings collected from one or more sensors over a period of time. While not something that a robot might use, it is a very valuable function when conducting experiments or studying natural phenomena. For example, with an ambient light sensor, you can have the Fusion measure the light level in a greenhouse every minute over a 24 hour period to examine how light affects the plant growth. Or, using an accelerometer, you can measure the G-Forces 100 times every second while a robotic cart is rolling down an incline and crashing into a wall.\n\nThe data collected with the data logger function is stored in a delimited text file that can easily be read into a spreadsheet program and graphed for analysis or presentation.\n\n\n\n\nThe \nProfile\n tab on the top bar allows you to \nSave\n a profile, \nLoad\n a profile or \nCreate a New\n profile. Saving a profile saves the information in the \nSampling Paramters\n window as well as the selected sensors and function in the \nSensor Setup\n window. Saving profiles makes it much easy to run multiple experiments without having to remember and setup the experiment every time. \n\nThe \nFile Manager\n tab on the top bar has the options to \nExport\n and \nDelete\n log files (.txt) or profiles. Exporting a file allows you to download it to your computer so that it can be imported into a spreadsheet or graphing software. Refer to the section \nLog File Usage\n on using the log file.\n\n\nSampling Parameters\n\n\n\n\n\n\nStart Delay\n is the amount of time before the sampling will begin. This is useful for starting the sampling at a desired time without having to be present.\n\n\nDuration\n is the length of time the sampling will take place.\n\n\nPeriod\n is the time interval between samples. In the example above a same is taken every 1 second. The smallest allowed time interval between samples is 0.01 seconds.\n\n\nMax Filesize\n is a limiter on the size of a log file which, when reached, will stop the sampling. The default is set to 32,000,000 Bytes (32MB). The only reason to modify this value would be if a log file requires multiple sensors over several hours. Experiment with smaller sample sizes to get an idea of possible file sizes.\n\n\nFile Name\n is the name of the saved text files that will contain all the sampling data. Creating a text file with the same name of a file that already exists will automatically overwrite the file.\n\n\nColumn Labels\n will add the proper labels for each column at the top of the text file. Therefore when the file is imported into a spreadsheet all of the columns are properly labeled.\n\n\n\"Quote\" strings\n puts quotes around the column labels.\n\n\nDelimiter Type\n refers to how the data is separated. The data is separated by a \nTab\n, \nComma\n or \nSemicolon\n. Below are examples of how the data is produced depending on the delimiter type selected. The data displayed is organized by the following columns (based on Sensor Setup): \nTime\n, \nDigital Read\n, \nAnalog Read\n, \nGet Degrees\n.\n\n\n\n\nThe \nStart Sampling\n button will advance to the \nSampling Screen\n screen.\n\n\n\n\nSensor Setup\n\n\n\n\n\n\n\n    \nEnable\nPort\nSensor\nFunction\n\n    \nChecking this box adds the sensor to list of sensors to be sampled and logged.\nDisplays a list of available sensor ports. Select the port the sensor to be sampled is connected to.\nSelect if the sensor is Analog, Digital or one of the specific I2C sensors.\nA list of available data for the selected sensor.\n\n\n\n\nClick \nStart Sampling\n in the \nSampling Paramters\n window to advance to the \nSampling Screen\n screen.\n\n\n\n\nSampling\n\n\n\n\n\n\nStart Countdown\n is the amount of time before the sampling will begin. If you want to start sampling before the time reaches 00:00:00, click the \nStart Now\n button in the lower right hand corner of the screen.\n\n\n\nTime Remaining\n displays the time left sampling based on input from the previous page.\n\n\nCompletion\n indicates the time remaining in sampling as a percentage.\n\n\nOutput File\n is the name given on the previous screen. Once sampling is concluded a text file (.txt) will be saved.  \n\n\nReal-Time Sensor Data\n displays what the sensors are currently reading.\n\n\nFile Output\n displays a preview of the data that will be contained in the log file.\n\n\n\n\nLog File Usage\n\n\n\n\nOnce the sampling is complete and a log file is saved, the next step is to display the data in a meaningful way. Go to \nFile Manager\n and select \nExport\n to save the file to your local computer.\n\n\nSelect the name of the log file you just created and click \nExport\n to download it locally.\n\nFor this example we will use Microsoft Excel to display the information from the sampling.  \n\n\n\n\nOpen a \nBlank workbook\n after opening Excel.\n\n\n\n\nClick the \nData\n tab and select \nForm Text/CSV\n.\n\n\n\n\nA preview of your data will be displayed. Click \nLoad\n to open the data in a spreadsheet. \n\n\n\nThe spreadsheet now contains all the sampling data from the previously run experiment.\n\n\n\n\nThe next step to take would be to make graphs or some sort of visual display to represent the data. Below is an example of a \nLight Sensor\n reading the ambient light levels from before sunset to after sunrise.\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Data Logging Tool", 
            "title": "Data Logging Tool"
        }, 
        {
            "location": "/Data_Logging_Tool/#data-logging-tool", 
            "text": "The Data Logging Tool feature of the Fusion Controller allows you to collect and store readings collected from one or more sensors over a period of time. While not something that a robot might use, it is a very valuable function when conducting experiments or studying natural phenomena. For example, with an ambient light sensor, you can have the Fusion measure the light level in a greenhouse every minute over a 24 hour period to examine how light affects the plant growth. Or, using an accelerometer, you can measure the G-Forces 100 times every second while a robotic cart is rolling down an incline and crashing into a wall. \nThe data collected with the data logger function is stored in a delimited text file that can easily be read into a spreadsheet program and graphed for analysis or presentation.   The  Profile  tab on the top bar allows you to  Save  a profile,  Load  a profile or  Create a New  profile. Saving a profile saves the information in the  Sampling Paramters  window as well as the selected sensors and function in the  Sensor Setup  window. Saving profiles makes it much easy to run multiple experiments without having to remember and setup the experiment every time.  \nThe  File Manager  tab on the top bar has the options to  Export  and  Delete  log files (.txt) or profiles. Exporting a file allows you to download it to your computer so that it can be imported into a spreadsheet or graphing software. Refer to the section  Log File Usage  on using the log file.", 
            "title": "Data Logging Tool"
        }, 
        {
            "location": "/Data_Logging_Tool/#sampling-parameters", 
            "text": "Start Delay  is the amount of time before the sampling will begin. This is useful for starting the sampling at a desired time without having to be present.  Duration  is the length of time the sampling will take place.  Period  is the time interval between samples. In the example above a same is taken every 1 second. The smallest allowed time interval between samples is 0.01 seconds.  Max Filesize  is a limiter on the size of a log file which, when reached, will stop the sampling. The default is set to 32,000,000 Bytes (32MB). The only reason to modify this value would be if a log file requires multiple sensors over several hours. Experiment with smaller sample sizes to get an idea of possible file sizes.  File Name  is the name of the saved text files that will contain all the sampling data. Creating a text file with the same name of a file that already exists will automatically overwrite the file.  Column Labels  will add the proper labels for each column at the top of the text file. Therefore when the file is imported into a spreadsheet all of the columns are properly labeled.  \"Quote\" strings  puts quotes around the column labels.  Delimiter Type  refers to how the data is separated. The data is separated by a  Tab ,  Comma  or  Semicolon . Below are examples of how the data is produced depending on the delimiter type selected. The data displayed is organized by the following columns (based on Sensor Setup):  Time ,  Digital Read ,  Analog Read ,  Get Degrees .   The  Start Sampling  button will advance to the  Sampling Screen  screen.", 
            "title": "Sampling Parameters"
        }, 
        {
            "location": "/Data_Logging_Tool/#sensor-setup", 
            "text": "Enable Port Sensor Function \n     Checking this box adds the sensor to list of sensors to be sampled and logged. Displays a list of available sensor ports. Select the port the sensor to be sampled is connected to. Select if the sensor is Analog, Digital or one of the specific I2C sensors. A list of available data for the selected sensor.   Click  Start Sampling  in the  Sampling Paramters  window to advance to the  Sampling Screen  screen.", 
            "title": "Sensor Setup"
        }, 
        {
            "location": "/Data_Logging_Tool/#sampling", 
            "text": "Start Countdown  is the amount of time before the sampling will begin. If you want to start sampling before the time reaches 00:00:00, click the  Start Now  button in the lower right hand corner of the screen.  Time Remaining  displays the time left sampling based on input from the previous page.  Completion  indicates the time remaining in sampling as a percentage.  Output File  is the name given on the previous screen. Once sampling is concluded a text file (.txt) will be saved.    Real-Time Sensor Data  displays what the sensors are currently reading.  File Output  displays a preview of the data that will be contained in the log file.", 
            "title": "Sampling"
        }, 
        {
            "location": "/Data_Logging_Tool/#log-file-usage", 
            "text": "Once the sampling is complete and a log file is saved, the next step is to display the data in a meaningful way. Go to  File Manager  and select  Export  to save the file to your local computer. \nSelect the name of the log file you just created and click  Export  to download it locally. \nFor this example we will use Microsoft Excel to display the information from the sampling.     Open a  Blank workbook  after opening Excel.   Click the  Data  tab and select  Form Text/CSV .   A preview of your data will be displayed. Click  Load  to open the data in a spreadsheet.   The spreadsheet now contains all the sampling data from the previously run experiment.   The next step to take would be to make graphs or some sort of visual display to represent the data. Below is an example of a  Light Sensor  reading the ambient light levels from before sunset to after sunrise.", 
            "title": "Log File Usage"
        }, 
        {
            "location": "/Data_Logging_Tool/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Data Logging Tool", 
            "title": "Questions?"
        }, 
        {
            "location": "/Robot_Building_Topic/", 
            "text": "Robot Building Instructions\n\n\n\n\nThe Fusion Controller is complimented by the MyBot Base Kit, a versatile and robust metal building system. The system features 4mm holes placed on a standard 8mm by 8mm grid to simplify adding mechanical parts and sensors. In addition to a variety of sensors, there are a number of 3D printable parts designs which can be downloaded and printed to expand the capabilities and learning opportunities of your robot.\n\n\nThe MyBot Base Kit has been supplied with some different components, requiring different assembly instructions.\n\n\n\n\nThe easiest way to determining the instructions you will use to assemble your MyBot Base kit is to \nlook at the wheels\n supplied with the kit.  Then, click on the appropriate tile below to view step-by-step assembly instructions for your MyBot Kit:\n\n\n\n\nSelect the Proper Assembly Instructions for your Robot", 
            "title": "Robot Building Instructions"
        }, 
        {
            "location": "/Robot_Building_Topic/#robot-building-instructions", 
            "text": "The Fusion Controller is complimented by the MyBot Base Kit, a versatile and robust metal building system. The system features 4mm holes placed on a standard 8mm by 8mm grid to simplify adding mechanical parts and sensors. In addition to a variety of sensors, there are a number of 3D printable parts designs which can be downloaded and printed to expand the capabilities and learning opportunities of your robot.  The MyBot Base Kit has been supplied with some different components, requiring different assembly instructions.   The easiest way to determining the instructions you will use to assemble your MyBot Base kit is to  look at the wheels  supplied with the kit.  Then, click on the appropriate tile below to view step-by-step assembly instructions for your MyBot Kit:", 
            "title": "Robot Building Instructions"
        }, 
        {
            "location": "/Robot_Building_Topic/#select-the-proper-assembly-instructions-for-your-robot", 
            "text": "", 
            "title": "Select the Proper Assembly Instructions for your Robot"
        }, 
        {
            "location": "/Robot_Building_Topic_2/", 
            "text": "Robot Building Instructions\n\n\n\n\nThe Fusion Controller is complimented with a versatile and robust metal building system. The building system features 4mm holes placed on a standard 8mm by 8mm grid to simplify adding mechanical parts and sensors. In addition to a variety of sensors, we have a number of 3D printable parts designs which can be downloaded and printed to expand the capabilities and learning opportunities of your robot.\n\n\nClick on the tiles below to view step-by-step assembly instructions for your MyBot Kit:\n\n\nAssembling the Basic Kits\n\n\n\n\n\n\nModifications for Adding New Sensors\n\n\n\n\n\n\nLegacy Build Instructions\n\n\nIf you have an Original MyBot Base Kit and need to review the instructions or update your unit to accommodate the Planetary Exploration Sensor Pack, please use the links below. Original Base Kit builds are easily identified by looking at the motor mounting brackets; if they touch the 3 hole by 5 hole plates, your kit was built using the original instructions.  Complete step-by-step modification instructions are provided to add the Planetary Exploration Sensor Pack to your original base kit.  \n\n\nClick here for the original MyBot/Fusion Base Kit Build Instructions:  \n\n\nClick here if you're adding a Planetary Exploration Sensor Pack to an original basekit:", 
            "title": "Robot Building Instructions 2"
        }, 
        {
            "location": "/Robot_Building_Topic_2/#robot-building-instructions", 
            "text": "The Fusion Controller is complimented with a versatile and robust metal building system. The building system features 4mm holes placed on a standard 8mm by 8mm grid to simplify adding mechanical parts and sensors. In addition to a variety of sensors, we have a number of 3D printable parts designs which can be downloaded and printed to expand the capabilities and learning opportunities of your robot.  Click on the tiles below to view step-by-step assembly instructions for your MyBot Kit:", 
            "title": "Robot Building Instructions"
        }, 
        {
            "location": "/Robot_Building_Topic_2/#assembling-the-basic-kits", 
            "text": "", 
            "title": "Assembling the Basic Kits"
        }, 
        {
            "location": "/Robot_Building_Topic_2/#modifications-for-adding-new-sensors", 
            "text": "", 
            "title": "Modifications for Adding New Sensors"
        }, 
        {
            "location": "/Robot_Building_Topic_2/#legacy-build-instructions", 
            "text": "If you have an Original MyBot Base Kit and need to review the instructions or update your unit to accommodate the Planetary Exploration Sensor Pack, please use the links below. Original Base Kit builds are easily identified by looking at the motor mounting brackets; if they touch the 3 hole by 5 hole plates, your kit was built using the original instructions.  Complete step-by-step modification instructions are provided to add the Planetary Exploration Sensor Pack to your original base kit.", 
            "title": "Legacy Build Instructions"
        }, 
        {
            "location": "/Robot_Building_Topic_2/#click-here-for-the-original-mybotfusion-base-kit-build-instructions", 
            "text": "", 
            "title": "Click here for the original MyBot/Fusion Base Kit Build Instructions:  "
        }, 
        {
            "location": "/Robot_Building_Topic_2/#click-here-if-youre-adding-a-planetary-exploration-sensor-pack-to-an-original-basekit", 
            "text": "", 
            "title": "Click here if you're adding a Planetary Exploration Sensor Pack to an original basekit:  "
        }, 
        {
            "location": "/Missing_Items/", 
            "text": "Missing items from your Fusion?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed list of the items you are missing. Include description of the missing parts along with the part number and order number will help us better serve you. \n\n\n\n\nEmail Subject\n: Fusion Missing Items", 
            "title": "Missing Items"
        }, 
        {
            "location": "/Missing_Items/#missing-items-from-your-fusion", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed list of the items you are missing. Include description of the missing parts along with the part number and order number will help us better serve you.    Email Subject : Fusion Missing Items", 
            "title": "Missing items from your Fusion?"
        }, 
        {
            "location": "/Connect_USB_Power/", 
            "text": "Connect USB power\n\n\n\n\nConnect Fusion with supplied USB cable\n\n\n\n\nThe USB cable included with you Fusion is a USB-Micro to USB-A cable. \n\n\nThe micro end of the cable connects to the Fusion via the USB-Micro port on the side of the controller. This port is for power only and does not transfer any data. The standard USB-A end of the cable connects to the computer or power supply capable of 5V at a minimum of 500mA.\n\n\n\nOnce connected, a green LED near the Micro USB port will illuminate to show that the Fusion is connected to power.\n\n\n\n\nTry Another USB-A port\n\n\n\n\nIf the USB LED is not turning on when the USB cable is connected, try connecting the USB-A end of the cable into another USB port.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion USB Power", 
            "title": "Connect USB Power"
        }, 
        {
            "location": "/Connect_USB_Power/#connect-usb-power", 
            "text": "", 
            "title": "Connect USB power"
        }, 
        {
            "location": "/Connect_USB_Power/#connect-fusion-with-supplied-usb-cable", 
            "text": "The USB cable included with you Fusion is a USB-Micro to USB-A cable.  \nThe micro end of the cable connects to the Fusion via the USB-Micro port on the side of the controller. This port is for power only and does not transfer any data. The standard USB-A end of the cable connects to the computer or power supply capable of 5V at a minimum of 500mA.  \nOnce connected, a green LED near the Micro USB port will illuminate to show that the Fusion is connected to power.", 
            "title": "Connect Fusion with supplied USB cable"
        }, 
        {
            "location": "/Connect_USB_Power/#try-another-usb-a-port", 
            "text": "If the USB LED is not turning on when the USB cable is connected, try connecting the USB-A end of the cable into another USB port.", 
            "title": "Try Another USB-A port"
        }, 
        {
            "location": "/Connect_USB_Power/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion USB Power", 
            "title": "Questions?"
        }, 
        {
            "location": "/Power_On/", 
            "text": "Power the Fusion on\n\n\n\n\nFusion Power Button (PWR)\n\n\n\n\nFirst, check to see that you have power connected to either \nUSB\n or an approved \n6V Battery\n.\n\nSimply pressing the power button will cause the LEDs on board to flash, but not turn the Fusion on. The power button must be held down for 2 sec in order to turn on the power and start the system.\n\n\nOnce powered on, a green LED under the Fusion logo will start flashing while the system boots up. This process takes approximately 30 seconds.\n\nWhen the LED stays solid, the systems is ready for use.\n\n\n\n\n\nWhat if it doesn't stop blinking?\n\n\n\n\nIf the Fusion was recently updated, it may take up to 2 minutes for the system boot up process to complete.\n\nIf the LED continues to blink, \npower off\n the Fusion by holding down on the power button until the power LED turns off. Wait a few seconds, before pressing the power button to turn the Fusion back on.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Power Issue", 
            "title": "Power On"
        }, 
        {
            "location": "/Power_On/#power-the-fusion-on", 
            "text": "", 
            "title": "Power the Fusion on"
        }, 
        {
            "location": "/Power_On/#fusion-power-button-pwr", 
            "text": "First, check to see that you have power connected to either  USB  or an approved  6V Battery . \nSimply pressing the power button will cause the LEDs on board to flash, but not turn the Fusion on. The power button must be held down for 2 sec in order to turn on the power and start the system. \nOnce powered on, a green LED under the Fusion logo will start flashing while the system boots up. This process takes approximately 30 seconds. \nWhen the LED stays solid, the systems is ready for use.", 
            "title": "Fusion Power Button (PWR)"
        }, 
        {
            "location": "/Power_On/#what-if-it-doesnt-stop-blinking", 
            "text": "If the Fusion was recently updated, it may take up to 2 minutes for the system boot up process to complete. \nIf the LED continues to blink,  power off  the Fusion by holding down on the power button until the power LED turns off. Wait a few seconds, before pressing the power button to turn the Fusion back on.", 
            "title": "What if it doesn't stop blinking?"
        }, 
        {
            "location": "/Power_On/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Power Issue", 
            "title": "Questions?"
        }, 
        {
            "location": "/Power_Off/", 
            "text": "Power down the Fusion\n\n\n\n\nShutdown the Fusion with the on-board power button (PWR)\n\n\n\n\n(\nSoft Shutdown\n)  \n\n\n\n\nThe recommended method to power off the Fusion is to press the power button once when the Status LED is solid. This will send the power off command to the RaspberryPi and safely power down the Fusion.  \n\n\n\n\n(\nHard Shutdown\n) \n\n\n\n\nThe second method to power off the Fusion is to hold down the power button for 4 seconds until the power LED turns off. This can be done at any time, however does not safely shutdown the Fusion and should only be used if the \nsoft shutdown\n did not work.\n\n\n\n\n\n\n\nPowering down the Fusion with the web interface.\n\n\n\n\nThere is also an option to power the Fusion down within the web interface.\n\n\n\n\n\n\nGo to the top right corner of the Fusion Web Interface\n\n\nSelect the power icon on the right.\n\n\nSelect one of the following options:  \n\n\n\n\nLogout\n - Exit the current user account.  \n\n\nPower Off\n - Safely power down the Fusion.  \n\n\nRestart\n - Power down the Fusion and immediately power back on.\n\n\n\n\n\n\n\n\n\n\nPower Off\n and \nRestart\n will disconnect your computer from the Fusion Access Point.\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Power Down", 
            "title": "Power Off"
        }, 
        {
            "location": "/Power_Off/#power-down-the-fusion", 
            "text": "", 
            "title": "Power down the Fusion"
        }, 
        {
            "location": "/Power_Off/#shutdown-the-fusion-with-the-on-board-power-button-pwr", 
            "text": "( Soft Shutdown )     The recommended method to power off the Fusion is to press the power button once when the Status LED is solid. This will send the power off command to the RaspberryPi and safely power down the Fusion.     ( Hard Shutdown )    The second method to power off the Fusion is to hold down the power button for 4 seconds until the power LED turns off. This can be done at any time, however does not safely shutdown the Fusion and should only be used if the  soft shutdown  did not work.", 
            "title": "Shutdown the Fusion with the on-board power button (PWR)"
        }, 
        {
            "location": "/Power_Off/#powering-down-the-fusion-with-the-web-interface", 
            "text": "There is also an option to power the Fusion down within the web interface.    Go to the top right corner of the Fusion Web Interface  Select the power icon on the right.  Select one of the following options:     Logout  - Exit the current user account.    Power Off  - Safely power down the Fusion.    Restart  - Power down the Fusion and immediately power back on.      Power Off  and  Restart  will disconnect your computer from the Fusion Access Point.", 
            "title": "Powering down the Fusion with the web interface."
        }, 
        {
            "location": "/Power_Off/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Power Down", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Find/", 
            "text": "Find/Connect Fusion Access Point\n\n\n\n\nFind default Fusion Access Point\n\n\n\n\nEach Fusion has its own unique access point Service Set Identifier (SSID) assigned to it. The access point starts with \nFusionAP_\n followed by a 6 digit alphanumeric value  unique to each controller. Therefore a valid Fusion Access Point is \nFusionAP_99be01\n.  \n\n\nThis access point can be connected to via Wi-Fi from a device capable of Wi-Fi and browser access (i.e. computer).\nUsing the device's Wi-Fi capabilities, find the Fusion Access Point and connect to it.  \n\n\n\n\nConnect via Windows\n  \n\n\nConnect via Mac\n\n\nConnect via Linux\n  \n\n\nConnect via iOS\n  \n\n\nConnect via Android\n\n\n\n\n\n\nConnect to the default Fusion Access Point\n\n\n\n\nSelect the Fusion Access Point that matches the SSID on the bottom of your controller (also inside box) to the SSID found.\n\nThe default Fusion passkey is \nmrifusion\n.\n\n\nOnce connected, open your web browser (Google Chrome recommended) and follow the steps to \naccess to the web interface\n.\n\n\n\n\nFor instructions on changing the Fusion Access Point SSID and Passkey, refer to \nChange Fusion Access Point\n instructions.\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Find/Connect to Fusion", 
            "title": "Find/Connect FusionAP"
        }, 
        {
            "location": "/AP_Find/#findconnect-fusion-access-point", 
            "text": "", 
            "title": "Find/Connect Fusion Access Point"
        }, 
        {
            "location": "/AP_Find/#find-default-fusion-access-point", 
            "text": "Each Fusion has its own unique access point Service Set Identifier (SSID) assigned to it. The access point starts with  FusionAP_  followed by a 6 digit alphanumeric value  unique to each controller. Therefore a valid Fusion Access Point is  FusionAP_99be01 .    This access point can be connected to via Wi-Fi from a device capable of Wi-Fi and browser access (i.e. computer).\nUsing the device's Wi-Fi capabilities, find the Fusion Access Point and connect to it.     Connect via Windows     Connect via Mac  Connect via Linux     Connect via iOS     Connect via Android", 
            "title": "Find default Fusion Access Point"
        }, 
        {
            "location": "/AP_Find/#connect-to-the-default-fusion-access-point", 
            "text": "Select the Fusion Access Point that matches the SSID on the bottom of your controller (also inside box) to the SSID found. \nThe default Fusion passkey is  mrifusion . \nOnce connected, open your web browser (Google Chrome recommended) and follow the steps to  access to the web interface .   For instructions on changing the Fusion Access Point SSID and Passkey, refer to  Change Fusion Access Point  instructions.", 
            "title": "Connect to the default Fusion Access Point"
        }, 
        {
            "location": "/AP_Find/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Find/Connect to Fusion", 
            "title": "Questions?"
        }, 
        {
            "location": "/Accessing_Web_Interface/", 
            "text": "Accessing the Fusion Web Interface\n\n\n\n\nWe recommend using Google Chrome for the Fusion Web Interface.\n\n\nConnecting to the Fusion Web Interface\n\n\n\n\n1.\n Open your browser (\nGoogle Chrome\n) and click on the address bar on top.\n\n\n2.\n Type \nmy.bot\n into the address bar of your browser. To connect using an IP address, type 192.168.50.1:8080 into the address bar.\n\n\n3.\n Click \"Go To\" or press your Enter key on your keyboard to go to that address.\n\n\nYou should now be connected to the Fusion Web Interface by being presented with the login screen.\n\n\nNow you can either login with as the guest or an existing account previously created.\n\nIf you do not have an account, follow the steps to \ncreate an accont\n.\n\n\n\n\nError \"This site can't be reached\"\n\n\n\n\nIf you are having trouble accessing the Fusion Web Interface follow the steps below.  \n\n\n\n\n1.\n Make sure you are connected to the \nFusion Access Point\n and try again. \n\n\n2.\n If that does not work, try restarting the Fusion by \npowering off\n and \npowering on\n.\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Accesing Fusion Web Interface", 
            "title": "Accessing Web Interface"
        }, 
        {
            "location": "/Accessing_Web_Interface/#accessing-the-fusion-web-interface", 
            "text": "We recommend using Google Chrome for the Fusion Web Interface.", 
            "title": "Accessing the Fusion Web Interface"
        }, 
        {
            "location": "/Accessing_Web_Interface/#connecting-to-the-fusion-web-interface", 
            "text": "1.  Open your browser ( Google Chrome ) and click on the address bar on top.  2.  Type  my.bot  into the address bar of your browser. To connect using an IP address, type 192.168.50.1:8080 into the address bar.  3.  Click \"Go To\" or press your Enter key on your keyboard to go to that address.  You should now be connected to the Fusion Web Interface by being presented with the login screen. \nNow you can either login with as the guest or an existing account previously created. \nIf you do not have an account, follow the steps to  create an accont .", 
            "title": "Connecting to the Fusion Web Interface"
        }, 
        {
            "location": "/Accessing_Web_Interface/#error-this-site-cant-be-reached", 
            "text": "If you are having trouble accessing the Fusion Web Interface follow the steps below.     1.  Make sure you are connected to the  Fusion Access Point  and try again.   2.  If that does not work, try restarting the Fusion by  powering off  and  powering on .", 
            "title": "Error \"This site can't be reached\""
        }, 
        {
            "location": "/Accessing_Web_Interface/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Accesing Fusion Web Interface", 
            "title": "Questions?"
        }, 
        {
            "location": "/Account_Create/", 
            "text": "Create an Account\n\n\n\n\nCreate an account from the login screen\n\n\n\n\n1.\n When presented with the login screen, click \nREGISTER\n to start the registration process.\n\n\n\n2.\n Enter your information into the registration form. Fields marked with a * are required while the other fields may be left blank. In the \nUser Group\n, you can select from \nAdmin\n or \nUser\n.  \n\n\nIf this is your first time creating an account, we recommend making an administrator account. Only 1 administrator account can be created from the login screen. Additional administrator accounts can be created from the \nUser Settings\n\n\n\nClick \nRegister\n once you have completed the form. You will then be directed to the Fusion Web Interface home screen.\n\n\n\n\n\nCreate an account from the user settings screen\n\n\n\n\nYou must be logged into an administrator account to create additional users from the settings.\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nUSERS\n menu.  \n\n\n3.\n Select the \nADD NEW\n button to add a new user.\n\n\n4.\n Enter your information into the registration form. Fields marked with a * are required while the other fields may be left blank. In the \nUser Group\n, you can select from \nAdmin\n or \nUser\n.\n\n\nClick \nCREATE\n once you have completed the form. \n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Creating a Fusion Account", 
            "title": "Create Account"
        }, 
        {
            "location": "/Account_Create/#create-an-account", 
            "text": "", 
            "title": "Create an Account"
        }, 
        {
            "location": "/Account_Create/#create-an-account-from-the-login-screen", 
            "text": "1.  When presented with the login screen, click  REGISTER  to start the registration process.  2.  Enter your information into the registration form. Fields marked with a * are required while the other fields may be left blank. In the  User Group , you can select from  Admin  or  User .    If this is your first time creating an account, we recommend making an administrator account. Only 1 administrator account can be created from the login screen. Additional administrator accounts can be created from the  User Settings  \nClick  Register  once you have completed the form. You will then be directed to the Fusion Web Interface home screen.", 
            "title": "Create an account from the login screen"
        }, 
        {
            "location": "/Account_Create/#create-an-account-from-the-user-settings-screen", 
            "text": "You must be logged into an administrator account to create additional users from the settings.  1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  USERS  menu.    3.  Select the  ADD NEW  button to add a new user.  4.  Enter your information into the registration form. Fields marked with a * are required while the other fields may be left blank. In the  User Group , you can select from  Admin  or  User . \nClick  CREATE  once you have completed the form.", 
            "title": "Create an account from the user settings screen"
        }, 
        {
            "location": "/Account_Create/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Creating a Fusion Account", 
            "title": "Questions?"
        }, 
        {
            "location": "/Account_Edit/", 
            "text": "Edit an Account\n\n\n\n\nEdit an account from the user settings screen\n\n\n\n\nYou must be logged into an administrator account to edit a current user account.\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nUSERS\n menu.\n\n\n3.\n Select the blue \nEDIT\n button to add a new user.\n\n\n4.\n Modify the information in the registration form. Fields marked with a * are required while the other fields may be left blank.\n\n\nClick \nUPDATE\n once you are done updating the form. \n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Editing a Fusion Account", 
            "title": "Edit Account"
        }, 
        {
            "location": "/Account_Edit/#edit-an-account", 
            "text": "", 
            "title": "Edit an Account"
        }, 
        {
            "location": "/Account_Edit/#edit-an-account-from-the-user-settings-screen", 
            "text": "You must be logged into an administrator account to edit a current user account.  1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  USERS  menu.  3.  Select the blue  EDIT  button to add a new user.  4.  Modify the information in the registration form. Fields marked with a * are required while the other fields may be left blank. \nClick  UPDATE  once you are done updating the form.", 
            "title": "Edit an account from the user settings screen"
        }, 
        {
            "location": "/Account_Edit/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Editing a Fusion Account", 
            "title": "Questions?"
        }, 
        {
            "location": "/Account_Delete/", 
            "text": "Delete an Account\n\n\n\n\nDelete an account from the user settings screen\n\n\n\n\nYou must be logged into an administrator account to delete users.\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nUSERS\n menu.\n\n\n3.\n Select the red \nDELETE\n button to add a new user.\n\n\n4.\n Confirm that you want to delete the user by selecting \"\nOKAY!\n\".\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Deleting a Fusion Account", 
            "title": "Delete Account"
        }, 
        {
            "location": "/Account_Delete/#delete-an-account", 
            "text": "", 
            "title": "Delete an Account"
        }, 
        {
            "location": "/Account_Delete/#delete-an-account-from-the-user-settings-screen", 
            "text": "You must be logged into an administrator account to delete users.  1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  USERS  menu.  3.  Select the red  DELETE  button to add a new user.  4.  Confirm that you want to delete the user by selecting \" OKAY! \".", 
            "title": "Delete an account from the user settings screen"
        }, 
        {
            "location": "/Account_Delete/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Deleting a Fusion Account", 
            "title": "Questions?"
        }, 
        {
            "location": "/Connect_Battery/", 
            "text": "Connecting a battery\n\n\n\n\nHow to connect the battery\n\n\n\n\nConnect the Fusion Battery pack for a truly wireless experience. The Fusion uses a 6V 2200mAh Ni-MH battery with a polarized connection designed to have the power on the left and the ground on the right. The battery has a keyed connection that only allows for it to be connected to the battery port in one direction.\n\n\n\nDO NOT\n connect any other power source to the battery port. Only use the Fusion 6V Battery with Fusion. Using another power source or reverse polarity could permanently damage your Fusion.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connecting Fusion Battery", 
            "title": "Connecting Battery"
        }, 
        {
            "location": "/Connect_Battery/#connecting-a-battery", 
            "text": "", 
            "title": "Connecting a battery"
        }, 
        {
            "location": "/Connect_Battery/#how-to-connect-the-battery", 
            "text": "Connect the Fusion Battery pack for a truly wireless experience. The Fusion uses a 6V 2200mAh Ni-MH battery with a polarized connection designed to have the power on the left and the ground on the right. The battery has a keyed connection that only allows for it to be connected to the battery port in one direction.  DO NOT  connect any other power source to the battery port. Only use the Fusion 6V Battery with Fusion. Using another power source or reverse polarity could permanently damage your Fusion.", 
            "title": "How to connect the battery"
        }, 
        {
            "location": "/Connect_Battery/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connecting Fusion Battery", 
            "title": "Questions?"
        }, 
        {
            "location": "/Charge_Battery/", 
            "text": "Charging the Fusion battery\n\n\n\n\nHow to charge the battery\n\n\n\n\nTo charge the Fusion battery pack, first make sure the \nbattery is connected\n.\n\n\nThen connect the accompanying battery charger to the CHRG port on the Fusion. \nThe Fusion must be off in order to charge the battery.\n  If the Fusion is on while the battery and charger are connected, the battery will not be charged. \n\n\nThe charger must be plugged in to the CHRG port as shown, with the BLACK wire to the right in the battery will not be charged.\n\n\n\n\nWhen the charger is connected and charging the battery, the light on the charger will turn red. Once the battery is fully charged the light will turn green. The charger may get warm when charging a battery..\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Charging the Fusion Battery", 
            "title": "Charge Battery"
        }, 
        {
            "location": "/Charge_Battery/#charging-the-fusion-battery", 
            "text": "", 
            "title": "Charging the Fusion battery"
        }, 
        {
            "location": "/Charge_Battery/#how-to-charge-the-battery", 
            "text": "To charge the Fusion battery pack, first make sure the  battery is connected .  Then connect the accompanying battery charger to the CHRG port on the Fusion.  The Fusion must be off in order to charge the battery.   If the Fusion is on while the battery and charger are connected, the battery will not be charged.   The charger must be plugged in to the CHRG port as shown, with the BLACK wire to the right in the battery will not be charged.   When the charger is connected and charging the battery, the light on the charger will turn red. Once the battery is fully charged the light will turn green. The charger may get warm when charging a battery..", 
            "title": "How to charge the battery"
        }, 
        {
            "location": "/Charge_Battery/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Charging the Fusion Battery", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Windows/", 
            "text": "Connect to Fusion via Windows\n\n\n\n\nSteps to connect with Windows\n\n\n\n\n1.\n Turn on your computer's Wi-Fi capabilities. Click on the Wi-Fi symbol in the toolbar in the lower right hand corner.\n\n\n\n2.\n Find the Fusion Access Point SSID and select \"Connect\" to enter the passkey (i.e. \nFusionAP_99be01\n).\n\n\n\n3.\n Enter the passkey for your Fusion. Then click \"Next\" to connect.\n\nDefault Passkey: \nmrifusion\n\n\n\n\n4.\n Your Fusion is now connected to your Windows computer.\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connect Fusion via Windows", 
            "title": "Connect Windows"
        }, 
        {
            "location": "/AP_Windows/#connect-to-fusion-via-windows", 
            "text": "", 
            "title": "Connect to Fusion via Windows"
        }, 
        {
            "location": "/AP_Windows/#steps-to-connect-with-windows", 
            "text": "1.  Turn on your computer's Wi-Fi capabilities. Click on the Wi-Fi symbol in the toolbar in the lower right hand corner.  2.  Find the Fusion Access Point SSID and select \"Connect\" to enter the passkey (i.e.  FusionAP_99be01 ).  3.  Enter the passkey for your Fusion. Then click \"Next\" to connect. \nDefault Passkey:  mrifusion   4.  Your Fusion is now connected to your Windows computer.", 
            "title": "Steps to connect with Windows"
        }, 
        {
            "location": "/AP_Windows/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connect Fusion via Windows", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Mac/", 
            "text": "Connect to Fusion via Mac\n\n\n\n\nSteps to connect with Mac\n\n\n\n\n1.\n Turn on your computer's Wi-Fi capabilities. Click on the Wi-Fi symbol in the toolbar in the upper right hand corner.\n\n\n\n\n2.\n Find the Fusion Access Point SSID and select it to enter the passkey (i.e. \nFusionAP_99be01\n).\n\n\n\n\n3.\n Enter the passkey for your Fusion. Then click \"Join\" to connect.\n\nDefault Passkey: \nmrifusion\n\n\n\n\n4.\n Your Fusion is now connected to your Mac computer.\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connect Fusion via Mac", 
            "title": "Connect Mac"
        }, 
        {
            "location": "/AP_Mac/#connect-to-fusion-via-mac", 
            "text": "", 
            "title": "Connect to Fusion via Mac"
        }, 
        {
            "location": "/AP_Mac/#steps-to-connect-with-mac", 
            "text": "1.  Turn on your computer's Wi-Fi capabilities. Click on the Wi-Fi symbol in the toolbar in the upper right hand corner.   2.  Find the Fusion Access Point SSID and select it to enter the passkey (i.e.  FusionAP_99be01 ).   3.  Enter the passkey for your Fusion. Then click \"Join\" to connect. \nDefault Passkey:  mrifusion   4.  Your Fusion is now connected to your Mac computer.", 
            "title": "Steps to connect with Mac"
        }, 
        {
            "location": "/AP_Mac/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connect Fusion via Mac", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Linux/", 
            "text": "Connect to Fusion via Linux\n\n\n\n\nSteps to connect with Linux\n\n\n\n\n1.\n Turn on your computer's Wi-Fi capabilities. Click on the Wi-Fi symbol in the toolbar in the upper right hand corner.\n\n\n\n2.\n Find the Fusion Access Point SSID and select it to enter the passkey (i.e. \nFusionAP_99be01\n).\n\n\n\n3.\n Enter the passkey for your Fusion. Then click \"OK\" to connect.\n\nDefault Passkey: \nmrifusion\n\n\n\n\n4.\n Your Fusion is now connected to your Linux computer.\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connect Fusion via Linux", 
            "title": "Connect Linux"
        }, 
        {
            "location": "/AP_Linux/#connect-to-fusion-via-linux", 
            "text": "", 
            "title": "Connect to Fusion via Linux"
        }, 
        {
            "location": "/AP_Linux/#steps-to-connect-with-linux", 
            "text": "1.  Turn on your computer's Wi-Fi capabilities. Click on the Wi-Fi symbol in the toolbar in the upper right hand corner.  2.  Find the Fusion Access Point SSID and select it to enter the passkey (i.e.  FusionAP_99be01 ).  3.  Enter the passkey for your Fusion. Then click \"OK\" to connect. \nDefault Passkey:  mrifusion   4.  Your Fusion is now connected to your Linux computer.", 
            "title": "Steps to connect with Linux"
        }, 
        {
            "location": "/AP_Linux/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connect Fusion via Linux", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_iOS/", 
            "text": "Connect to Fusion via iOS\n\n\n\n\nSteps to connect with iOS\n\n\n\n\n1.\n Find and open the Settings App on your iPhone/iPad.\n\n\n\n2.\n Once the settings menu is open, select Wi-Fi.\n\n\n\n3.\n Find the Fusion Access Point SSID and select it to enter the passkey(i.e. \nFusionAP_99be01\n).\n\n\n\n4.\n Enter the passkey for your Fusion. Then select \"Join\" to connect.\n\nDefault Passkey: \nmrifusion\n\n\n\n\n5.\n Your Fusion is now connected to your iOS device.\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connect Fusion via iOS", 
            "title": "Connect iOS"
        }, 
        {
            "location": "/AP_iOS/#connect-to-fusion-via-ios", 
            "text": "", 
            "title": "Connect to Fusion via iOS"
        }, 
        {
            "location": "/AP_iOS/#steps-to-connect-with-ios", 
            "text": "1.  Find and open the Settings App on your iPhone/iPad.  2.  Once the settings menu is open, select Wi-Fi.  3.  Find the Fusion Access Point SSID and select it to enter the passkey(i.e.  FusionAP_99be01 ).  4.  Enter the passkey for your Fusion. Then select \"Join\" to connect. \nDefault Passkey:  mrifusion   5.  Your Fusion is now connected to your iOS device.", 
            "title": "Steps to connect with iOS"
        }, 
        {
            "location": "/AP_iOS/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connect Fusion via iOS", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Android/", 
            "text": "Connect to Fusion via Android\n\n\n\n\nSteps to connect with Android\n\n\n\n\n1.\n Find and open the Settings App on your Android device.\n\n\n\n\n2.\n Once the settings menu is open, select Wi-Fi.\n\n\n\n3.\n Find the Fusion Access Point SSID and select it to enter the passkey(i.e. \nFusionAP_99be01\n).\n\n\n\n4.\n Enter the passkey for your Fusion. Then select \"Connect\" to connect.\n\nDefault Passkey: \nmrifusion\n\n\n\n\n5.\n Your Fusion is now connected to your Android device.\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connect Fusion via Android", 
            "title": "Connect Android"
        }, 
        {
            "location": "/AP_Android/#connect-to-fusion-via-android", 
            "text": "", 
            "title": "Connect to Fusion via Android"
        }, 
        {
            "location": "/AP_Android/#steps-to-connect-with-android", 
            "text": "1.  Find and open the Settings App on your Android device.   2.  Once the settings menu is open, select Wi-Fi.  3.  Find the Fusion Access Point SSID and select it to enter the passkey(i.e.  FusionAP_99be01 ).  4.  Enter the passkey for your Fusion. Then select \"Connect\" to connect. \nDefault Passkey:  mrifusion   5.  Your Fusion is now connected to your Android device.", 
            "title": "Steps to connect with Android"
        }, 
        {
            "location": "/AP_Android/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connect Fusion via Android", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Change/", 
            "text": "Change Fusion Access Point SSID and Passkey\n\n\n\n\nCustom access point and passkey\n\n\n\n\nEach Fusion has its own unique access point name, or Service Set Identifier (SSID), and share a common passkey. There is an option in the settings menu to change your SSID and passkey.  \n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nWIRELESS\n menu.\n\n\n3.\n In the \nAccess Point Settings\n section, enter in a new SSID and passkey into the corresponding text boxes.  \n\n\n\n\nExample:\n\nSSID: \nHelloWorld\n\nPasskey: \nmynewpassword\n\n\n\n\n4.\n Click the \nAPPLY CHANGES\n button to apply the changes to your Fusion.\n\n\n5.\n You will be prompted to accept the new Access Point credentials. Clicking \nOK\n will restart your Fusion.\n\n\n\n6.\n The Fusion server will shutdown and you will need to reconnect with the new credentials that were created in Step 3 once the Fusion restarts.\n\n\nFor instructions on connecting to the Fusion Access Point, refer to the following links.\n\n\n\n\nConnect via Windows\n  \n\n\nConnect via Mac\n\n\nConnect via Linux\n  \n\n\nConnect via iOS\n  \n\n\nConnect via Android\n\n\n\n\n\n\nCan't connect to new access point\n\n\n\n\nIf you changed your SSID and Passkey and are now unable to connect to your Fusion, a few things could have gone wrong.\n\n\n1.\n \nPower off\n your Fusion and then turn it back on. Then attempt to connect to the Fusion using your credentials.\n\n\n2.\n If that is still not working, you may have accidentally entered your password incorrectly or the caps lock on when you entered in the new password. \n\n\n\n\nFollow the instructions to \nRestore SSID and Passkey\n to default using the supplied \nSystem Recovery Wire\n.\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Change Fusion Access Point", 
            "title": "Change Fusion AP"
        }, 
        {
            "location": "/AP_Change/#change-fusion-access-point-ssid-and-passkey", 
            "text": "", 
            "title": "Change Fusion Access Point SSID and Passkey"
        }, 
        {
            "location": "/AP_Change/#custom-access-point-and-passkey", 
            "text": "Each Fusion has its own unique access point name, or Service Set Identifier (SSID), and share a common passkey. There is an option in the settings menu to change your SSID and passkey.    1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  WIRELESS  menu.  3.  In the  Access Point Settings  section, enter in a new SSID and passkey into the corresponding text boxes.     Example: \nSSID:  HelloWorld \nPasskey:  mynewpassword   4.  Click the  APPLY CHANGES  button to apply the changes to your Fusion.  5.  You will be prompted to accept the new Access Point credentials. Clicking  OK  will restart your Fusion.  6.  The Fusion server will shutdown and you will need to reconnect with the new credentials that were created in Step 3 once the Fusion restarts. \nFor instructions on connecting to the Fusion Access Point, refer to the following links.   Connect via Windows     Connect via Mac  Connect via Linux     Connect via iOS     Connect via Android", 
            "title": "Custom access point and passkey"
        }, 
        {
            "location": "/AP_Change/#cant-connect-to-new-access-point", 
            "text": "If you changed your SSID and Passkey and are now unable to connect to your Fusion, a few things could have gone wrong.  1.   Power off  your Fusion and then turn it back on. Then attempt to connect to the Fusion using your credentials.  2.  If that is still not working, you may have accidentally entered your password incorrectly or the caps lock on when you entered in the new password.    Follow the instructions to  Restore SSID and Passkey  to default using the supplied  System Recovery Wire .", 
            "title": "Can't connect to new access point"
        }, 
        {
            "location": "/AP_Change/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Change Fusion Access Point", 
            "title": "Questions?"
        }, 
        {
            "location": "/AP_Restore/", 
            "text": "Restore Fusion Access Point SSID and Passkey\n\n\n\n\nThere are two methods for resetting the Fusion Access Point SSID and Passkey. Follow the steps below if you are unable to connect to your Fusion Access Point or want to reset the Fusion Access Point SSID and Passkey. \n\n\nRestore SSID and Passkey via the Web Interface\n\n\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nWIRELESS\n menu.\n\n\n3.\n In the \nAccess Point Settings\n section, click the \nDEFAULT\n button to your restore the Fusion Access Point SSID and Passkey. \n\n\n4.\nYou will be prompted to restore the Access Point credentials to defualt. Clicking \nOK\n will restart your Fusion.\n\n\n\n6.\n The Fusion server will shutdown and you will need to reconnect with the original credentials once the Fusion restarts. This can be found on a sticker at the bottom of your Fusion Controller.\n\n\nFor instructions on connecting to the Fusion Access Point, refer to the following links.\n\n\n\n\nConnect via Windows\n  \n\n\nConnect via Mac\n\n\nConnect via Linux\n  \n\n\nConnect via iOS\n  \n\n\nConnect via Android\n\n\n\n\n\n\nRestore SSID and Passkey via the System Recovery Wire\n\n\nIf you are unable to connect to the Fusion Access Point or forgot your password, you will need to complete a hardware reset using the \nSystem Recovery Wire\n included with your Fusion (color may vary).\n\n\n\n\n1.\n \nPower off\n the Fusion\n\n\n2.\n Connect the System Recovery Wire to left most pin (I/O Pin) of \nD0\n to the same pin on \nD7\n.\n\n\n\n3.\n \nPower on\n the Fusion. The Status LED will start to blink.\n\n\n\n4.\n When the blue and yellow LEDs on the side of the Fusion turn on, the System Recovery Wire must be removed.\n\n\n\n5.\n The Fusion will continue to \npower on\n as it normally would and will now have the default SSID and Passkey.\n\n\nFollow the steps to \nconnect your Fusion\n using the default credentials.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Restore Fusion Access Point", 
            "title": "Restore Fusion AP"
        }, 
        {
            "location": "/AP_Restore/#restore-fusion-access-point-ssid-and-passkey", 
            "text": "There are two methods for resetting the Fusion Access Point SSID and Passkey. Follow the steps below if you are unable to connect to your Fusion Access Point or want to reset the Fusion Access Point SSID and Passkey.", 
            "title": "Restore Fusion Access Point SSID and Passkey"
        }, 
        {
            "location": "/AP_Restore/#restore-ssid-and-passkey-via-the-web-interface", 
            "text": "1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  WIRELESS  menu.  3.  In the  Access Point Settings  section, click the  DEFAULT  button to your restore the Fusion Access Point SSID and Passkey.   4. You will be prompted to restore the Access Point credentials to defualt. Clicking  OK  will restart your Fusion.  6.  The Fusion server will shutdown and you will need to reconnect with the original credentials once the Fusion restarts. This can be found on a sticker at the bottom of your Fusion Controller. \nFor instructions on connecting to the Fusion Access Point, refer to the following links.   Connect via Windows     Connect via Mac  Connect via Linux     Connect via iOS     Connect via Android", 
            "title": "Restore SSID and Passkey via the Web Interface"
        }, 
        {
            "location": "/AP_Restore/#restore-ssid-and-passkey-via-the-system-recovery-wire", 
            "text": "If you are unable to connect to the Fusion Access Point or forgot your password, you will need to complete a hardware reset using the  System Recovery Wire  included with your Fusion (color may vary).   1.   Power off  the Fusion  2.  Connect the System Recovery Wire to left most pin (I/O Pin) of  D0  to the same pin on  D7 .  3.   Power on  the Fusion. The Status LED will start to blink.  4.  When the blue and yellow LEDs on the side of the Fusion turn on, the System Recovery Wire must be removed.  5.  The Fusion will continue to  power on  as it normally would and will now have the default SSID and Passkey. \nFollow the steps to  connect your Fusion  using the default credentials.", 
            "title": "Restore SSID and Passkey via the System Recovery Wire"
        }, 
        {
            "location": "/AP_Restore/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Restore Fusion Access Point", 
            "title": "Questions?"
        }, 
        {
            "location": "/Connect_Internet/", 
            "text": "Connect Fusion to the Internet\n\n\n\n\nConnect to the internet via Ethernet Cable\n\n\n\n\n1.\n Connect an ethernet cable (CAT5e or CAT6) to the Fusion \nEthernet Port\n. Connect the other end of the cable to your router or modem.\n\n\nThe Fusion will automatically connect to the internet. This process may take a few moments.\n\n\n\n\nConnect to the internet via external USB Wi-Fi Adapter\n\n\n\n\n1.\n Connect the USB Wi-Fi adapter supplied by Boxlight Robotics to your Fusion via the \nUSB Hub\n. Refer to the \nWi-Fi Hub\n for more information on how wireless connections are made with the Fusion.\n\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nWIRELESS\n menu.\n\n\n3.\n In the \nWireless Networks\n section, look at the list of available networks for your wireless router. Click on the router SSID(name) to start the internet connection process. \n\n\n4.\n Click \nConnect\n to connect to the selected network\n\n\n5.\n Enter the correct passkey for that network and click \nOK\n to connect.\n\nThis process may take a few moments to connect to the internet.\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Connect Fusion to the Internet", 
            "title": "Connect to Internet"
        }, 
        {
            "location": "/Connect_Internet/#connect-fusion-to-the-internet", 
            "text": "", 
            "title": "Connect Fusion to the Internet"
        }, 
        {
            "location": "/Connect_Internet/#connect-to-the-internet-via-ethernet-cable", 
            "text": "1.  Connect an ethernet cable (CAT5e or CAT6) to the Fusion  Ethernet Port . Connect the other end of the cable to your router or modem. \nThe Fusion will automatically connect to the internet. This process may take a few moments.", 
            "title": "Connect to the internet via Ethernet Cable"
        }, 
        {
            "location": "/Connect_Internet/#connect-to-the-internet-via-external-usb-wi-fi-adapter", 
            "text": "1.  Connect the USB Wi-Fi adapter supplied by Boxlight Robotics to your Fusion via the  USB Hub . Refer to the  Wi-Fi Hub  for more information on how wireless connections are made with the Fusion.  1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  WIRELESS  menu.  3.  In the  Wireless Networks  section, look at the list of available networks for your wireless router. Click on the router SSID(name) to start the internet connection process.   4.  Click  Connect  to connect to the selected network  5.  Enter the correct passkey for that network and click  OK  to connect. \nThis process may take a few moments to connect to the internet.", 
            "title": "Connect to the internet via external USB Wi-Fi Adapter"
        }, 
        {
            "location": "/Connect_Internet/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Connect Fusion to the Internet", 
            "title": "Questions?"
        }, 
        {
            "location": "/Update/", 
            "text": "Update Fusion\n\n\n\n\nTo update your Fusion Controller to the latest software version, you need to connect the Fusion to the Internet.\n\n\nConnect to the internet via Ethernet Cable\n\n\n\n\n1.\n Connect an ethernet cable (CAT5e or CAT6) to the Fusion \nEthernet Port\n. Connect the other end of the cable to your router or modem.\n\n\nThe Fusion will automatically connect to the internet. This process may take a few moments.\n\n\n\n\n\nConnect to the internet via external USB WiFi Adapter\n\n\n\n\n1.\n Connect the USB Wi-Fi adapter supplied by Boxlight Robotics to your Fusion via the \nUSB Hub\n. Refer to the \nWi-Fi Hub\n for more information on how wireless connections are made with the Fusion.\n\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nWIRELESS\n menu.\n\n\n3.\n In the \nWireless Networks\n section, look at the list of available networks for your wireless router. Click on the router SSID(name) to start the internet connection process. \n\n\n4.\n Click \nConnect\n to connect to the selected network\n\n\n5.\n Enter the correct passkey for that network and click \nOK\n to connect.\n\nThis process may take a few moments to connect to the internet.\n\n\n\n\n\nUpdate the Fusion\n\n\n\n\nYou must be logged into an administrator account to update.\n\n\n1.\n Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n2.\n Navigate to the \nSOFTWARE\n menu.\n\n\n3.\n If an update is available the button will be active. Select the \nUPDATE\n button.  \n\n\n4.\n The update screen will start to fill with text. This is the update script running and producing output to the screen. \n\n\n\n\n5.\n The Fusion server will automatically shutdown when the update is complete. Reboot the controller, then connect and login as normal. \n\n\n\nLog in with your username and password to use your updated Fusion.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Updating Fusion", 
            "title": "Update Fusion"
        }, 
        {
            "location": "/Update/#update-fusion", 
            "text": "To update your Fusion Controller to the latest software version, you need to connect the Fusion to the Internet.", 
            "title": "Update Fusion"
        }, 
        {
            "location": "/Update/#connect-to-the-internet-via-ethernet-cable", 
            "text": "1.  Connect an ethernet cable (CAT5e or CAT6) to the Fusion  Ethernet Port . Connect the other end of the cable to your router or modem. \nThe Fusion will automatically connect to the internet. This process may take a few moments.", 
            "title": "Connect to the internet via Ethernet Cable"
        }, 
        {
            "location": "/Update/#connect-to-the-internet-via-external-usb-wifi-adapter", 
            "text": "1.  Connect the USB Wi-Fi adapter supplied by Boxlight Robotics to your Fusion via the  USB Hub . Refer to the  Wi-Fi Hub  for more information on how wireless connections are made with the Fusion.  1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  WIRELESS  menu.  3.  In the  Wireless Networks  section, look at the list of available networks for your wireless router. Click on the router SSID(name) to start the internet connection process.   4.  Click  Connect  to connect to the selected network  5.  Enter the correct passkey for that network and click  OK  to connect. \nThis process may take a few moments to connect to the internet.", 
            "title": "Connect to the internet via external USB WiFi Adapter"
        }, 
        {
            "location": "/Update/#update-the-fusion", 
            "text": "You must be logged into an administrator account to update.  1.  Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.  2.  Navigate to the  SOFTWARE  menu.  3.  If an update is available the button will be active. Select the  UPDATE  button.    4.  The update screen will start to fill with text. This is the update script running and producing output to the screen.    5.  The Fusion server will automatically shutdown when the update is complete. Reboot the controller, then connect and login as normal.   \nLog in with your username and password to use your updated Fusion.", 
            "title": "Update the Fusion"
        }, 
        {
            "location": "/Update/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Updating Fusion", 
            "title": "Questions?"
        }, 
        {
            "location": "/Program_Autostart/", 
            "text": "Autonomous Mode\n\n\n\n\nAutonomous mode allows an administrator to select a program on the Fusion to run automatically\nwhen the Fusion powers on.\n\n\n\n\nA user must be logged in as an \nadministrator\n to access the appropriate settings.\n\n\n\n\nLocation:\n\n\n\n\n\n\n\n\nOpen the Fusion settings from the hamburger menu on the left or the settings box on the home page.\n\n\n\n\n\n\n\nNavigate to the \nAUTONOMOUS\n tab option\n\n\n\n\n\n\n\n\n\nToggle Autonomous Mode\n\n\n\n\nAutonmous mode can be toggled on and off by enabling the switch on the upper right hand corner.\n\n\n\n\n\nSetting a Program\n\n\n\n\n\n\n\n\nSelect a user account\n\n\n\n\n\n\n\nSelect a program type (at the time of writing this documentation, only editor programs are supported)\n\n\n\n\n\n\n\nSelect a program\n\n\n\n\n\n\n\nPress set\n\n\n\n\n\n\n\n\n\nResetting to Default Mode\n\n\n\n\nAutonomous mode can be reset to it's factory settings by pressing the default button.\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Autonomous Mode", 
            "title": "Auto Start Program"
        }, 
        {
            "location": "/Program_Autostart/#autonomous-mode", 
            "text": "Autonomous mode allows an administrator to select a program on the Fusion to run automatically\nwhen the Fusion powers on.   A user must be logged in as an  administrator  to access the appropriate settings.", 
            "title": "Autonomous Mode"
        }, 
        {
            "location": "/Program_Autostart/#location", 
            "text": "Open the Fusion settings from the hamburger menu on the left or the settings box on the home page.    Navigate to the  AUTONOMOUS  tab option", 
            "title": "Location:"
        }, 
        {
            "location": "/Program_Autostart/#toggle-autonomous-mode", 
            "text": "Autonmous mode can be toggled on and off by enabling the switch on the upper right hand corner.", 
            "title": "Toggle Autonomous Mode"
        }, 
        {
            "location": "/Program_Autostart/#setting-a-program", 
            "text": "Select a user account    Select a program type (at the time of writing this documentation, only editor programs are supported)    Select a program    Press set", 
            "title": "Setting a Program"
        }, 
        {
            "location": "/Program_Autostart/#resetting-to-default-mode", 
            "text": "Autonomous mode can be reset to it's factory settings by pressing the default button.", 
            "title": "Resetting to Default Mode"
        }, 
        {
            "location": "/Program_Autostart/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Autonomous Mode", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blockly/", 
            "text": "Blockly Guide\n\n\n\n\nRefer to the \nBlockly Library Informtation\n for available programming blocks.\n\n\nCreate a new program\n\n\n\n\nTo create a new program from the Home screen, click the \nLAUNCH\n button in the Blockly box.\n\n\n\n\nA program will open that is listed at Untitled\nX\n.blk where \nX\n is an incrementing number. Click the save button to save the file with a new name. For our example we will name the file \nmyprog\n which will result in a file being created call \nmyprog.blk\n.\n\nEvery new program has a start block placed in the programming environment.\n\n\n\n\nOpen an existing program\n\n\n\n\nTo open an existing program, click the open file button and select the program you want to open. The program will open in the programming environment as it was the last time it was saved.\n\n\n\n\nWriting a LED flashing program (Basic)\n\n\n\n\nFirst, make sure you are on the Basic Blockly screen by going to \nView -\n Mode -\n Basic\n in the toolbar. This example will show how to create a Blockly program to toggle the onboard yellow and blue LEDs. After opening a new program, the program environment contains just the \nStart Block\n.  \n\n\n\n\n\n\n\n\n1)\n Go to the \nFusion Control\n toolbox and drag out the \nYellow LED Block\n and attach it to the start block like shown.\n\n\n\n\n\n\n\n\n2)\n Now we are going to add a delay so the yellow LED will stay on for 1 second before the next LED block. Go to the \nFusion Control\n toolbox and drag out the \nWait Block\n.\n\n\n\n\n\n\n\n\n3)\n Go to the \nFusion Control\n toolbox and drag out the \nBlue LED Block\n and attach it to the wait block from the previous step. Now the yellow LED will turn on for 1 second and then switch to blue.\n\n\n\n\n\n\n\n\n4)\n Go to the \nFusion Control\n toolbox and drag the \nWait Block\n to the blue LED block. Now the yellow LED will turn on for 1 second, turn off and the blue LED will turn on for 1 second.\n\n\n\n\n\n\n\n\n5)\n In the toolbar at the top of the page, click \"Run\" to start running (also saves) the current program. You should observe the following:\n\n\n\n\n1.\n Only the Yellow LED turns on for 1 second.\n\n\n2.\n Only the Blue LED turns on for 1 second.\n\n\n3.\n The program will end and both LEDs will be off.\n\n\n\n\n\n\n\n\n\n\nWriting a LED flashing program (Intermediate)\n\n\n\n\nFirst, make sure you are on the Intermediate Blockly screen by going to \nView -\n Mode -\n Intermediate\n in the toolbar. This example will show how to create a Blockly program to continuously toggle the onboard yellow and blue LEDs. After opening a new program, the program environment contains just the \nStart Block\n.\n\n\n\n\n\n\n\n\n1)\n Go to the \nLoops\n toolbox and drag out the \nRepeat While True Block\n \n\n\n\n\n\n\n\n\n2)\n Go to the \nFusion Control\n toolbox and drag out 2 of the \nLED Blocks\n and attach them inside the loop like shown. Change the lower block to \nblue\n and set it to \noff\n.\n\n\n\n\n\n\n\n\n3)\n Go to the \nTime\n toolbox and drag out the \nWait \nX\n Seconds Block\n and attach it under the LED blocks. Change the number in the center to the desired length of time for the yellow LED to stay on. For this example, we will leave the time at 1 second.\n\n\n\n\n\n\n\n\n4)\n Go to the \nFusion Control\n toolbox and drag out 2 more of the \nLED Blocks\n and attach them below the wait block. This time turn the yellow LED \noff\n and the blue LED \non\n.\n\n\n\n\n\n\n\n\n5)\n Go to the \nTime\n toolbox and drag out the \nWait \nX\n Seconds Block\n and attach it under the LED blocks.\n\n\n\n\n\n\n\n\n6)\n In the toolbar at the top of the page, click \"Run\" to start running (also saves) the current program. You should observe the following:\n\n\n\n\n1.\n Only the Yellow LED turns on for 1 second.\n\n\n2.\n Only the Blue LED turns on for 1 second.\n\n\n3.\n The program will continually loop and flash the LEDs until \"Stop\" is selected in the toolbar.\n\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Programming", 
            "title": "Blockly"
        }, 
        {
            "location": "/Blockly/#blockly-guide", 
            "text": "Refer to the  Blockly Library Informtation  for available programming blocks.", 
            "title": "Blockly Guide"
        }, 
        {
            "location": "/Blockly/#create-a-new-program", 
            "text": "To create a new program from the Home screen, click the  LAUNCH  button in the Blockly box.   A program will open that is listed at Untitled X .blk where  X  is an incrementing number. Click the save button to save the file with a new name. For our example we will name the file  myprog  which will result in a file being created call  myprog.blk . \nEvery new program has a start block placed in the programming environment.", 
            "title": "Create a new program"
        }, 
        {
            "location": "/Blockly/#open-an-existing-program", 
            "text": "To open an existing program, click the open file button and select the program you want to open. The program will open in the programming environment as it was the last time it was saved.", 
            "title": "Open an existing program"
        }, 
        {
            "location": "/Blockly/#writing-a-led-flashing-program-basic", 
            "text": "First, make sure you are on the Basic Blockly screen by going to  View -  Mode -  Basic  in the toolbar. This example will show how to create a Blockly program to toggle the onboard yellow and blue LEDs. After opening a new program, the program environment contains just the  Start Block .       1)  Go to the  Fusion Control  toolbox and drag out the  Yellow LED Block  and attach it to the start block like shown.     2)  Now we are going to add a delay so the yellow LED will stay on for 1 second before the next LED block. Go to the  Fusion Control  toolbox and drag out the  Wait Block .     3)  Go to the  Fusion Control  toolbox and drag out the  Blue LED Block  and attach it to the wait block from the previous step. Now the yellow LED will turn on for 1 second and then switch to blue.     4)  Go to the  Fusion Control  toolbox and drag the  Wait Block  to the blue LED block. Now the yellow LED will turn on for 1 second, turn off and the blue LED will turn on for 1 second.     5)  In the toolbar at the top of the page, click \"Run\" to start running (also saves) the current program. You should observe the following:   1.  Only the Yellow LED turns on for 1 second.  2.  Only the Blue LED turns on for 1 second.  3.  The program will end and both LEDs will be off.", 
            "title": "Writing a LED flashing program (Basic)"
        }, 
        {
            "location": "/Blockly/#writing-a-led-flashing-program-intermediate", 
            "text": "First, make sure you are on the Intermediate Blockly screen by going to  View -  Mode -  Intermediate  in the toolbar. This example will show how to create a Blockly program to continuously toggle the onboard yellow and blue LEDs. After opening a new program, the program environment contains just the  Start Block .     1)  Go to the  Loops  toolbox and drag out the  Repeat While True Block       2)  Go to the  Fusion Control  toolbox and drag out 2 of the  LED Blocks  and attach them inside the loop like shown. Change the lower block to  blue  and set it to  off .     3)  Go to the  Time  toolbox and drag out the  Wait  X  Seconds Block  and attach it under the LED blocks. Change the number in the center to the desired length of time for the yellow LED to stay on. For this example, we will leave the time at 1 second.     4)  Go to the  Fusion Control  toolbox and drag out 2 more of the  LED Blocks  and attach them below the wait block. This time turn the yellow LED  off  and the blue LED  on .     5)  Go to the  Time  toolbox and drag out the  Wait  X  Seconds Block  and attach it under the LED blocks.     6)  In the toolbar at the top of the page, click \"Run\" to start running (also saves) the current program. You should observe the following:   1.  Only the Yellow LED turns on for 1 second.  2.  Only the Blue LED turns on for 1 second.  3.  The program will continually loop and flash the LEDs until \"Stop\" is selected in the toolbar.", 
            "title": "Writing a LED flashing program (Intermediate)"
        }, 
        {
            "location": "/Blockly/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Programming", 
            "title": "Questions?"
        }, 
        {
            "location": "/Editor/", 
            "text": "Editor Guide\n\n\n\n\nRefer to the \nEditor Library Informtation\n for available Fusion specific functions.\n\n\nCreate a new program\n\n\n\n\nTo create a new program from the Home screen, click the \nLAUNCH\n button in the Editor box.\n\n\n\n\nA program will open that is listed at Untitled\nX\n.py where \nX\n is an incrementing number. Click the save button to save the file with a new name. For our example we will name out file \nmyprog\n which will result in a file being created call \nmyprog.py\n.\n\nEvery new program has an import and class constructor at the beginning of the code. This is needed to operate any Boxlight Robotics sensor or access Fusion library functions.\n\n\n\n\nOpen an existing program\n\n\n\n\nTo open an existing program, click the open file button and select the program you want to open. The program will open in the programming environment as it was the last time it was saved and the file will be listed in the working files directory.\n\n\n\n\nWriting a LED flashing program\n\n\n\n\nThis example will show how to create an Editor program to continuously toggle the on-board yellow and blue LEDs. After opening a new program, the program environment contains only the import and class constructor.\n\n\n\n\nimport Fusion\nf = Fusion.driver()\n\n\n\n\n\n1)\n Turn \non\n the yellow LED and turn \noff\n the blue LED using the \nsetLED(led, value)\n function from the \nFusion Driver\n class.\n\n\n\n\nimport Fusion\nf = Fusion.driver()\n\nsetLED(f.YELLOW, 1)\nsetLED(f.BLUE, 0)\n\n\n\n\n\n2)\n The next step is to add a time delay after turning the yellow LED on. This delay determines the length of time that the yellow LED stay on. In order to use the built-in \nsleep(seconds)\n function, the time module must be imported.\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\n\nf.setLED(f.YELLOW, 1)\nf.setLED(f.BLUE, 0)\ntime.sleep(1)\n\n\n\n\n\n3)\n Now, turn \noff\n the yellow LED and turn \non\n the blue LED using the \nsetLED(led, value)\n function.\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\n\nf.setLED(f.YELLOW, 1)\nf.setLED(f.BLUE, 0)\ntime.sleep(1)\nf.setLED(f.YELLOW, 0)\nf.setLED(f.BLUE, 1)\n\n\n\n\n\n4)\n The final step before running the program is to add another time delay for the length of time the blue LED stays on.\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\n\nf.setLED(f.YELLOW, 1)\nf.setLED(f.BLUE, 0)\ntime.sleep(1)\nf.setLED(f.YELLOW, 0)\nf.setLED(f.BLUE, 1)\ntime.sleep(1)\n\n\n\n\n\n5)\n In the toolbar at the top of the page, click \"Run\" to start running (also saves) the current program. You should observe the following:\n\n\n\n\n1.\n Only the Yellow LED turns on for 1 second.\n\n\n2.\n Only the Blue LED turns on for 1 second.\n\n\n3.\n The program will end and both LEDs will be off.\n\n\n\n\n\n\nTo continuously toggle the LEDs \non\n and \noff\n, the \nsetLED()\n and \nsleep()\n functions must be placed inside a loop. For our purpose we will use a \nwhile\n loop with its condition being \nTrue\n. It is important that any code within the \nwhile True:\n loop must be indented with a \nTab\n.\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\n\nwhile True:\n    f.setLED(f.YELLOW, 1)\n    f.setLED(f.BLUE, 0)\n    time.sleep(1)\n    f.setLED(f.YELLOW, 0)\n    f.setLED(f.BLUE, 1)\n    time.sleep(1)\n\n\n\n\n\nYou should observe the following:  \n\n\n\n\n1.\n Only the Yellow LED turns on for 1 second.\n\n\n2.\n Only the Blue LED turns on for 1 second.\n\n\n3.\n The program will continually loop and flash the LEDs until \"Stop\" is selected in the toolbar.\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Editor Programming", 
            "title": "Editor"
        }, 
        {
            "location": "/Editor/#editor-guide", 
            "text": "Refer to the  Editor Library Informtation  for available Fusion specific functions.", 
            "title": "Editor Guide"
        }, 
        {
            "location": "/Editor/#create-a-new-program", 
            "text": "To create a new program from the Home screen, click the  LAUNCH  button in the Editor box.   A program will open that is listed at Untitled X .py where  X  is an incrementing number. Click the save button to save the file with a new name. For our example we will name out file  myprog  which will result in a file being created call  myprog.py . \nEvery new program has an import and class constructor at the beginning of the code. This is needed to operate any Boxlight Robotics sensor or access Fusion library functions.", 
            "title": "Create a new program"
        }, 
        {
            "location": "/Editor/#open-an-existing-program", 
            "text": "To open an existing program, click the open file button and select the program you want to open. The program will open in the programming environment as it was the last time it was saved and the file will be listed in the working files directory.", 
            "title": "Open an existing program"
        }, 
        {
            "location": "/Editor/#writing-a-led-flashing-program", 
            "text": "This example will show how to create an Editor program to continuously toggle the on-board yellow and blue LEDs. After opening a new program, the program environment contains only the import and class constructor.   import Fusion\nf = Fusion.driver()   1)  Turn  on  the yellow LED and turn  off  the blue LED using the  setLED(led, value)  function from the  Fusion Driver  class.   import Fusion\nf = Fusion.driver()\n\nsetLED(f.YELLOW, 1)\nsetLED(f.BLUE, 0)   2)  The next step is to add a time delay after turning the yellow LED on. This delay determines the length of time that the yellow LED stay on. In order to use the built-in  sleep(seconds)  function, the time module must be imported.   import Fusion\nimport time\nf = Fusion.driver()\n\nf.setLED(f.YELLOW, 1)\nf.setLED(f.BLUE, 0)\ntime.sleep(1)   3)  Now, turn  off  the yellow LED and turn  on  the blue LED using the  setLED(led, value)  function.   import Fusion\nimport time\nf = Fusion.driver()\n\nf.setLED(f.YELLOW, 1)\nf.setLED(f.BLUE, 0)\ntime.sleep(1)\nf.setLED(f.YELLOW, 0)\nf.setLED(f.BLUE, 1)   4)  The final step before running the program is to add another time delay for the length of time the blue LED stays on.   import Fusion\nimport time\nf = Fusion.driver()\n\nf.setLED(f.YELLOW, 1)\nf.setLED(f.BLUE, 0)\ntime.sleep(1)\nf.setLED(f.YELLOW, 0)\nf.setLED(f.BLUE, 1)\ntime.sleep(1)   5)  In the toolbar at the top of the page, click \"Run\" to start running (also saves) the current program. You should observe the following:   1.  Only the Yellow LED turns on for 1 second.  2.  Only the Blue LED turns on for 1 second.  3.  The program will end and both LEDs will be off.    To continuously toggle the LEDs  on  and  off , the  setLED()  and  sleep()  functions must be placed inside a loop. For our purpose we will use a  while  loop with its condition being  True . It is important that any code within the  while True:  loop must be indented with a  Tab .   import Fusion\nimport time\nf = Fusion.driver()\n\nwhile True:\n    f.setLED(f.YELLOW, 1)\n    f.setLED(f.BLUE, 0)\n    time.sleep(1)\n    f.setLED(f.YELLOW, 0)\n    f.setLED(f.BLUE, 1)\n    time.sleep(1)   You should observe the following:     1.  Only the Yellow LED turns on for 1 second.  2.  Only the Blue LED turns on for 1 second.  3.  The program will continually loop and flash the LEDs until \"Stop\" is selected in the toolbar.", 
            "title": "Writing a LED flashing program"
        }, 
        {
            "location": "/Editor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Editor Programming", 
            "title": "Questions?"
        }, 
        {
            "location": "/On_Board_LED/", 
            "text": "OnBoard LEDs\n\n\n\n\n\n\n\n\n\n\nRaspberry Pi Power\n  \n\n\n\n\nThese LEDs indicate power to the Raspberry Pi 3.  \n\n\n\n\nFusion Power\n \n\n\n\n\nThis indicates the Fusion is powered on and running.\n\n\n\n\n5V Power\n \n\n\n\n\nThis indicates the 5V circuitry is enabled.\n\n\n\n\nBattery Power\n \n\n\n\n\nThis indicates that the battery is connected and the 6V circuitry is enabled.\n\n\n\n\nStatus Indicator\n \n\n\n\n\nThe status LED indicated the current state the Fusion is in.\n\n\n\n\nIf the LED is \nOFF\n, then the Fusion is off.\n\n\nIf the LED is \nBLINKING\n, then the Fusion is booting up and will be ready for use once the light is solid.\n\n\nIf the LED is \nON\n and solid, then the Fusion is ready to use.\n\n\n\n\n\n\n\n\n\n\nError/Low Battery\n \n\n\n\n\nThis LED will blink when the battery has approximately 20% battery life remaining.\n\n\n\n\nUSB Power\n \n\n\n\n\nThis LED is turn on when connected to a USB power source.\n\n\n\n\nUser Controlled LEDs\n \n\n\n\n\nThese LEDs can be programmed by the user from both \nBlockly\n(\nBasic\n) and the \nEditor\n to turn \nON\n and \nOFF\n.\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion LEDs", 
            "title": "On Board LEDs"
        }, 
        {
            "location": "/On_Board_LED/#onboard-leds", 
            "text": "Raspberry Pi Power      These LEDs indicate power to the Raspberry Pi 3.     Fusion Power     This indicates the Fusion is powered on and running.   5V Power     This indicates the 5V circuitry is enabled.   Battery Power     This indicates that the battery is connected and the 6V circuitry is enabled.   Status Indicator     The status LED indicated the current state the Fusion is in.   If the LED is  OFF , then the Fusion is off.  If the LED is  BLINKING , then the Fusion is booting up and will be ready for use once the light is solid.  If the LED is  ON  and solid, then the Fusion is ready to use.      Error/Low Battery     This LED will blink when the battery has approximately 20% battery life remaining.   USB Power     This LED is turn on when connected to a USB power source.   User Controlled LEDs     These LEDs can be programmed by the user from both  Blockly ( Basic ) and the  Editor  to turn  ON  and  OFF .", 
            "title": "OnBoard LEDs"
        }, 
        {
            "location": "/On_Board_LED/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion LEDs", 
            "title": "Questions?"
        }, 
        {
            "location": "/Digital_Ports/", 
            "text": "Digital Ports\n\n\n\n\nThere are 8 digital ports for controlling digital sensors that are either \nON\n (\n1\n) or \nOFF\n (\n0\n). Each port consists of a black, red and yellow wire connection. The black wire is the ground wire and must line up with the black bar on the right side of the port. The red wire is the power wire that connects to 5V for all the sensors to operate on. The yellow wire is the logic voltage line that ranges from 0V-5V and it is used to send or receive signal. \n\n\n\n\nCurrent Limiting Resistor\n : 220ohm\n\n\nSignal Logic Levels\n : 5V TTL at 22mA Max\n\n\nPorts\n : D0 - D7\n\n\nBlockly Programming Reference\n\n\nPython Programming Reference\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Digital Ports", 
            "title": "Digital Ports"
        }, 
        {
            "location": "/Digital_Ports/#digital-ports", 
            "text": "There are 8 digital ports for controlling digital sensors that are either  ON  ( 1 ) or  OFF  ( 0 ). Each port consists of a black, red and yellow wire connection. The black wire is the ground wire and must line up with the black bar on the right side of the port. The red wire is the power wire that connects to 5V for all the sensors to operate on. The yellow wire is the logic voltage line that ranges from 0V-5V and it is used to send or receive signal.    Current Limiting Resistor  : 220ohm  Signal Logic Levels  : 5V TTL at 22mA Max  Ports  : D0 - D7  Blockly Programming Reference  Python Programming Reference", 
            "title": "Digital Ports"
        }, 
        {
            "location": "/Digital_Ports/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Digital Ports", 
            "title": "Questions?"
        }, 
        {
            "location": "/Analog_Ports/", 
            "text": "Analog Ports\n\n\n\n\nThere are 8 analog ports for reading analog sensors that range from \n0\n - \n1023\n. Eacch port consists of a black, red and yellow wire connection. The black wire is the ground wire and must line up with the black bar on the right side of the port. The red wire is the power wire that connects to 5V for all the sensors to operate on. The yellow wire is the variable voltage line that ranges from 0V-5V and it is used to receive a signal from the sensor.\n\n\n\n\nSignal Logic Levels\n : Analog 0V - 5V\n\n\nResolution\n : 10 bit\n\n\nPorts\n : A0 - A7\n\n\nBlockly Programming Reference\n \n\n\nPython Programming Reference\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Analog Ports", 
            "title": "Analog Ports"
        }, 
        {
            "location": "/Analog_Ports/#analog-ports", 
            "text": "There are 8 analog ports for reading analog sensors that range from  0  -  1023 . Eacch port consists of a black, red and yellow wire connection. The black wire is the ground wire and must line up with the black bar on the right side of the port. The red wire is the power wire that connects to 5V for all the sensors to operate on. The yellow wire is the variable voltage line that ranges from 0V-5V and it is used to receive a signal from the sensor.   Signal Logic Levels  : Analog 0V - 5V  Resolution  : 10 bit  Ports  : A0 - A7  Blockly Programming Reference    Python Programming Reference", 
            "title": "Analog Ports"
        }, 
        {
            "location": "/Analog_Ports/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Analog Ports", 
            "title": "Questions?"
        }, 
        {
            "location": "/I2C_Ports/", 
            "text": "I2C Ports\n\n\n\n\nThere are 4 Inter-Integrated Circuit (I2C) ports for controlling I2C sensors. An I2C sensor uses addresses, registers and commands to read and write data.  \n\n\nEach sensor has its own I2C address associated with it. If two of the same sensor are to be used together, the I2C address of one sensor must be changed first. The I2C ports on the Fusion are all connected to the same I2C bus. Therefore, the I2C port that the sensor is connected to is arbitrary.  \n\n\nEach sensor has its own object declaration that must be called at the beginning of user code. The object declaration name is arbitrary and an object declaration must be called for each sensor being used. If there are two of the same sensors, the declaration must be called twice and they must have different names.  \n\n\n\n\nPower\n : 5V DC\n\n\nPull-up Resistor\n : 47k ohm\n\n\nSeries Resistor\n : 47 ohm\n\n\nSignal Logic Levels\n : 5V TTL\n\n\nI2C Bus Speed\n : 100kHz\n\n\nPorts\n : I2C  \n\n\nPython Programming Reference\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion I2C Ports", 
            "title": "I2C Ports"
        }, 
        {
            "location": "/I2C_Ports/#i2c-ports", 
            "text": "There are 4 Inter-Integrated Circuit (I2C) ports for controlling I2C sensors. An I2C sensor uses addresses, registers and commands to read and write data.    Each sensor has its own I2C address associated with it. If two of the same sensor are to be used together, the I2C address of one sensor must be changed first. The I2C ports on the Fusion are all connected to the same I2C bus. Therefore, the I2C port that the sensor is connected to is arbitrary.    Each sensor has its own object declaration that must be called at the beginning of user code. The object declaration name is arbitrary and an object declaration must be called for each sensor being used. If there are two of the same sensors, the declaration must be called twice and they must have different names.     Power  : 5V DC  Pull-up Resistor  : 47k ohm  Series Resistor  : 47 ohm  Signal Logic Levels  : 5V TTL  I2C Bus Speed  : 100kHz  Ports  : I2C    Python Programming Reference", 
            "title": "I2C Ports"
        }, 
        {
            "location": "/I2C_Ports/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion I2C Ports", 
            "title": "Questions?"
        }, 
        {
            "location": "/Motor_Ports/", 
            "text": "Motor Ports\n\n\n\n\nThere are 2 motor ports for controlling 6V DC motors. Connecting the motors in reverse polarity will switch the direction of motor rotation and will not cause any damage to the controller or the motors.\n\n\n\n\nPower\n : 6V DC\n\n\nCurrent Limit\n : 1.5A max\n\n\nOperation Frequency\n : 800Hz PWM\n\n\nStop Modes\n : Float / Brake\n\n\nPorts\n : M0 - M1\n\n\nBlockly Programming Reference\n\n\nPython Programming Reference\n\n\n\n\n\n\nThe connection depicted above is the default motor connection configuration for the Fusion Controller. If your motors are not connected in this manner, any examples that use motors may not work correctly.\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Motor Ports", 
            "title": "Motor Ports"
        }, 
        {
            "location": "/Motor_Ports/#motor-ports", 
            "text": "There are 2 motor ports for controlling 6V DC motors. Connecting the motors in reverse polarity will switch the direction of motor rotation and will not cause any damage to the controller or the motors.   Power  : 6V DC  Current Limit  : 1.5A max  Operation Frequency  : 800Hz PWM  Stop Modes  : Float / Brake  Ports  : M0 - M1  Blockly Programming Reference  Python Programming Reference    The connection depicted above is the default motor connection configuration for the Fusion Controller. If your motors are not connected in this manner, any examples that use motors may not work correctly.", 
            "title": "Motor Ports"
        }, 
        {
            "location": "/Motor_Ports/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Motor Ports", 
            "title": "Questions?"
        }, 
        {
            "location": "/Servo_Ports/", 
            "text": "Servo Ports\n\n\n\n\nThere are 4 servo ports for controlling analog and digital servos. \n\n\n\n\nPower\n : 6V DC\n\n\nStandard Mode\n : 750uS \u2013 2250uS\n\n\nExtended Mode\n : 500uS \u2013 2500uS\n\n\nPorts\n : S0 - S3\n\n\nBlockly Programming Reference\n \n\n\nPython Programming Reference\n\n\n\n\n\n\nServos operate on Pulse Width Modulation (PWM) which allows for an analog result using a digital signal. This is achieved by timing how long the signal is \nHIGH\n, how long the signal is \nLOW\n and comparing them to get the duty cycle.\n\n\n\n\nServos use this signal to dictate which position to go to. A PWM value of 255 creates a 100% duty cycle while a value of 0 creates a 0% duty cycle. When a servo is turned on, it defaults to a value of 127 which is a 50% duty cycle and places the servo halfway through its mechanical limits.  \n\n\nWhen reaching the limits of 0 or 255, listen to your servo for humming or clicking which would indicate that the servo has reach or is attempting to surpass its mechanical limit. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Servo Ports", 
            "title": "Servo Ports"
        }, 
        {
            "location": "/Servo_Ports/#servo-ports", 
            "text": "There are 4 servo ports for controlling analog and digital servos.    Power  : 6V DC  Standard Mode  : 750uS \u2013 2250uS  Extended Mode  : 500uS \u2013 2500uS  Ports  : S0 - S3  Blockly Programming Reference    Python Programming Reference    Servos operate on Pulse Width Modulation (PWM) which allows for an analog result using a digital signal. This is achieved by timing how long the signal is  HIGH , how long the signal is  LOW  and comparing them to get the duty cycle.   Servos use this signal to dictate which position to go to. A PWM value of 255 creates a 100% duty cycle while a value of 0 creates a 0% duty cycle. When a servo is turned on, it defaults to a value of 127 which is a 50% duty cycle and places the servo halfway through its mechanical limits.    When reaching the limits of 0 or 255, listen to your servo for humming or clicking which would indicate that the servo has reach or is attempting to surpass its mechanical limit. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.", 
            "title": "Servo Ports"
        }, 
        {
            "location": "/Servo_Ports/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Servo Ports", 
            "title": "Questions?"
        }, 
        {
            "location": "/HDMI/", 
            "text": "HDMI Port\n\n\n\n\nThe High-Definition Multimedia Interface (HDMI) is an audio/video cable that connects to devices like a computer monitor or television. The cable is multi-directional so either end can be connected to the Fusion.\n\n\n\n\nIf the Fusion is connected via HDMI it is possible to boot into the operating system and use the controller via the desktop. There is still access to the web interface that can be accessed via typing the local host. address into the address bar.\n\nIP: \nlocalhost:8080\n\n\n\n\nFor a more in-depth explanation of HDMI and how it works, go to \nhttps://en.wikipedia.org/wiki/HDMI\n.\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion HDMI Port", 
            "title": "HDMI Port"
        }, 
        {
            "location": "/HDMI/#hdmi-port", 
            "text": "The High-Definition Multimedia Interface (HDMI) is an audio/video cable that connects to devices like a computer monitor or television. The cable is multi-directional so either end can be connected to the Fusion.   If the Fusion is connected via HDMI it is possible to boot into the operating system and use the controller via the desktop. There is still access to the web interface that can be accessed via typing the local host. address into the address bar. \nIP:  localhost:8080   For a more in-depth explanation of HDMI and how it works, go to  https://en.wikipedia.org/wiki/HDMI .", 
            "title": "HDMI Port"
        }, 
        {
            "location": "/HDMI/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion HDMI Port", 
            "title": "Questions?"
        }, 
        {
            "location": "/AV_RCA/", 
            "text": "A/V RCA 3.5mm Connector\n\n\n\n\nThe A/V RCA 3.5mm connector is a composite audio/video connection that can be used as an alternate to HDMI, however it is not recommended for use with the Fusion at this time. Support for this port will be supported in a future release.\n\n\nIt is recommended that \nHDMI\n be used for video and audio output\n.\n\n\n\n\nThe black 3.5mm jack connects to the 3.5mm port on the side of the Fusion. The yellow, white and red connectors connect to the corresponding colored ports on a display device such as a television.  \n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion AV RCA Port", 
            "title": "AV RCA Port"
        }, 
        {
            "location": "/AV_RCA/#av-rca-35mm-connector", 
            "text": "The A/V RCA 3.5mm connector is a composite audio/video connection that can be used as an alternate to HDMI, however it is not recommended for use with the Fusion at this time. Support for this port will be supported in a future release.  It is recommended that  HDMI  be used for video and audio output .   The black 3.5mm jack connects to the 3.5mm port on the side of the Fusion. The yellow, white and red connectors connect to the corresponding colored ports on a display device such as a television.", 
            "title": "A/V RCA 3.5mm Connector"
        }, 
        {
            "location": "/AV_RCA/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion AV RCA Port", 
            "title": "Questions?"
        }, 
        {
            "location": "/USB_Hub/", 
            "text": "USB Hub\n\n\n\n\nThere are 4 USB2.0 ports on the Fusion. A Wi-Fi dongle, offered by Boxlight Robotics, can be used in one of the USB ports to connect the Fusion to the internet. With the Wi-Fi dongle connected the Fusion can \nconnect to a wireless router\n and access the internet.\n\n\n\n\nUse the USB ports to connect approved devices such as a mouse, keyboard, game controller or camera bringing a new level of robotic customization. For more information on a list of approved devices, contact \nBoxlight Robotics\n.\n\n\n\n\nFor a more in-depth explanation of USB and how it works, go to \nhttps://en.wikipedia.org/wiki/USB\n or click \nhere\n for more Raspberry Pi USB related information.\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion USB Hub", 
            "title": "USB Hub"
        }, 
        {
            "location": "/USB_Hub/#usb-hub", 
            "text": "There are 4 USB2.0 ports on the Fusion. A Wi-Fi dongle, offered by Boxlight Robotics, can be used in one of the USB ports to connect the Fusion to the internet. With the Wi-Fi dongle connected the Fusion can  connect to a wireless router  and access the internet.   Use the USB ports to connect approved devices such as a mouse, keyboard, game controller or camera bringing a new level of robotic customization. For more information on a list of approved devices, contact  Boxlight Robotics .   For a more in-depth explanation of USB and how it works, go to  https://en.wikipedia.org/wiki/USB  or click  here  for more Raspberry Pi USB related information.", 
            "title": "USB Hub"
        }, 
        {
            "location": "/USB_Hub/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion USB Hub", 
            "title": "Questions?"
        }, 
        {
            "location": "/WiFi_Hub/", 
            "text": "Wi-Fi Hub\n\n\n\n\nThe Fusion Controller acts as a Wi-Fi access point. Computers or phones can be used to search for local access points and find the Fusion Access Point by a unique SSID (name). Since the programming device (i.e. computer) is connected via Wi-Fi to the Fusion, there is no internet access.\n\n\n\n\nHow to connect to a Fusion Access Point\n\n\n\n\n\n\nIf internet access is needed, a Wi-Fi dongle (available from Boxlight Robotics) can be connected to any of the available ports on the \nUSB Hub\n. With the Wi-Fi dongle connected, the Fusion can connect to a wireless router.  \n\n\n\n\nHow to connect to the Internet\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Wi-Fi Hub", 
            "title": "Wi-Fi Hub"
        }, 
        {
            "location": "/WiFi_Hub/#wi-fi-hub", 
            "text": "The Fusion Controller acts as a Wi-Fi access point. Computers or phones can be used to search for local access points and find the Fusion Access Point by a unique SSID (name). Since the programming device (i.e. computer) is connected via Wi-Fi to the Fusion, there is no internet access.   How to connect to a Fusion Access Point    If internet access is needed, a Wi-Fi dongle (available from Boxlight Robotics) can be connected to any of the available ports on the  USB Hub . With the Wi-Fi dongle connected, the Fusion can connect to a wireless router.", 
            "title": "Wi-Fi Hub"
        }, 
        {
            "location": "/WiFi_Hub/#how-to-connect-to-the-internet", 
            "text": "", 
            "title": "How to connect to the Internet"
        }, 
        {
            "location": "/WiFi_Hub/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Wi-Fi Hub", 
            "title": "Questions?"
        }, 
        {
            "location": "/Ethernet_Port/", 
            "text": "Ethernet Port\n\n\n\n\nThe Fusion has one ethernet port for directly connecting to the internet. We recommend using a CAT5e or CAT6 ethernet cable.\n\n\n\n\nOne option to access to the internet is to connect an ethernet cable from the router (or modem) to the Fusion. Once the cable is connected, the Fusion will \nconnect to the internet\n automatically.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Ethernet Port", 
            "title": "Ethernet Port"
        }, 
        {
            "location": "/Ethernet_Port/#ethernet-port", 
            "text": "The Fusion has one ethernet port for directly connecting to the internet. We recommend using a CAT5e or CAT6 ethernet cable.   One option to access to the internet is to connect an ethernet cable from the router (or modem) to the Fusion. Once the cable is connected, the Fusion will  connect to the internet  automatically.", 
            "title": "Ethernet Port"
        }, 
        {
            "location": "/Ethernet_Port/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Ethernet Port", 
            "title": "Questions?"
        }, 
        {
            "location": "/SD_Card/", 
            "text": "Micro SD Card Slot\n\n\n\n\nThe Fusion has a Micro SD Card slot in the bottom of the controller. The Micro SD Card contains the operating system and file system of the Fusion.\n\n\n\n\nThe Micro SD Card must be Class 10 with at least 8 GB of space. The Fusion comes with a Micro SD Card preloaded with Fusion software and libraries, ready to run.\n\n\n \n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion SD Card", 
            "title": "SD Card"
        }, 
        {
            "location": "/SD_Card/#micro-sd-card-slot", 
            "text": "The Fusion has a Micro SD Card slot in the bottom of the controller. The Micro SD Card contains the operating system and file system of the Fusion.   The Micro SD Card must be Class 10 with at least 8 GB of space. The Fusion comes with a Micro SD Card preloaded with Fusion software and libraries, ready to run.", 
            "title": "Micro SD Card Slot"
        }, 
        {
            "location": "/SD_Card/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion SD Card", 
            "title": "Questions?"
        }, 
        {
            "location": "/Sensor_Topic/", 
            "text": "Sensor Reference\n\n\n\n\nour Sensors are designed for plug and play with the Fusion Controller. All sensors are fully supported for \nBlockly\n and \nPython\n. The sensors are either \nAnalog\n, \nDigital\n or \nI2C\n interfaces. Refer to the \nFusion Controller\n documentation for more information on all the available ports.\n\nSelect the sensor below for more information and links to programming references.", 
            "title": "Sensor Reference"
        }, 
        {
            "location": "/Sensor_Topic/#sensor-reference", 
            "text": "our Sensors are designed for plug and play with the Fusion Controller. All sensors are fully supported for  Blockly  and  Python . The sensors are either  Analog ,  Digital  or  I2C  interfaces. Refer to the  Fusion Controller  documentation for more information on all the available ports. \nSelect the sensor below for more information and links to programming references.", 
            "title": "Sensor Reference"
        }, 
        {
            "location": "/Sensor_Program_Control_Button/", 
            "text": "Program Control (Push) Button (45-2002)\n\n\n\n\nThe Program Control Button was originally designed for another controller but can be used on the Fusion as a standard push button. It can be used for an array of different tasks including program start/stop button, a mode changer, and various other user interface devices. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.\n\n\n\n\nSensor Type\n : Three Wire Digital\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V", 
            "title": "Program Control Button (45-2002)"
        }, 
        {
            "location": "/Sensor_Program_Control_Button/#program-control-push-button-45-2002", 
            "text": "The Program Control Button was originally designed for another controller but can be used on the Fusion as a standard push button. It can be used for an array of different tasks including program start/stop button, a mode changer, and various other user interface devices. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.   Sensor Type  : Three Wire Digital  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V", 
            "title": "Program Control (Push) Button (45-2002)"
        }, 
        {
            "location": "/Sensor_Rate_Gyro/", 
            "text": "Rate Gyro (45-2004)\n\n\n\n\nThe Rate Gyro is used to detect the rate of rotation. When the Rate Gyro is completely still, the returned reading is 1.4V which produces a reading of 280\u00b0 \u00b12\u00b0. With the sensor idle at 280\u00b0 a Counter Clockwise (CCW) rotation will increase the value of the reading and then return to 280\u00b0 once movement is stopped. A Clockwise (CW) rotation of the gyro will cause a decrease in the return value and return to 280\u00b0 once the sensor is no longer moving. The readings are accurate to the degree.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V \n\n\nRate Gyro Visual Programming Blocks\n\n\nRate Gyro Python Library Information", 
            "title": "Rate Gyro (45-2004)"
        }, 
        {
            "location": "/Sensor_Rate_Gyro/#rate-gyro-45-2004", 
            "text": "The Rate Gyro is used to detect the rate of rotation. When the Rate Gyro is completely still, the returned reading is 1.4V which produces a reading of 280\u00b0 \u00b12\u00b0. With the sensor idle at 280\u00b0 a Counter Clockwise (CCW) rotation will increase the value of the reading and then return to 280\u00b0 once movement is stopped. A Clockwise (CW) rotation of the gyro will cause a decrease in the return value and return to 280\u00b0 once the sensor is no longer moving. The readings are accurate to the degree.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V   Rate Gyro Visual Programming Blocks  Rate Gyro Python Library Information", 
            "title": "Rate Gyro (45-2004)"
        }, 
        {
            "location": "/Sensor_Optical_Distance_Sensor/", 
            "text": "Optical Distance Sensor (45-2006)\n\n\n\n\nThe Optical Distance Sensor (ODS) is an analog sensor that uses electro optical proximity detection to calculate distance from an object based on the intensity of the light. This sensor can calculate distances between 1cm to 15cm. Lighter colored objects will return a more accurate and consistent reading, the material also plays a part on the returned value. Try different colors and material to see what works best for you. The ODS can be used for object detection, line detection and the difference between light and dark.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V  \n\n\nOptical Distance Sensor Visual Programming Blocks\n\n\nOptical Distance Sensor Python Library Information", 
            "title": "Optical Distance Sensor (45-2006)"
        }, 
        {
            "location": "/Sensor_Optical_Distance_Sensor/#optical-distance-sensor-45-2006", 
            "text": "The Optical Distance Sensor (ODS) is an analog sensor that uses electro optical proximity detection to calculate distance from an object based on the intensity of the light. This sensor can calculate distances between 1cm to 15cm. Lighter colored objects will return a more accurate and consistent reading, the material also plays a part on the returned value. Try different colors and material to see what works best for you. The ODS can be used for object detection, line detection and the difference between light and dark.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V    Optical Distance Sensor Visual Programming Blocks  Optical Distance Sensor Python Library Information", 
            "title": "Optical Distance Sensor (45-2006)"
        }, 
        {
            "location": "/Sensor_Touch_Sensor/", 
            "text": "Touch Sensor (45-2007)\n\n\n\n\nThe Touch Sensor can be used for an array of different tasks including object detection, a counter, a standard push button and many more. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.\n\n\n\n\nSensor Type\n : Three Wire Digital\n\n\nDimensions\n : 36mm x 32mm x 15mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V \n\n\nTouch Sensor Visual Programming Blocks\n\n\nTouch Sensor Pythin Library Information", 
            "title": "Touch Sensor (45-2007)"
        }, 
        {
            "location": "/Sensor_Touch_Sensor/#touch-sensor-45-2007", 
            "text": "The Touch Sensor can be used for an array of different tasks including object detection, a counter, a standard push button and many more. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.   Sensor Type  : Three Wire Digital  Dimensions  : 36mm x 32mm x 15mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V   Touch Sensor Visual Programming Blocks  Touch Sensor Pythin Library Information", 
            "title": "Touch Sensor (45-2007)"
        }, 
        {
            "location": "/Sensor_Light_Sensor/", 
            "text": "Light Sensor (45-2015)\n\n\n\n\nThe Light Sensor detects the ambient light level using a phototransistor. The value returned is a quasi-logarithmic analog value. This means that the Light Sensor can detect slight changes in light and dark environments. A value of 0 indicates no light and a value of 1023 indicates the sensor is flooded with light.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V  \n\n\nLight Sensor Visual Programming Blocks\n\n\nLight Sensor Python Library Information", 
            "title": "Light Sensor (45-2015)"
        }, 
        {
            "location": "/Sensor_Light_Sensor/#light-sensor-45-2015", 
            "text": "The Light Sensor detects the ambient light level using a phototransistor. The value returned is a quasi-logarithmic analog value. This means that the Light Sensor can detect slight changes in light and dark environments. A value of 0 indicates no light and a value of 1023 indicates the sensor is flooded with light.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V    Light Sensor Visual Programming Blocks  Light Sensor Python Library Information", 
            "title": "Light Sensor (45-2015)"
        }, 
        {
            "location": "/Sensor_Magnet_Sensor/", 
            "text": "Magnetic Sensor (45-2020)\n\n\n\n\nThe Magnetic Sensor detects a magnetic field and returns the strength based on the distance between the sensor element and the magnet. The default returned by the sensor when no magnetic field is present is approximately 340. When the returned value is increasing, the sensor is detecting the \"North Pole\" of the magnet. If the value returned is decreasing, then the sensor is detecting the \"South Pole\" of the magnet.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V  \n\n\nMagnetic Sensor Visual Programming Blocks\n\n\nMagnetic Sensor Python Library Information", 
            "title": "Magnet Sensor (45-2020)"
        }, 
        {
            "location": "/Sensor_Magnet_Sensor/#magnetic-sensor-45-2020", 
            "text": "The Magnetic Sensor detects a magnetic field and returns the strength based on the distance between the sensor element and the magnet. The default returned by the sensor when no magnetic field is present is approximately 340. When the returned value is increasing, the sensor is detecting the \"North Pole\" of the magnet. If the value returned is decreasing, then the sensor is detecting the \"South Pole\" of the magnet.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V    Magnetic Sensor Visual Programming Blocks  Magnetic Sensor Python Library Information", 
            "title": "Magnetic Sensor (45-2020)"
        }, 
        {
            "location": "/Sensor_Compass/", 
            "text": "Compass (45-2003)\n\n\n\n\nThe Compass uses a magnetometer and an accelerometer to calculate heading data based on Earth\u2019s magnetic field. The compass can return the heading data, accelerometer data and magnetometer data to the user. Anything that generates a magnetic field must be moved away from the sensor like power cables, motor or magnetic material. This must happen because during calibration the sensor will add an offset to account for other magnetic sources in the area.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x24\n\n\nSensor ID Code\n : 0x63\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE) \n\n\nCompass Visual Programming Blocks\n\n\nCompass Python Library Information\n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nCommand\n\n    \n0x04/0x05\nHeading Data (lsb/msb)\n\n    \n0x06/0x07\nAccelerometer X Value (lsb/msb)\n\n    \n0x08/0x09\nAccelerometer Y Value (lsb/msb)\n\n    \n0x0A/0x0B\nAccelerometer Z Value (lsb/msb)\n\n    \n0x0C/0x0D\nMagnetometer X Value (lsb/msb)\n\n    \n0x0E/0x0F\nMagnetometer Y Value (lsb/msb)\n\n    \n0x10/0x11\nMagnetometer Z Value (lsb/msb)\n\n    \n0x12/0x13\nAccelerometer X Offset (lsb/msb)\n\n    \n0x14/0x15\nAccelerometer Y Offset (lsb/msb)\n\n    \n0x16/0x17\nAccelerometer Z Offset (lsb/msb)\n\n    \n0x18/0x19\nMagnetometer X Offset (lsb/msb)\n\n    \n0x1A/0x1B\nMagnetometer Y Offset (lsb/msb)\n\n    \n0x1C/0x1D\nMagnetometer Z Offset (lsb/msb)\n\n    \n0x1E/0x1F\nMagnetometer Tilt Coefficient (lsb/msb)\n\n    \n0x20/0x21\nAccelerometer Scale Coefficient (lsb/msb)\n\n    \n0x22/0x23\nMagnetometer X Scale Coefficient (lsb/msb)\n\n    \n0x24/0x25\nMagnetometer Y Scale Coefficient (lsb/msb)\n\n\n\n\n\n\n    \nCommand\nOperation\nEEPROM Auto-Update\n\n    \n0x00\nNormal measurement mode\n\n    \n0x43\nHard Iron Calibration mode\nX\n\n    \n0x58\nAccelerometer X axis null\nX\n\n    \n0x59\nAccelerometer Y axis null\nX\n\n    \n0x5A\nAccelerometer Z axis null\nX\n\n    \n0x47\nAccelerometer sensitivity/gain adjust\nX\n\n    \n0x55\nMeasure tilted up accelerometer value\n\n    \n0x44\nMeasure tilted down accelerometer value\nX\n\n    \n0x57\nWrite EEPROM Data\nX\n\n\n\n\n\nDuring normal operation, the LED will blink briefly at 1Hz. During Hard Iron Calibration,the LED will blink at \u00bdHz. During tilt up and tilt down calibration the LED will be onduring a period of calibration measurement.\n\n\nHard Iron Calibration\n\n\n\n\nHard Iron Calibration is entered by setting the command location to 0x43. Once Hard Iron Calibration is active rotate the Compass 360\u00b0, making sure it does not tilt, for a period of 5 seconds. Once the rotation procedure is complete, the command location must be set to 0x00 to signal that calibration is complete. If the data collected during the rotation was good, the Compass will enter Normal Measurement Mode using the new calibration data. If the data collected during the rotation was not good, the command value will change to 0x46 and the Compass will enter Normal Measurement Mode using the previous calibration data.\n\n\n\n\nTilt Compensation\n\n\n\n\nTilt compensation is performed in two steps, tilt up and tilt down in that order. The first step is tilt up. To set the Compass up for tilt up measurement, the Compass should be pointed due North and set with the front of the device tiled up by approximately 20\u00b0. Then the command location should be set to 0x55 while the Compass is held perfectly still. Once the LED extinguishes itself, the command location will return to 0x00, indicating that tilt up data has been captured.\n\nThe second step is tilt down. To set the Compass up for tilt down measurement, the Compass should be pointed due North and set with the front of the device tilted down by approximately 20\u00b0. Then the command location should be set to 0x44 while the compass is held perfectly still. Once the LED extinguishes itself, the command location will return 0x00, indicating that tilt down data has been captured and the tilt compensation coefficient has been acquired.\n\nIf the two tilt steps are not performed in the correct order, or some other error is detected, the command location will be set to 0x46 and the Compass will enter Normal Measurement Mode using the previous tilt compensation coefficient.\n\n\n\n\nAccelerometer Nulling\n\n\n\n\nAccelerometer axis nulling is performed using the three axis null commands. For both the x and y axis nulling should be performed with the device set perfectly level. Setting the command location to 0x58 will update the accelerometer X axis offset. Setting the command location to 0x59 will update the accelerometer Y axis offset. For the Z axis nulling, the device should be set to be perfectly vertical. Setting the command location to 0x5A will update the accelerometer Z axis offset\n\n\n\n\nAccelerometer Scale Coefficient\n\n\n\n\nThe Accelerometer Scale Coefficient is adjusted to be approximately 1mg/count. If greater measurement accuracy is required, the Accelerometer Scale Coefficient (fsb/lsb) may be set by the user. This can be simply done by setting the device perfectly vertical\nand obtaining the accelerometer X value via registers 0x06 and 0x07.\n\nOnce the Accelerometer Scale Coefficient has been adjusted, the 0x57 command should be issued to ensure the new value is recorded in EEPROM.\n\n\n\n\nExample:  \n\n\nStep 1: Sensor Position\n\nSet the sensor vertical so that the wires are pointing up in the air.\n\n\nStep 2: Find the X Value\n\nFind the Accelerometer X Value - Register 0x06(lsb)/0x07(msb)  \n\n\nRegister 0x06 (lsb) = \n0xE2\n\nRegister 0x07 (msb) = \n0x04\n  \n\n\nX Value = msb:lsb = 0x04:0xE2 = \n0x04E2\n = \n1250\n\n\nStep 3: Calculating Scaling Value\n\nScaling Value = 1000/X Value = 1000/1250 = \n.8\n\n\nStep 4: Calculate Register Values\n\nRegister Values (lsb:fsb) = .8*256 = 204.8 = 204 = \n0xCC\n = \n0x00CC\n\n\nStep 5: Enter Values into Accelerometer Scale Coefficient Register\n\nAccelerometer Scale Coefficient = 0x20(fsb)/0x21(lsb)\n\n\nRegister 0x20 (fsb) = \n0xCC\n\nRegister 0x21 (lsb) = \n0x00\n\n\nStep 6: Saving the value to EEPROM\n\nEnter a value of \n0x57\n (Write EEPROM Data) to the Command Register (0x03) to save the scaled value into EEPROM.", 
            "title": "Compass (45-2003)"
        }, 
        {
            "location": "/Sensor_Compass/#compass-45-2003", 
            "text": "The Compass uses a magnetometer and an accelerometer to calculate heading data based on Earth\u2019s magnetic field. The compass can return the heading data, accelerometer data and magnetometer data to the user. Anything that generates a magnetic field must be moved away from the sensor like power cables, motor or magnetic material. This must happen because during calibration the sensor will add an offset to account for other magnetic sources in the area.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x24  Sensor ID Code  : 0x63  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)   Compass Visual Programming Blocks  Compass Python Library Information    \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Command \n     0x04/0x05 Heading Data (lsb/msb) \n     0x06/0x07 Accelerometer X Value (lsb/msb) \n     0x08/0x09 Accelerometer Y Value (lsb/msb) \n     0x0A/0x0B Accelerometer Z Value (lsb/msb) \n     0x0C/0x0D Magnetometer X Value (lsb/msb) \n     0x0E/0x0F Magnetometer Y Value (lsb/msb) \n     0x10/0x11 Magnetometer Z Value (lsb/msb) \n     0x12/0x13 Accelerometer X Offset (lsb/msb) \n     0x14/0x15 Accelerometer Y Offset (lsb/msb) \n     0x16/0x17 Accelerometer Z Offset (lsb/msb) \n     0x18/0x19 Magnetometer X Offset (lsb/msb) \n     0x1A/0x1B Magnetometer Y Offset (lsb/msb) \n     0x1C/0x1D Magnetometer Z Offset (lsb/msb) \n     0x1E/0x1F Magnetometer Tilt Coefficient (lsb/msb) \n     0x20/0x21 Accelerometer Scale Coefficient (lsb/msb) \n     0x22/0x23 Magnetometer X Scale Coefficient (lsb/msb) \n     0x24/0x25 Magnetometer Y Scale Coefficient (lsb/msb)   \n     Command Operation EEPROM Auto-Update \n     0x00 Normal measurement mode \n     0x43 Hard Iron Calibration mode X \n     0x58 Accelerometer X axis null X \n     0x59 Accelerometer Y axis null X \n     0x5A Accelerometer Z axis null X \n     0x47 Accelerometer sensitivity/gain adjust X \n     0x55 Measure tilted up accelerometer value \n     0x44 Measure tilted down accelerometer value X \n     0x57 Write EEPROM Data X   During normal operation, the LED will blink briefly at 1Hz. During Hard Iron Calibration,the LED will blink at \u00bdHz. During tilt up and tilt down calibration the LED will be onduring a period of calibration measurement.", 
            "title": "Compass (45-2003)"
        }, 
        {
            "location": "/Sensor_Compass/#hard-iron-calibration", 
            "text": "Hard Iron Calibration is entered by setting the command location to 0x43. Once Hard Iron Calibration is active rotate the Compass 360\u00b0, making sure it does not tilt, for a period of 5 seconds. Once the rotation procedure is complete, the command location must be set to 0x00 to signal that calibration is complete. If the data collected during the rotation was good, the Compass will enter Normal Measurement Mode using the new calibration data. If the data collected during the rotation was not good, the command value will change to 0x46 and the Compass will enter Normal Measurement Mode using the previous calibration data.", 
            "title": "Hard Iron Calibration"
        }, 
        {
            "location": "/Sensor_Compass/#tilt-compensation", 
            "text": "Tilt compensation is performed in two steps, tilt up and tilt down in that order. The first step is tilt up. To set the Compass up for tilt up measurement, the Compass should be pointed due North and set with the front of the device tiled up by approximately 20\u00b0. Then the command location should be set to 0x55 while the Compass is held perfectly still. Once the LED extinguishes itself, the command location will return to 0x00, indicating that tilt up data has been captured. \nThe second step is tilt down. To set the Compass up for tilt down measurement, the Compass should be pointed due North and set with the front of the device tilted down by approximately 20\u00b0. Then the command location should be set to 0x44 while the compass is held perfectly still. Once the LED extinguishes itself, the command location will return 0x00, indicating that tilt down data has been captured and the tilt compensation coefficient has been acquired. \nIf the two tilt steps are not performed in the correct order, or some other error is detected, the command location will be set to 0x46 and the Compass will enter Normal Measurement Mode using the previous tilt compensation coefficient.", 
            "title": "Tilt Compensation"
        }, 
        {
            "location": "/Sensor_Compass/#accelerometer-nulling", 
            "text": "Accelerometer axis nulling is performed using the three axis null commands. For both the x and y axis nulling should be performed with the device set perfectly level. Setting the command location to 0x58 will update the accelerometer X axis offset. Setting the command location to 0x59 will update the accelerometer Y axis offset. For the Z axis nulling, the device should be set to be perfectly vertical. Setting the command location to 0x5A will update the accelerometer Z axis offset", 
            "title": "Accelerometer Nulling"
        }, 
        {
            "location": "/Sensor_Compass/#accelerometer-scale-coefficient", 
            "text": "The Accelerometer Scale Coefficient is adjusted to be approximately 1mg/count. If greater measurement accuracy is required, the Accelerometer Scale Coefficient (fsb/lsb) may be set by the user. This can be simply done by setting the device perfectly vertical\nand obtaining the accelerometer X value via registers 0x06 and 0x07. \nOnce the Accelerometer Scale Coefficient has been adjusted, the 0x57 command should be issued to ensure the new value is recorded in EEPROM.   Example:    Step 1: Sensor Position \nSet the sensor vertical so that the wires are pointing up in the air.  Step 2: Find the X Value \nFind the Accelerometer X Value - Register 0x06(lsb)/0x07(msb)    Register 0x06 (lsb) =  0xE2 \nRegister 0x07 (msb) =  0x04     X Value = msb:lsb = 0x04:0xE2 =  0x04E2  =  1250  Step 3: Calculating Scaling Value \nScaling Value = 1000/X Value = 1000/1250 =  .8  Step 4: Calculate Register Values \nRegister Values (lsb:fsb) = .8*256 = 204.8 = 204 =  0xCC  =  0x00CC  Step 5: Enter Values into Accelerometer Scale Coefficient Register \nAccelerometer Scale Coefficient = 0x20(fsb)/0x21(lsb)  Register 0x20 (fsb) =  0xCC \nRegister 0x21 (lsb) =  0x00  Step 6: Saving the value to EEPROM \nEnter a value of  0x57  (Write EEPROM Data) to the Command Register (0x03) to save the scaled value into EEPROM.", 
            "title": "Accelerometer Scale Coefficient"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/", 
            "text": "Integrating Gyro (45-2005)\n\n\n\n\nThe Integrating Gyro uses a 3-axis chip to obtain \nX\n, \nY\n and \nZ\n coordinates as well as an integration of the z-axis to provide heading data. The integrated Z value is an integration of the z-axis over time and this value is used internally in heading calculations. The LED will blink at 1Hz during normal operation and will remain on during null operation (calibration). Once the null location is set, the sensor will maintain that reference until the sensor is recalibrated or zeroed.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x20\n\n\nSensor ID Code\n : 0x47\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)  \n\n\nIntegrating Gyro Visual Programming Blocks\n\n\nIntegrating Gyro Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nCommand\n\n    \n0x04/0x05\nHeading Data (lsb/msb)\n\n    \n0x06/0x07\nIntegrated Z Value (lsb/msb)\n\n    \n0x08/0x09\nRaw X Value (lsb/msb)\n\n    \n0x0A/0x0B\nRaw Y Value (lsb/msb)\n\n    \n0x0C/0x0D\nRaw Z Value (lsb/msb)\n\n    \n0x0E/0x0F\nZ Axis Offset (lsb/msb)\n\n    \n0x10/0x11\nZ Axis Scaling Coefficient (lsb/msb)\n\n\n\n\n\n\n    \nCommand\nOperation\nEEPROM Auto-Update\n\n    \n0x00\nNormal measurement mode\n\n    \n0x43\nNull gyro offset and reset Z axis integrator\nX\n\n    \n0x52\nReset Z axis integrator\n\n\n\n\n\nDuring normal operation the LED will blink briefly at 1Hz. During Null gyro the LED will\nbe on for the period of calibration.\n\n\nGyro Null\n\n\n\n\nGyro null is entered by setting the command register to 0x4E. The sensor must be kept still for 3 seconds while the sensor calibrates. Once the gyro offset has been measured, the Z axis integrator will be reset to 0 and the command location will reset to 0x00. The Z axis offset field is used to record the offset value and will be automatically recorded in EEPROM.\n\n\nUse 0x52 when resetting your heading value in code. Gyro Null writes to flash memory with a read/write life cycle.\n\n\n\n\nGyro Raw Values\n\n\n\n\nThe three fields X, Y and Z are the unprocessed values being obtained from the sensor element that measure the rate of rotation of an axis. These values are updated at approximately 760Hz.\n\n\n\n\nHeading Data\n\n\n\n\nThe heading data is obtained by dividing the integrated gyro Z value by 360 yielding a remainder which is then forced to lie between 0\u00b0 - 359\u00b0 as the current heading value. If rotated in a \nCW\n direction, the value increases from 0\u00b0. If rotated in a \nCCW\n direction, the value decreases from 359\u00b0.\n\n\n\n\nIntegrated Z Value\n\n\n\n\nThe integrated gyro Z value returns the current value obtained by integrating the Z axis rate value, adjusted by the Z axis offset continuously. This integrated value can be reset to 0 by issuing command 0x52.\n\nThis value can also be used as a signed heading value where \nCCW\n is in the positive direction and \nCW\n is in the negative direction.\n\n\n\n\nZ Axis Scaling Coefficient\n\n\n\n\nThe integrated Z value is subject to scaling based on the Z axis scaling coefficient. This value defaults to 0x0100 which has a binary \u201cdecimal point\u201d between bits 7 and 8. Thus the 0x0100 represents a value of 1.0. This value may be adjusted to ensure that a reading of 360\u00b0 corresponds to one exact revolution of the sensor.\n\nThe Z axis scaling coefficient must be calculated by dividing the angle the sensor is physically rotated by the heading value that is returned from the sensor. The \u201cAngle Rotated\u201d is the number of degrees the Gyro physically rotated (360\u00b0). The \u201cHeading Value\u201d is the value returned by the sensor by the Heading Data registers. Once the value is entered in the Z Axis Scaling Coefficient register, a command of 0x4E (Null Operation) must be made to the command register to save the value to the EEPROM.\n\n\n\n\nExample:  \n\n\nStep 1: Collecting Values\n\nWith the Gyro sitting completely still, type a value of 0x4E (Null gyro offset and reset Z axis integrator) into the Command Register (0x03) to Null the gyro. Then rotate the Gyro 360\u00b0 exactly in a counter clockwise direction and write down the heading value that is returned.\n\n\nAngle Rotated = \n360\u00b0\n \nAlways rotate 360\u00b0 when scaling the Z Axis\n\nHeading Value = Returned Values 0x06(lsb)/0x07(msb)\n\n\nRegister 0x06 (lsb) = \n0x63\n\nRegister 0x07 (msb) = \n0x01\n\n\nHeading Value = \n0x0163\n = \n355\u00b0\n\n\nStep 2: Calculate the Scaling Coefficient\n\n\n\n\nScale Coefficient = Angle Rotated/Heading Value\n\nScale Coefficient = 360/355 = \n1.01\n\n\nThe value obtained in this step is the scaling coefficient. When this scaling coefficient is multiplied by the heading value, the result is a scaled heading.\n\n\nStep 3: Calculate Register Values\n\nRegister Value (lsb:fsb) = 1.01*256 = 258.56\n\nRound Down: 258 = \n0x0102\n\n\nStep 4: Enter Values into Z Axis Scaling Coefficient Register\n\nZ Axis Scaling Coefficient = 0x10(fsb)/0x11(lsb)\n\n\nRegister 0x10 (fsb) = \n0x02\n\nRegister 0x11 (lsb) = \n0x01\n\n\nClick \nWRITE\n to enter the values into the registers. You can then \nREAD\n back to verify the registers contain the correct value.\n\n\nStep 5: Saving the value to EEPROM\n\nEnter a value of 0x4E (Null gyro offset and reset Z axis integrator) to the Command Register (0x03) to save the scaled value into EEPROM and recalibrate the Gyro with the new scaling factor.", 
            "title": "Integrating Gyro (45-2005)"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/#integrating-gyro-45-2005", 
            "text": "The Integrating Gyro uses a 3-axis chip to obtain  X ,  Y  and  Z  coordinates as well as an integration of the z-axis to provide heading data. The integrated Z value is an integration of the z-axis over time and this value is used internally in heading calculations. The LED will blink at 1Hz during normal operation and will remain on during null operation (calibration). Once the null location is set, the sensor will maintain that reference until the sensor is recalibrated or zeroed.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x20  Sensor ID Code  : 0x47  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)    Integrating Gyro Visual Programming Blocks  Integrating Gyro Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Command \n     0x04/0x05 Heading Data (lsb/msb) \n     0x06/0x07 Integrated Z Value (lsb/msb) \n     0x08/0x09 Raw X Value (lsb/msb) \n     0x0A/0x0B Raw Y Value (lsb/msb) \n     0x0C/0x0D Raw Z Value (lsb/msb) \n     0x0E/0x0F Z Axis Offset (lsb/msb) \n     0x10/0x11 Z Axis Scaling Coefficient (lsb/msb)   \n     Command Operation EEPROM Auto-Update \n     0x00 Normal measurement mode \n     0x43 Null gyro offset and reset Z axis integrator X \n     0x52 Reset Z axis integrator   During normal operation the LED will blink briefly at 1Hz. During Null gyro the LED will\nbe on for the period of calibration.", 
            "title": "Integrating Gyro (45-2005)"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/#gyro-null", 
            "text": "Gyro null is entered by setting the command register to 0x4E. The sensor must be kept still for 3 seconds while the sensor calibrates. Once the gyro offset has been measured, the Z axis integrator will be reset to 0 and the command location will reset to 0x00. The Z axis offset field is used to record the offset value and will be automatically recorded in EEPROM.  Use 0x52 when resetting your heading value in code. Gyro Null writes to flash memory with a read/write life cycle.", 
            "title": "Gyro Null"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/#gyro-raw-values", 
            "text": "The three fields X, Y and Z are the unprocessed values being obtained from the sensor element that measure the rate of rotation of an axis. These values are updated at approximately 760Hz.", 
            "title": "Gyro Raw Values"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/#heading-data", 
            "text": "The heading data is obtained by dividing the integrated gyro Z value by 360 yielding a remainder which is then forced to lie between 0\u00b0 - 359\u00b0 as the current heading value. If rotated in a  CW  direction, the value increases from 0\u00b0. If rotated in a  CCW  direction, the value decreases from 359\u00b0.", 
            "title": "Heading Data"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/#integrated-z-value", 
            "text": "The integrated gyro Z value returns the current value obtained by integrating the Z axis rate value, adjusted by the Z axis offset continuously. This integrated value can be reset to 0 by issuing command 0x52. \nThis value can also be used as a signed heading value where  CCW  is in the positive direction and  CW  is in the negative direction.", 
            "title": "Integrated Z Value"
        }, 
        {
            "location": "/Sensor_Integrating_Gyro/#z-axis-scaling-coefficient", 
            "text": "The integrated Z value is subject to scaling based on the Z axis scaling coefficient. This value defaults to 0x0100 which has a binary \u201cdecimal point\u201d between bits 7 and 8. Thus the 0x0100 represents a value of 1.0. This value may be adjusted to ensure that a reading of 360\u00b0 corresponds to one exact revolution of the sensor. \nThe Z axis scaling coefficient must be calculated by dividing the angle the sensor is physically rotated by the heading value that is returned from the sensor. The \u201cAngle Rotated\u201d is the number of degrees the Gyro physically rotated (360\u00b0). The \u201cHeading Value\u201d is the value returned by the sensor by the Heading Data registers. Once the value is entered in the Z Axis Scaling Coefficient register, a command of 0x4E (Null Operation) must be made to the command register to save the value to the EEPROM.   Example:    Step 1: Collecting Values \nWith the Gyro sitting completely still, type a value of 0x4E (Null gyro offset and reset Z axis integrator) into the Command Register (0x03) to Null the gyro. Then rotate the Gyro 360\u00b0 exactly in a counter clockwise direction and write down the heading value that is returned.  Angle Rotated =  360\u00b0   Always rotate 360\u00b0 when scaling the Z Axis \nHeading Value = Returned Values 0x06(lsb)/0x07(msb)  Register 0x06 (lsb) =  0x63 \nRegister 0x07 (msb) =  0x01  Heading Value =  0x0163  =  355\u00b0  Step 2: Calculate the Scaling Coefficient   Scale Coefficient = Angle Rotated/Heading Value \nScale Coefficient = 360/355 =  1.01  The value obtained in this step is the scaling coefficient. When this scaling coefficient is multiplied by the heading value, the result is a scaled heading.  Step 3: Calculate Register Values \nRegister Value (lsb:fsb) = 1.01*256 = 258.56 \nRound Down: 258 =  0x0102  Step 4: Enter Values into Z Axis Scaling Coefficient Register \nZ Axis Scaling Coefficient = 0x10(fsb)/0x11(lsb)  Register 0x10 (fsb) =  0x02 \nRegister 0x11 (lsb) =  0x01  Click  WRITE  to enter the values into the registers. You can then  READ  back to verify the registers contain the correct value.  Step 5: Saving the value to EEPROM \nEnter a value of 0x4E (Null gyro offset and reset Z axis integrator) to the Command Register (0x03) to save the scaled value into EEPROM and recalibrate the Gyro with the new scaling factor.", 
            "title": "Z Axis Scaling Coefficient"
        }, 
        {
            "location": "/Sensor_Range_Sensor/", 
            "text": "Range Sensor (45-2008)\n\n\n\n\nThe Range Sensor combines ultrasonic and optical measuring elements to obtain a reading between 1cm and 255cm. The ultrasonic accurately measures distance to a target up to 255cm away, but it losses accuracy if the object is closer than 5cm. This is where the optical sensor comes into play as it can measure from 1cm out to about 7cm. The target shape and surface material will influence the detectable range.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x28\n\n\nSensor ID Code\n : 0x55\n\n\nDimensions\n : 56mm x 32mm x 17mm\n\n\nMounting Holes\n : 48mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nRange Sensor Visual Programming Blocks\n\n\nRange Sensor Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nNot Used\n\n    \n0x04\nUltrasonic reading (cm)\n\n    \n0x05\nOptical Reading\n\n\n\n\n\nUltrasonic\n\n\n\n\nThe ultrasonic element works by one of the transducers emitting a sound wave and the other receiving the sound wave. This reading is accurate between 5cm and approximately 255cm. Since the value returned is in units of centimeters, the return is linear.\n\n\n\n\nOptical\n\n\n\n\nThe optical element works by emitting infrared light from on LED and receiving infrared light to the other LED. The optical value can detect objects within 15cm. As an object approaches the optical element the returned value will increase at an exponential rate.", 
            "title": "Range Sensor (45-2008)"
        }, 
        {
            "location": "/Sensor_Range_Sensor/#range-sensor-45-2008", 
            "text": "The Range Sensor combines ultrasonic and optical measuring elements to obtain a reading between 1cm and 255cm. The ultrasonic accurately measures distance to a target up to 255cm away, but it losses accuracy if the object is closer than 5cm. This is where the optical sensor comes into play as it can measure from 1cm out to about 7cm. The target shape and surface material will influence the detectable range.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x28  Sensor ID Code  : 0x55  Dimensions  : 56mm x 32mm x 17mm  Mounting Holes  : 48mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  Range Sensor Visual Programming Blocks  Range Sensor Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Not Used \n     0x04 Ultrasonic reading (cm) \n     0x05 Optical Reading", 
            "title": "Range Sensor (45-2008)"
        }, 
        {
            "location": "/Sensor_Range_Sensor/#ultrasonic", 
            "text": "The ultrasonic element works by one of the transducers emitting a sound wave and the other receiving the sound wave. This reading is accurate between 5cm and approximately 255cm. Since the value returned is in units of centimeters, the return is linear.", 
            "title": "Ultrasonic"
        }, 
        {
            "location": "/Sensor_Range_Sensor/#optical", 
            "text": "The optical element works by emitting infrared light from on LED and receiving infrared light to the other LED. The optical value can detect objects within 15cm. As an object approaches the optical element the returned value will increase at an exponential rate.", 
            "title": "Optical"
        }, 
        {
            "location": "/Sensor_IR_Locator_360/", 
            "text": "IR Locator 360\u00b0 (45-2009)\n\n\n\n\nThe IR Locator 360\u00b0 utilizes an array of 4 photodiodes to detect the direction and distance from a 1200Hz or 600Hz pulsed infrared source with a  5\u00b0resolution. Both the 600Hz and 1200Hz frequencies can be read at the same time allowing up to two directional sources to be used. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. \n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x1C\n\n\nSensor ID Code\n : 0x4C\n\n\nDimensions\n : 56mm x 32mm x 31mm\n\n\nMounting Holes\n : 48mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE) \n\n\nIR Locator 360\u00b0 Visual Programming Blocks\n\n\nIR Locator 360\u00b0 Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nNot Used\n\n    \n0x04\n1200 Hz Heading in 5\u00b0 increments\n\n    \n0x05\n1200 Hz Signal Strength\n\n    \n0x06\n600 Hz Heading in 5\u00b0 increments\n\n    \n0x07\n600 Hz Signal Strength\n\n\n\n\n\nThe frequencies are channels that the IR Locator 360 uses to tell the difference between IR emitting sources. Both 600Hz and 1200Hz IR signals may be present at the same time which results in two identifiable IR sources.\n\n\nHeading\n\n\n\n\nThe heading value is returned in degrees and ranges from 0 to 71 at a resolution of 5\u00b0. If an object were to circle the sensor in a clockwise direction, the value of degrees will increase. If the object were to circle in a counter clockwise direction, the value of the heading will decrease.\n\n\n\n\nStrength\n\n\n\n\nThe strength value represents the distance of the IR source out to a range of about 3m. When no IR source is detected the value of the strength approaches 0. As an IR source get closer to the sensor the value of the strength goes to 255.", 
            "title": "IR Locator 360\u00b0 (45-2009)"
        }, 
        {
            "location": "/Sensor_IR_Locator_360/#ir-locator-360-45-2009", 
            "text": "The IR Locator 360\u00b0 utilizes an array of 4 photodiodes to detect the direction and distance from a 1200Hz or 600Hz pulsed infrared source with a  5\u00b0resolution. Both the 600Hz and 1200Hz frequencies can be read at the same time allowing up to two directional sources to be used. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used.    Sensor Type  : Four Wire I2C  Default I2C Address  : 0x1C  Sensor ID Code  : 0x4C  Dimensions  : 56mm x 32mm x 31mm  Mounting Holes  : 48mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)   IR Locator 360\u00b0 Visual Programming Blocks  IR Locator 360\u00b0 Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Not Used \n     0x04 1200 Hz Heading in 5\u00b0 increments \n     0x05 1200 Hz Signal Strength \n     0x06 600 Hz Heading in 5\u00b0 increments \n     0x07 600 Hz Signal Strength   The frequencies are channels that the IR Locator 360 uses to tell the difference between IR emitting sources. Both 600Hz and 1200Hz IR signals may be present at the same time which results in two identifiable IR sources.", 
            "title": "IR Locator 360\u00b0 (45-2009)"
        }, 
        {
            "location": "/Sensor_IR_Locator_360/#heading", 
            "text": "The heading value is returned in degrees and ranges from 0 to 71 at a resolution of 5\u00b0. If an object were to circle the sensor in a clockwise direction, the value of degrees will increase. If the object were to circle in a counter clockwise direction, the value of the heading will decrease.", 
            "title": "Heading"
        }, 
        {
            "location": "/Sensor_IR_Locator_360/#strength", 
            "text": "The strength value represents the distance of the IR source out to a range of about 3m. When no IR source is detected the value of the strength approaches 0. As an IR source get closer to the sensor the value of the strength goes to 255.", 
            "title": "Strength"
        }, 
        {
            "location": "/Sensor_Sound_Generator/", 
            "text": "Sound Generator (45-2016)\n\n\n\n\nThe Sound Generator can generate a sound based on volume, pitch and duration. This sensor also can overwrite settings during a tone to change the pitch, volume, or extend the duration of the tone.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x34\n\n\nSensor ID Code\n : 0x53\n\n\nDimensions\n : 32mm x 32mm x 19mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)  \n\n\nSound Generator Visual Programming Blocks\n\n\nSound Generator Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nNot Used\n\n    \n0x04\nSound level\n\n    \n0x05/0x06\nPitch (lsb/msb)\n\n    \n0x07\nDuration\n\n\n\n\n\nThe order if the 4 control bytes, Sound Level, Pitch (lsb), Pitch (msb) and Duration are arranged such that a signal 4 byte write can be used to initiate a tone.\n\n\nSound Level\n\n\n\n\nControls the amplitude of the output signal from 0 to 3 where 0 is the quietest and 3 is the loudest.\n\n\n\n\nPitch\n\n\n\n\nConsisting of 2 bytes to make a word, the Pitch controls the frequency of the output in increments of 1Hz. The frequencies range from 1Hz to 65kHz, although operation over 5kHz is not recommended and may damage the device. The speaker resonates at about 2kHz, so the speaker will sound much louder at this frequency.\n\n\n\n\nDuration\n\n\n\n\nThis controls the duration of the tone in increments of 10 msec. The duration of the tone can range from 10 msec \u2013 2.55 sec. The duration of the tone begins a countdown and will stop when the counter reaches 0. The duration may be updated at anytime to extend the length of a tone past 2.55 sec.", 
            "title": "Sound Generator (45-2016)"
        }, 
        {
            "location": "/Sensor_Sound_Generator/#sound-generator-45-2016", 
            "text": "The Sound Generator can generate a sound based on volume, pitch and duration. This sensor also can overwrite settings during a tone to change the pitch, volume, or extend the duration of the tone.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x34  Sensor ID Code  : 0x53  Dimensions  : 32mm x 32mm x 19mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)    Sound Generator Visual Programming Blocks  Sound Generator Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Not Used \n     0x04 Sound level \n     0x05/0x06 Pitch (lsb/msb) \n     0x07 Duration   The order if the 4 control bytes, Sound Level, Pitch (lsb), Pitch (msb) and Duration are arranged such that a signal 4 byte write can be used to initiate a tone.", 
            "title": "Sound Generator (45-2016)"
        }, 
        {
            "location": "/Sensor_Sound_Generator/#sound-level", 
            "text": "Controls the amplitude of the output signal from 0 to 3 where 0 is the quietest and 3 is the loudest.", 
            "title": "Sound Level"
        }, 
        {
            "location": "/Sensor_Sound_Generator/#pitch", 
            "text": "Consisting of 2 bytes to make a word, the Pitch controls the frequency of the output in increments of 1Hz. The frequencies range from 1Hz to 65kHz, although operation over 5kHz is not recommended and may damage the device. The speaker resonates at about 2kHz, so the speaker will sound much louder at this frequency.", 
            "title": "Pitch"
        }, 
        {
            "location": "/Sensor_Sound_Generator/#duration", 
            "text": "This controls the duration of the tone in increments of 10 msec. The duration of the tone can range from 10 msec \u2013 2.55 sec. The duration of the tone begins a countdown and will stop when the counter reaches 0. The duration may be updated at anytime to extend the length of a tone past 2.55 sec.", 
            "title": "Duration"
        }, 
        {
            "location": "/Sensor_IR_Seeker_V3/", 
            "text": "IR Seeker V3 (45-2017)\n\n\n\n\nThe IR Seeker V3 consists of 2 photodiodes to locate the direction and intensity of an IR source relative to the front of the sensor. The sensor can detect pulsed infrared light at 600Hz and 1200Hz with a 150\u00b0 field of view. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. Overall detection range is based on the intensity of the IR source being used.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x38\n\n\nSensor ID Code\n : 0x49\n\n\nDimensions\n : 32mm x 32mm x 19mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)  \n\n\nIR Seeker V3 Visual Programming Blocks\n\n\nIR Seeker V3 Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nNot Used\n\n    \n0x04\n1200 Hz Heading Data\n\n    \n0x05\n1200 Hz Signal Strength\n\n    \n0x06\n600 Hz Heading Data\n\n    \n0x07\n600 Hz Signal Strength\n\n    \n0x08/0x09\n1200 Hz Left Side Raw Heading Data (lsb/msb)\n\n    \n0x0A/0x0B\n1200 Hz Right Side Raw Heading Data (lsb/msb)\n\n    \n0x0C/0x0D\n600 Hz Left Side Raw Heading Data (lsb/msb)\n\n    \n0x0E/0x0F\n600 Hz Right Side Raw Heading Data (lsb/msb)\n\n\n\n\n\nThe frequencies are channels that the IR Seeker V3 uses to tell the difference between IR emitting sources. Both 600Hz and 1200Hz IR signals may be present at the same time which results in two identifiable IR sources.\n\n\nHeading\n\n\n\n\nThe heading value gives an indication of the source direction. If the value is negative, then the source is to the left of center. If the value is positive, then the source is to the right of center. The magnitude of the values gives an indication of how far off the axis the source is. If the value is zero, then the source is in the center of the field of view.\n\n\n\n\nStrength\n\n\n\n\nThe strength value represents the magnitude of the receive signal. If this value is set to 0, it means that not enough IR signal is available to estimate the heading value. The value of the strength will increase as an IR source approaches the sensor.", 
            "title": "IR Seeker V3 (45-2017)"
        }, 
        {
            "location": "/Sensor_IR_Seeker_V3/#ir-seeker-v3-45-2017", 
            "text": "The IR Seeker V3 consists of 2 photodiodes to locate the direction and intensity of an IR source relative to the front of the sensor. The sensor can detect pulsed infrared light at 600Hz and 1200Hz with a 150\u00b0 field of view. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. Overall detection range is based on the intensity of the IR source being used.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x38  Sensor ID Code  : 0x49  Dimensions  : 32mm x 32mm x 19mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)    IR Seeker V3 Visual Programming Blocks  IR Seeker V3 Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Not Used \n     0x04 1200 Hz Heading Data \n     0x05 1200 Hz Signal Strength \n     0x06 600 Hz Heading Data \n     0x07 600 Hz Signal Strength \n     0x08/0x09 1200 Hz Left Side Raw Heading Data (lsb/msb) \n     0x0A/0x0B 1200 Hz Right Side Raw Heading Data (lsb/msb) \n     0x0C/0x0D 600 Hz Left Side Raw Heading Data (lsb/msb) \n     0x0E/0x0F 600 Hz Right Side Raw Heading Data (lsb/msb)   The frequencies are channels that the IR Seeker V3 uses to tell the difference between IR emitting sources. Both 600Hz and 1200Hz IR signals may be present at the same time which results in two identifiable IR sources.", 
            "title": "IR Seeker V3 (45-2017)"
        }, 
        {
            "location": "/Sensor_IR_Seeker_V3/#heading", 
            "text": "The heading value gives an indication of the source direction. If the value is negative, then the source is to the left of center. If the value is positive, then the source is to the right of center. The magnitude of the values gives an indication of how far off the axis the source is. If the value is zero, then the source is in the center of the field of view.", 
            "title": "Heading"
        }, 
        {
            "location": "/Sensor_IR_Seeker_V3/#strength", 
            "text": "The strength value represents the magnitude of the receive signal. If this value is set to 0, it means that not enough IR signal is available to estimate the heading value. The value of the strength will increase as an IR source approaches the sensor.", 
            "title": "Strength"
        }, 
        {
            "location": "/Sensor_Color_Sensor/", 
            "text": "Color Sensor (45-2018)\n\n\n\n\nThe Color Sensor is used to detect the color of an object or a visible light source. Along with raw and adjusted RGB values, the device can also return a color number corresponding to a the colors listed below in the documentation. Calibration steps must be taken as needed based on the environment and ambient lighting for the most accurate readings. Maximum detection distance of the color sensor is approximately 7cm and it is recommended that during active mode the device is placed at a slight angle to avoid white light reflecting from the LED. \n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x3C\n\n\nSensor ID Code\n : 0x67\n\n\nDimensions\n : 32mm x 32mm x 11mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE) \n\n\nColor Sensor Visual Programming Blocks\n\n\nColor Sensor Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nCommand\n\n    \n0x04\nColor Number\n\n    \n0x05\nRed Value\n\n    \n0x06\nGreen Value\n\n    \n0x07\nBlue Value\n\n    \n0x08\nWhite Value\n\n    \n0x09\nColor Index Number\n\n    \n0x0A\nRed Index\n\n    \n0x0B\nGreen Index\n\n    \n0x0C\nBlue Index\n\n    \n0x0D\nUndefined\n\n    \n0x0E/0x0F\nRed Reading (lsb/msb)\n\n    \n0x10/0x11\nGreen Reading (lsb/msb)\n\n    \n0x12/0x13\nBlue Reading (lsb/msb)\n\n    \n0x14/0x15\nWhite Reading (lsb/msb)\n\n    \n0x16/0x17\nNormalized Red Reading (lsb/msb)\n\n    \n0x18/0x19\nNormalized Green Reading (lsb/msb)\n\n    \n0x1A/0x1B\nNormalized Blue Reading (lsb/msb)\n\n    \n0x1C/0x1D\nNormalized White Reading (lsb/msb)\n\n\n\n\n\n\n    \nCommand\nOperation\nEEPROM Auto-Update\n\n    \n0x00\nActive Mode (LED On)\nX\n\n    \n0x01\nPassive Mode (LED Off)\nX\n\n    \n0x35\n50 Hz Operating Frequency\nX\n\n    \n0x36\n60 Hz Operating Frequency\nX\n\n    \n0x42\nBlack Level Calibration\nX\n\n    \n0x43\nWhite Balance Calibration\nX\n\n\n\n\n\nCommands\n\n\n\n\nThe command register may be set to any of the values from the command table. Once a command value is entered into the command register the value will be saved in the EEPROM.\n\n\n\n\nActive Measurement Mode\n\n\nCommand = 0x00\n\nIn active measurement mode, the sensor takes a reading by illuminating a surface with a white LED and measuring the reflected light. Active mode is useful in identifying the color of a surface.\n\n\nPassive Measurement Mode\n\n\nCommand = 0x01\n\nIn passive measurement mode, the sensor takes a reading without the white LED on. Therefore passive measurement mode is most useful in determining the color of a light source like an LED.\n\n\nOperating Frequency\n\n\nCommand = 0x35(50Hz) or 0x36(60Hz)\n\nThe operating frequency is provided to enable the sampling to coincide with the normal flickering associated with artificial lighting. This helps to reduce signal noise and other issues. The operating frequency can be set to 50Hz or 60Hz.\n\n\nBlack Level Calibration\n\n\nCommand = 0x42\n\nBlack level calibration will run 64 measurement cycles to obtain an average value for each of the 3 color channels.\n\nDuring black level calibration, the sensor should be placed such that no surface is within 1.5m forward of the sensor elements. The calibration process last about 1.5 seconds and when calibration is complete, the LED will blink briefly and then the command register will be reset to 0x00 or 0x01 depending on the mode save in EEPROM.\n\nBlack level calibration must be completed before white balance calibration.\n\n\nWhite Balance Calibration\n\n\nCommand = 0x43\n\nWhite balance calibration will run 64 measurement cycles to obtain and average value for each of the 3 color channels and are adjusted according to the black level calibration values.\n\nDuring white balance calibration, the sensor must be placed approximately 5cm (2in) from a white target. The target must be very white and not allow light to pass through the material. At least 3 sheets of high quality copy paper will make a satisfactory white surface for calibration. The calibration process last about 1.5 seconds and when calibration is complete, the LED will blink briefly and then the command register will be reset to 0x00 or 0x01 depending on the mode save in EEPROM.\n\n\n\n\n\n\nColor Number\n\n\n\n\nThe color number register returns a single number representing the color estimate. The number corresponds to the following figure.\n\n\n\n\n\n\nColor Values\n\n\n\n\nThe color values are returned separately as red, green, blue and white. The color value is a measure of the current detection levels for each primary color.\n\n\n\n\nColor Index Number\n\n\n\n\nThe color index number is a single 6 bit number. Bits (5:4) encode the red signal level, bits (3:2) encode the green signal level and bits (1:0) encode the blue signal levels.\n\n\n\n\n\n    \nD7\nD6\nD5\nD4\nD3\nD2\nD1\nD0\n\n    \n0\n0\nRed 1\nRed 0\nGreen 1\nGreen 0\nBlue 1\nBlue 0\n\n\n\n\n\nColor Indexes\n\n\n\n\nThe color index will return the current analog signal levels for red, green and blue separately. The color with the greatest intensity is set as 0xFF while the other two colors indexes are set as a proportion of 0xFF.\n\n\n\n\nColor Readings\n\n\n\n\nThe color reading registers return the current analog signal levels as 16 bits values forred, green, blue and white.\n\n\n\n\nColor Normalized Readings\n\n\n\n\nThe color normalized readings will return the current levels for the color components and white channel that are adjusted for gain and offset.", 
            "title": "Color Sensor (45-2018)"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-sensor-45-2018", 
            "text": "The Color Sensor is used to detect the color of an object or a visible light source. Along with raw and adjusted RGB values, the device can also return a color number corresponding to a the colors listed below in the documentation. Calibration steps must be taken as needed based on the environment and ambient lighting for the most accurate readings. Maximum detection distance of the color sensor is approximately 7cm and it is recommended that during active mode the device is placed at a slight angle to avoid white light reflecting from the LED.    Sensor Type  : Four Wire I2C  Default I2C Address  : 0x3C  Sensor ID Code  : 0x67  Dimensions  : 32mm x 32mm x 11mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)   Color Sensor Visual Programming Blocks  Color Sensor Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Command \n     0x04 Color Number \n     0x05 Red Value \n     0x06 Green Value \n     0x07 Blue Value \n     0x08 White Value \n     0x09 Color Index Number \n     0x0A Red Index \n     0x0B Green Index \n     0x0C Blue Index \n     0x0D Undefined \n     0x0E/0x0F Red Reading (lsb/msb) \n     0x10/0x11 Green Reading (lsb/msb) \n     0x12/0x13 Blue Reading (lsb/msb) \n     0x14/0x15 White Reading (lsb/msb) \n     0x16/0x17 Normalized Red Reading (lsb/msb) \n     0x18/0x19 Normalized Green Reading (lsb/msb) \n     0x1A/0x1B Normalized Blue Reading (lsb/msb) \n     0x1C/0x1D Normalized White Reading (lsb/msb)   \n     Command Operation EEPROM Auto-Update \n     0x00 Active Mode (LED On) X \n     0x01 Passive Mode (LED Off) X \n     0x35 50 Hz Operating Frequency X \n     0x36 60 Hz Operating Frequency X \n     0x42 Black Level Calibration X \n     0x43 White Balance Calibration X", 
            "title": "Color Sensor (45-2018)"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#commands", 
            "text": "The command register may be set to any of the values from the command table. Once a command value is entered into the command register the value will be saved in the EEPROM.   Active Measurement Mode  Command = 0x00 \nIn active measurement mode, the sensor takes a reading by illuminating a surface with a white LED and measuring the reflected light. Active mode is useful in identifying the color of a surface.  Passive Measurement Mode  Command = 0x01 \nIn passive measurement mode, the sensor takes a reading without the white LED on. Therefore passive measurement mode is most useful in determining the color of a light source like an LED.  Operating Frequency  Command = 0x35(50Hz) or 0x36(60Hz) \nThe operating frequency is provided to enable the sampling to coincide with the normal flickering associated with artificial lighting. This helps to reduce signal noise and other issues. The operating frequency can be set to 50Hz or 60Hz.  Black Level Calibration  Command = 0x42 \nBlack level calibration will run 64 measurement cycles to obtain an average value for each of the 3 color channels. \nDuring black level calibration, the sensor should be placed such that no surface is within 1.5m forward of the sensor elements. The calibration process last about 1.5 seconds and when calibration is complete, the LED will blink briefly and then the command register will be reset to 0x00 or 0x01 depending on the mode save in EEPROM. \nBlack level calibration must be completed before white balance calibration.  White Balance Calibration  Command = 0x43 \nWhite balance calibration will run 64 measurement cycles to obtain and average value for each of the 3 color channels and are adjusted according to the black level calibration values. \nDuring white balance calibration, the sensor must be placed approximately 5cm (2in) from a white target. The target must be very white and not allow light to pass through the material. At least 3 sheets of high quality copy paper will make a satisfactory white surface for calibration. The calibration process last about 1.5 seconds and when calibration is complete, the LED will blink briefly and then the command register will be reset to 0x00 or 0x01 depending on the mode save in EEPROM.", 
            "title": "Commands"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-number", 
            "text": "The color number register returns a single number representing the color estimate. The number corresponds to the following figure.", 
            "title": "Color Number"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-values", 
            "text": "The color values are returned separately as red, green, blue and white. The color value is a measure of the current detection levels for each primary color.", 
            "title": "Color Values"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-index-number", 
            "text": "The color index number is a single 6 bit number. Bits (5:4) encode the red signal level, bits (3:2) encode the green signal level and bits (1:0) encode the blue signal levels.   \n     D7 D6 D5 D4 D3 D2 D1 D0 \n     0 0 Red 1 Red 0 Green 1 Green 0 Blue 1 Blue 0", 
            "title": "Color Index Number"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-indexes", 
            "text": "The color index will return the current analog signal levels for red, green and blue separately. The color with the greatest intensity is set as 0xFF while the other two colors indexes are set as a proportion of 0xFF.", 
            "title": "Color Indexes"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-readings", 
            "text": "The color reading registers return the current analog signal levels as 16 bits values forred, green, blue and white.", 
            "title": "Color Readings"
        }, 
        {
            "location": "/Sensor_Color_Sensor/#color-normalized-readings", 
            "text": "The color normalized readings will return the current levels for the color components and white channel that are adjusted for gain and offset.", 
            "title": "Color Normalized Readings"
        }, 
        {
            "location": "/Sensor_Color_Beacon/", 
            "text": "Color Beacon (45-2019)\n\n\n\n\nThe Color Beacon is used to display one of seven colors or any set custom color based on RGB values.\n\nThe beacon can also indicate \nRed\n/\nBlue\n team colors with the use of a magnet. There is no code or setup needed to operate as a team indicator. There is a Hall Effect sensor located on the left side of the sensors (wire pointed toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to \nRed\n, \nBlue\n or \nOff\n. This can be done at any time and will overwrite any custom color or color number. When the beacon is \nRed\n or \nBlue\n from the Hall Effect sensor, it will be locked in that mode until turned \nOff\n using a magnet or disconnecting the sensor.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x4C\n\n\nSensor ID Code\n : 0x75\n\n\nDimensions\n : 56mm x 32mm x 17mm\n\n\nMounting Holes\n : 48mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nLED Brightness\n : 840 Red, 1680 Green, 420 Blue mcd (millicandela) \n\n\nColor Beacon Visual Programming Blocks\n\n\nColor Beacon Python Library Information\n  \n\n\n\n\n\n\n\n    \nRegister\nFunction\n\n    \n0x00\nSensor Firmware Revision\n\n    \n0x01\nManufacturer Code\n\n    \n0x02\nSensor ID Code\n\n    \n0x03\nNot Used\n\n    \n0x04\nColor Number\n\n    \n0x05\nRed Strength\n\n    \n0x06\nGreen Strength\n\n    \n0x07\nBlue Strength\n\n\n\n\n\n\n    \nColor Value\nFunction\n\n    \nN/A\nHall Effect changes LED (Red/Blue/Off)\n\n    \n0\nLEDs Off\n\n    \n1\nRed\n\n    \n2\nGreen\n\n    \n3\nYellow\n\n    \n4\nBlue\n\n    \n5\nPurple\n\n    \n6\nTeal\n\n    \n7\nWhite\n\n    \n8\nCustom Color\n\n\n\n\n\nColor Number\n\n\n\n\nThe color number represents the color the Color Beacon will display. Values 0-7 display the colors as listed in the chart above. A value of 8 creates a custom color.\n\n\n\n\nCustom Color\n\n\n\n\nA custom color is created by entering a value of 8 into the color number register. Then using a 0-255 (0x00-0xFF) value, enter the Red (0x05), Green (0x06), and Blue (0x07) strength values into the corresponding registers.\n\n\n\n\nHall Effect Red/Blue Beacon\n\n\n\n\nThe Hall Effect sensor is located in the left side of the sensors (wire point toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to red, blue or off. This can be done at any time and will overwrite any custom color or color number. When the beacon is red or blue from the Hall Effects sensor, the beacon will not be able to be changed from code. The beacon will need to be disconnected and reconnected, or switched to the off mode using a magnet.", 
            "title": "Color Beacon (45-2019)"
        }, 
        {
            "location": "/Sensor_Color_Beacon/#color-beacon-45-2019", 
            "text": "The Color Beacon is used to display one of seven colors or any set custom color based on RGB values. \nThe beacon can also indicate  Red / Blue  team colors with the use of a magnet. There is no code or setup needed to operate as a team indicator. There is a Hall Effect sensor located on the left side of the sensors (wire pointed toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to  Red ,  Blue  or  Off . This can be done at any time and will overwrite any custom color or color number. When the beacon is  Red  or  Blue  from the Hall Effect sensor, it will be locked in that mode until turned  Off  using a magnet or disconnecting the sensor.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x4C  Sensor ID Code  : 0x75  Dimensions  : 56mm x 32mm x 17mm  Mounting Holes  : 48mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  LED Brightness  : 840 Red, 1680 Green, 420 Blue mcd (millicandela)   Color Beacon Visual Programming Blocks  Color Beacon Python Library Information       \n     Register Function \n     0x00 Sensor Firmware Revision \n     0x01 Manufacturer Code \n     0x02 Sensor ID Code \n     0x03 Not Used \n     0x04 Color Number \n     0x05 Red Strength \n     0x06 Green Strength \n     0x07 Blue Strength   \n     Color Value Function \n     N/A Hall Effect changes LED (Red/Blue/Off) \n     0 LEDs Off \n     1 Red \n     2 Green \n     3 Yellow \n     4 Blue \n     5 Purple \n     6 Teal \n     7 White \n     8 Custom Color", 
            "title": "Color Beacon (45-2019)"
        }, 
        {
            "location": "/Sensor_Color_Beacon/#color-number", 
            "text": "The color number represents the color the Color Beacon will display. Values 0-7 display the colors as listed in the chart above. A value of 8 creates a custom color.", 
            "title": "Color Number"
        }, 
        {
            "location": "/Sensor_Color_Beacon/#custom-color", 
            "text": "A custom color is created by entering a value of 8 into the color number register. Then using a 0-255 (0x00-0xFF) value, enter the Red (0x05), Green (0x06), and Blue (0x07) strength values into the corresponding registers.", 
            "title": "Custom Color"
        }, 
        {
            "location": "/Sensor_Color_Beacon/#hall-effect-redblue-beacon", 
            "text": "The Hall Effect sensor is located in the left side of the sensors (wire point toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to red, blue or off. This can be done at any time and will overwrite any custom color or color number. When the beacon is red or blue from the Hall Effects sensor, the beacon will not be able to be changed from code. The beacon will need to be disconnected and reconnected, or switched to the off mode using a magnet.", 
            "title": "Hall Effect Red/Blue Beacon"
        }, 
        {
            "location": "/Basic_Fusion-Control/", 
            "text": "Basic Fusion Control\n\n\n\n\nThe Basic Fusion Control toolbox comes with the necessary Start, LED and Wait blocks.\n\n\nList of available blocks:\n  \n\n\n\n\nStart Block\n\n\nMotor Selection Blocks\n\n\nDrive With Gyro\n\n\nBlue LED ON\n\n\nYellow LED ON\n\n\nBoth LEDs ON\n\n\nBoth LEDs OFF\n\n\nWait\n\n\n\n\nStart Block\n\n\n\n\nInitializes the Fusion Robot at the start of every program. This block must be used in every Blockly program. By default the Start block is included in the programming environment. \n\n\nBlock:\n\n\n\n\n\n\nMotor Selection Blocks\n\n\n\n\nRobot Kits may be supplied with two different motors which have different characteristics.  Each program must have a motor selection block to configure the program for the motor type.\n\n\nThe wheels are the easiest way to tell which motors your robot has.  To select the proper motor type, add one of these two blocks based on the color of your wheels.  The block should be placed immediately after the Start Block: \n\n\nBlocks:\n\n\n \n\n\n\n\nDrive With Gyro\n\n\n\n\nThis block enables the robot to move using the Boxlight Robotics \nIntegrating Gyro\n for percise turning. When used in a program, the basic \nMove\n and \nRotate\n blocks become modified.  \n\n\nBlock:\n\n\n\n\nThe Integrating Gyro can be placed anywhere on the robot, but it must lay flat and oriented right-side up.\n\n\n\n\n\n\n\n\nBlue LED ON\n\n\n\n\nTurn on the Blue LED. Turn off the Yellow LED.\n\n\nBlock:\n\n\n\n\n\n\nYellow LED ON\n\n\n\n\nTurn on the Yellow LED. Turn off the Blue LED.\n\n\nBlock:\n\n\n\n\n\n\nBoth LEDs ON\n\n\n\n\nTurn on the Yellow and Blue LEDs.\n\n\nBlock:\n\n\n\n\n\n\nBoth LEDs OFF\n\n\n\n\nTurn off the Yellow and Blue LEDs.\n\n\nBlock:\n\n\n\n\n\n\nWait\n\n\n\n\nWait 1 Second.\n\n\nBlock:\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Basic Fusion Control", 
            "title": "Basic Fusion Control"
        }, 
        {
            "location": "/Basic_Fusion-Control/#basic-fusion-control", 
            "text": "The Basic Fusion Control toolbox comes with the necessary Start, LED and Wait blocks.  List of available blocks:      Start Block  Motor Selection Blocks  Drive With Gyro  Blue LED ON  Yellow LED ON  Both LEDs ON  Both LEDs OFF  Wait", 
            "title": "Basic Fusion Control"
        }, 
        {
            "location": "/Basic_Fusion-Control/#start-block", 
            "text": "Initializes the Fusion Robot at the start of every program. This block must be used in every Blockly program. By default the Start block is included in the programming environment.", 
            "title": "Start Block"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#motor-selection-blocks", 
            "text": "Robot Kits may be supplied with two different motors which have different characteristics.  Each program must have a motor selection block to configure the program for the motor type.  The wheels are the easiest way to tell which motors your robot has.  To select the proper motor type, add one of these two blocks based on the color of your wheels.  The block should be placed immediately after the Start Block:", 
            "title": "Motor Selection Blocks"
        }, 
        {
            "location": "/Basic_Fusion-Control/#blocks", 
            "text": "", 
            "title": "Blocks:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#drive-with-gyro", 
            "text": "This block enables the robot to move using the Boxlight Robotics  Integrating Gyro  for percise turning. When used in a program, the basic  Move  and  Rotate  blocks become modified.", 
            "title": "Drive With Gyro"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block_1", 
            "text": "The Integrating Gyro can be placed anywhere on the robot, but it must lay flat and oriented right-side up.", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#blue-led-on", 
            "text": "Turn on the Blue LED. Turn off the Yellow LED.", 
            "title": "Blue LED ON"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#yellow-led-on", 
            "text": "Turn on the Yellow LED. Turn off the Blue LED.", 
            "title": "Yellow LED ON"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#both-leds-on", 
            "text": "Turn on the Yellow and Blue LEDs.", 
            "title": "Both LEDs ON"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#both-leds-off", 
            "text": "Turn off the Yellow and Blue LEDs.", 
            "title": "Both LEDs OFF"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block_5", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#wait", 
            "text": "Wait 1 Second.", 
            "title": "Wait"
        }, 
        {
            "location": "/Basic_Fusion-Control/#block_6", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Fusion-Control/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Basic Fusion Control", 
            "title": "Questions?"
        }, 
        {
            "location": "/Basic_Move-Robot/", 
            "text": "Basic Move Robot Control\n\n\n\n\nThe Move toolbox contains blocks to drive the robot forward and backward. There are also basic speed controls included in this toolbox.\n\n\nList of available blocks:\n  \n\n\n\n\nForward\n\n\nBackward\n\n\nFast\n\n\nMedium\n\n\nSlow\n\n\n\n\nMotor Selection Blocks - Reminder\n\n\n\n\nTo set the software to provide the correct speed values for straight line and cured motion, the program bust being with a Motor Selection Block.  \n\n\nRobot Kits may be supplied with two different motors which have different characteristics.  Each program must have a motor selection block to configure the program for the motor type.\n\n\nThe wheels are the easiest way to tell which motors your robot has.  To select the proper motor type, add one of these two blocks based on the color of your wheels.  The Motor Selection Block should be placed immediately after the Start Block.\n\n\nThese blocks can be found in the \nFusion Control\n toolbox.  \n\n\nBlocks:\n\n\n \n\n\nForward\n\n\nDrive forward for 1 second then stop.\n\n\nBlock:\n\n\n\n\n\n\nBackward\n\n\n\n\nDrive reverse for 1 second then stop.\n\n\nBlock:\n\n\n\n\n\n\nFast\n\n\n\n\nChange the default speed to 80.\n\n\nBlock:\n\n\n\n\n\n\nMedium\n\n\n\n\nChange the default speed to 60 (\nDefault\n).\n\n\nBlock:\n\n\n\n\n\n\nSlow\n\n\n\n\nChange the default speed to 20.\n\n\nBlock:\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Basic Move Robot", 
            "title": "Basic Move Robot"
        }, 
        {
            "location": "/Basic_Move-Robot/#basic-move-robot-control", 
            "text": "The Move toolbox contains blocks to drive the robot forward and backward. There are also basic speed controls included in this toolbox.  List of available blocks:      Forward  Backward  Fast  Medium  Slow", 
            "title": "Basic Move Robot Control"
        }, 
        {
            "location": "/Basic_Move-Robot/#motor-selection-blocks-reminder", 
            "text": "To set the software to provide the correct speed values for straight line and cured motion, the program bust being with a Motor Selection Block.    Robot Kits may be supplied with two different motors which have different characteristics.  Each program must have a motor selection block to configure the program for the motor type.  The wheels are the easiest way to tell which motors your robot has.  To select the proper motor type, add one of these two blocks based on the color of your wheels.  The Motor Selection Block should be placed immediately after the Start Block.  These blocks can be found in the  Fusion Control  toolbox.", 
            "title": "Motor Selection Blocks - Reminder"
        }, 
        {
            "location": "/Basic_Move-Robot/#blocks", 
            "text": "", 
            "title": "Blocks:"
        }, 
        {
            "location": "/Basic_Move-Robot/#forward", 
            "text": "Drive forward for 1 second then stop.", 
            "title": "Forward"
        }, 
        {
            "location": "/Basic_Move-Robot/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Move-Robot/#backward", 
            "text": "Drive reverse for 1 second then stop.", 
            "title": "Backward"
        }, 
        {
            "location": "/Basic_Move-Robot/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Move-Robot/#fast", 
            "text": "Change the default speed to 80.", 
            "title": "Fast"
        }, 
        {
            "location": "/Basic_Move-Robot/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Move-Robot/#medium", 
            "text": "Change the default speed to 60 ( Default ).", 
            "title": "Medium"
        }, 
        {
            "location": "/Basic_Move-Robot/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Move-Robot/#slow", 
            "text": "Change the default speed to 20.", 
            "title": "Slow"
        }, 
        {
            "location": "/Basic_Move-Robot/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Move-Robot/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Basic Move Robot", 
            "title": "Questions?"
        }, 
        {
            "location": "/Basic_Rotate-Robot/", 
            "text": "Basic Rotate Robot Control\n\n\n\n\nThe Rotate toolbox contains blocks to rotate right and left at a variety of angles.\n\n\nList of available blocks:\n  \n\n\n\n\nRotate Right 45\u00b0\n\n\nRotate Right 90\u00b0\n\n\nRotate Right 180\u00b0\n\n\nRotate Left 45\u00b0\n\n\nRotate Left 90\u00b0\n\n\nRotate Left 180\u00b0\n\n\n\n\nMotor Selection Blocks - Reminder\n\n\n\n\nTo set the software to provide the correct speed values for straight line and cured motion, the program bust being with a Motor Selection Block.  \n\n\nRobot Kits may be supplied with two different motors which have different characteristics.  Each program must have a motor selection block to configure the program for the motor type.\n\n\nThe wheels are the easiest way to tell which motors your robot has.  To select the proper motor type, add one of these two blocks based on the color of your wheels.  The Motor Selection Block should be placed immediately after the Start Block.\n\n\nThese blocks can be found in the \nFusion Control\n toolbox.  \n\n\nBlocks:\n\n\n \n\n\n\n\n\n\nRotate Right 45\u00b0\n\n\n\n\nRotates the robot to the right (clockwise) at an angle of 45\u00b0.\n\n\nBlock:\n\n\n\n\n\n\nRotate Right 90\u00b0\n\n\n\n\nRotates the robot to the right (clockwise) at an angle of 90\u00b0.\n\n\nBlock:\n\n\n\n\n\n\nRotate Right 180\u00b0\n\n\n\n\nRotates the robot to the right (clockwise) at an angle of 180\u00b0.\n\n\nBlock:\n\n\n\n\n\n\nRotate Left 45\u00b0\n\n\n\n\nRotates the robot to the left (counter-clockwise) at an angle of 45\u00b0.\n\n\nBlock:\n\n\n\n\n\n\nRotate Left 90\u00b0\n\n\n\n\nRotates the robot to the left (counter-clockwise) at an angle of 90\u00b0.\n\n\nBlock:\n\n\n\n\n\n\nRotate Left 180\u00b0\n\n\n\n\nRotates the robot to the left (counter-clockwise) at an angle of 180\u00b0.\n\n\nBlock:\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Basic Rotate Robot", 
            "title": "Basic Rotate Robot"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#basic-rotate-robot-control", 
            "text": "The Rotate toolbox contains blocks to rotate right and left at a variety of angles.  List of available blocks:      Rotate Right 45\u00b0  Rotate Right 90\u00b0  Rotate Right 180\u00b0  Rotate Left 45\u00b0  Rotate Left 90\u00b0  Rotate Left 180\u00b0", 
            "title": "Basic Rotate Robot Control"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#motor-selection-blocks-reminder", 
            "text": "To set the software to provide the correct speed values for straight line and cured motion, the program bust being with a Motor Selection Block.    Robot Kits may be supplied with two different motors which have different characteristics.  Each program must have a motor selection block to configure the program for the motor type.  The wheels are the easiest way to tell which motors your robot has.  To select the proper motor type, add one of these two blocks based on the color of your wheels.  The Motor Selection Block should be placed immediately after the Start Block.  These blocks can be found in the  Fusion Control  toolbox.", 
            "title": "Motor Selection Blocks - Reminder"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#blocks", 
            "text": "", 
            "title": "Blocks:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#rotate-right-45", 
            "text": "Rotates the robot to the right (clockwise) at an angle of 45\u00b0.", 
            "title": "Rotate Right 45\u00b0"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#rotate-right-90", 
            "text": "Rotates the robot to the right (clockwise) at an angle of 90\u00b0.", 
            "title": "Rotate Right 90\u00b0"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#rotate-right-180", 
            "text": "Rotates the robot to the right (clockwise) at an angle of 180\u00b0.", 
            "title": "Rotate Right 180\u00b0"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#rotate-left-45", 
            "text": "Rotates the robot to the left (counter-clockwise) at an angle of 45\u00b0.", 
            "title": "Rotate Left 45\u00b0"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#rotate-left-90", 
            "text": "Rotates the robot to the left (counter-clockwise) at an angle of 90\u00b0.", 
            "title": "Rotate Left 90\u00b0"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#rotate-left-180", 
            "text": "Rotates the robot to the left (counter-clockwise) at an angle of 180\u00b0.", 
            "title": "Rotate Left 180\u00b0"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#block_5", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Basic_Rotate-Robot/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Basic Rotate Robot", 
            "title": "Questions?"
        }, 
        {
            "location": "/Int_Fusion-Control/", 
            "text": "Intermediate Fusion Control\n\n\n\n\nThe Intermediate Fusion Control toolbox comes with the necessary Start, LED and End blocks.\n\n\nFusion Driver Python Library Information\n\n\nList of available blocks:\n  \n\n\n\n\nStart Block\n\n\nFusion LEDs\n\n\nComment\n\n\nEnd Program\n\n\n\n\nStart Block\n\n\n\n\nInitializes the Fusion Robot at the start of every program. This block must be used in every Blockly program. By default the Start block is included in the programming environment. \n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\n\n\n\n\n\n\n\nLED\n\n\n\n\nControl the on-board Yellow and Blue LEDs. The LEDs can be either \nON\n or \nOFF\n.  \n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nf.setLED(f.YELLOW, 1)\n\n\n\n\n\n\n\nComment\n\n\n\n\nInserts inline comments into the program. This helps to label sections making it easier to find blocks of code.\n\n\n\n\nIn Python a comment is made starting with \n#\n.\n\n\nAccepts ASCII characters.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\n#\n\n\n\n\n\nExample:\n\n\n\n\n\n\n# This is the first comment.\n# This is my second comment.\n# This is my last comment.\n\n\n\n\n\n\n\nEnd Program\n\n\n\n\nStop the current program running.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nexit()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Intermediate Fusion Control", 
            "title": "Intermediate Fusion Control"
        }, 
        {
            "location": "/Int_Fusion-Control/#intermediate-fusion-control", 
            "text": "The Intermediate Fusion Control toolbox comes with the necessary Start, LED and End blocks.  Fusion Driver Python Library Information  List of available blocks:      Start Block  Fusion LEDs  Comment  End Program", 
            "title": "Intermediate Fusion Control"
        }, 
        {
            "location": "/Int_Fusion-Control/#start-block", 
            "text": "Initializes the Fusion Robot at the start of every program. This block must be used in every Blockly program. By default the Start block is included in the programming environment.", 
            "title": "Start Block"
        }, 
        {
            "location": "/Int_Fusion-Control/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Fusion-Control/#code-produced", 
            "text": "import Fusion\nf = Fusion.driver()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Fusion-Control/#led", 
            "text": "Control the on-board Yellow and Blue LEDs. The LEDs can be either  ON  or  OFF .", 
            "title": "LED"
        }, 
        {
            "location": "/Int_Fusion-Control/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Fusion-Control/#code-produced_1", 
            "text": "f.setLED(f.YELLOW, 1)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Fusion-Control/#comment", 
            "text": "Inserts inline comments into the program. This helps to label sections making it easier to find blocks of code.   In Python a comment is made starting with  # .  Accepts ASCII characters.", 
            "title": "Comment"
        }, 
        {
            "location": "/Int_Fusion-Control/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Fusion-Control/#code-produced_2", 
            "text": "#", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Fusion-Control/#example", 
            "text": "# This is the first comment.\n# This is my second comment.\n# This is my last comment.", 
            "title": "Example:"
        }, 
        {
            "location": "/Int_Fusion-Control/#end-program", 
            "text": "Stop the current program running.", 
            "title": "End Program"
        }, 
        {
            "location": "/Int_Fusion-Control/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Fusion-Control/#code-produced_3", 
            "text": "exit()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Fusion-Control/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Intermediate Fusion Control", 
            "title": "Questions?"
        }, 
        {
            "location": "/Int_Motors/", 
            "text": "Motor Control\n\n\n\n\nThe Motor toolbox contains blocks for motor control.\n\n\n\n\nConnect via motor port \nM0\n or \nM1\n. Connection is bidirectional.\n\n\nMotor Speed ranges from \n-100\n to \n100\n.\n\n\nSpeed of \n0\n is a complete stop.\n\n\n\n\nMotor Python Library Information\n\n\nList of available blocks:\n  \n\n\n\n\nMotor Speed\n\n\nDrive at Speed\n\n\nDrive at Speed for Time\n\n\nRotate at Speed for Time\n\n\n\n\nMotor Speed\n\n\n\n\nApply power to a single motor port from \n-100\n to \n100\n.  \n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nf.motorSpeed(f.M0, 50)\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\nf.motorSpeed(f.M0, 100)\nf.motorSpeed(f.M1, 100)\ntime.sleep(1)\nf.motorSpeed(f.M0, -100)\nf.motorSpeed(f.M1, -100)\ntime.sleep(1)\nf.motorSpeed(f.M0, 0)\nf.motorSpeed(f.M1, 0)\n\n\n\n\n\n\n\n\n\nDrive at Speed\n\n\n\n\nDrive both motor ports at a set speed from \n-100\n to \n100\n.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nf.motorSpeed(f.M0+f.M1, 100)\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\nf.motorSpeed(f.M0+f.M1, 100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, -100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)\n\n\n\n\n\n\n\n\n\nDrive at Speed for Time\n\n\n\n\nDrive both motor ports at a set speed from \n-100\n to \n100\n for a set amount of time in seconds.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nImports:\n\n\n\n\nimport time\n\n\n\n\n\nCode:\n\n\n\n\n# Drive forwards with 80% power for 15 seconds\nf.motorSpeed(f.M0+f.M1, 80)\ntime.sleep(15)\nf.motorSpeed(f.M0+f.M1, 0)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\n# Drive forwards with 100% power for 1 seconds\nf.motorSpeed(f.M0+f.M1, 100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)\n# Drive backwards with -100% power for 1 seconds\nf.motorSpeed(f.M0+f.M1, -100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)\n\n\n\n\n\n\n\n\n\nRotate at Speed for Time\n\n\n\n\nRotate the robot either \nLeft\n or \nRight\n at a set speed from \n-100\n to \n100\n for a set amount of time in seconds. This results in one motor driving forward and the other motor driving backwards at the same speed.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nImports:\n\n\n\n\nimport time\n\n\n\n\n\nCode:\n\n\n\n\n# Turn Left with 50% power for 1.5 seconds\nf.motorSpeed(f.M1, -50)\nf.motorSpeed(f.M0, 50)\ntime.sleep(1.5)\nf.motorSpeed(f.M0+f.M1, 0)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\n# Turn Right with 70% power for 0.5 seconds\nf.motorSpeed(f.M1, 70);\nf.motorSpeed(f.M0, -70);\ntime.sleep(0.5)\nf.motorSpeed(f.M0+f.M1, 0)\n# Turn Left with 70% power for 1 seconds\nf.motorSpeed(f.M1, -70)\nf.motorSpeed(f.M0, 70)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)\n# Turn Right with 70% power for 2.5 seconds\nf.motorSpeed(f.M1, 70);\nf.motorSpeed(f.M0, -70);\ntime.sleep(2.5)\nf.motorSpeed(f.M0+f.M1, 0)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Intermediate Motor Control", 
            "title": "Motors"
        }, 
        {
            "location": "/Int_Motors/#motor-control", 
            "text": "The Motor toolbox contains blocks for motor control.   Connect via motor port  M0  or  M1 . Connection is bidirectional.  Motor Speed ranges from  -100  to  100 .  Speed of  0  is a complete stop.   Motor Python Library Information  List of available blocks:      Motor Speed  Drive at Speed  Drive at Speed for Time  Rotate at Speed for Time", 
            "title": "Motor Control"
        }, 
        {
            "location": "/Int_Motors/#motor-speed", 
            "text": "Apply power to a single motor port from  -100  to  100 .", 
            "title": "Motor Speed"
        }, 
        {
            "location": "/Int_Motors/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Motors/#code-produced", 
            "text": "f.motorSpeed(f.M0, 50)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Motors/#example", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\nf.motorSpeed(f.M0, 100)\nf.motorSpeed(f.M1, 100)\ntime.sleep(1)\nf.motorSpeed(f.M0, -100)\nf.motorSpeed(f.M1, -100)\ntime.sleep(1)\nf.motorSpeed(f.M0, 0)\nf.motorSpeed(f.M1, 0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Int_Motors/#drive-at-speed", 
            "text": "Drive both motor ports at a set speed from  -100  to  100 .", 
            "title": "Drive at Speed"
        }, 
        {
            "location": "/Int_Motors/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Motors/#code-produced_1", 
            "text": "f.motorSpeed(f.M0+f.M1, 100)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Motors/#example_1", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\nf.motorSpeed(f.M0+f.M1, 100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, -100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Int_Motors/#drive-at-speed-for-time", 
            "text": "Drive both motor ports at a set speed from  -100  to  100  for a set amount of time in seconds.", 
            "title": "Drive at Speed for Time"
        }, 
        {
            "location": "/Int_Motors/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Motors/#code-produced_2", 
            "text": "Imports:   import time   Code:   # Drive forwards with 80% power for 15 seconds\nf.motorSpeed(f.M0+f.M1, 80)\ntime.sleep(15)\nf.motorSpeed(f.M0+f.M1, 0)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Motors/#example_2", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\n# Drive forwards with 100% power for 1 seconds\nf.motorSpeed(f.M0+f.M1, 100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)\n# Drive backwards with -100% power for 1 seconds\nf.motorSpeed(f.M0+f.M1, -100)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Int_Motors/#rotate-at-speed-for-time", 
            "text": "Rotate the robot either  Left  or  Right  at a set speed from  -100  to  100  for a set amount of time in seconds. This results in one motor driving forward and the other motor driving backwards at the same speed.", 
            "title": "Rotate at Speed for Time"
        }, 
        {
            "location": "/Int_Motors/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Motors/#code-produced_3", 
            "text": "Imports:   import time   Code:   # Turn Left with 50% power for 1.5 seconds\nf.motorSpeed(f.M1, -50)\nf.motorSpeed(f.M0, 50)\ntime.sleep(1.5)\nf.motorSpeed(f.M0+f.M1, 0)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Motors/#example_3", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\n# Turn Right with 70% power for 0.5 seconds\nf.motorSpeed(f.M1, 70);\nf.motorSpeed(f.M0, -70);\ntime.sleep(0.5)\nf.motorSpeed(f.M0+f.M1, 0)\n# Turn Left with 70% power for 1 seconds\nf.motorSpeed(f.M1, -70)\nf.motorSpeed(f.M0, 70)\ntime.sleep(1)\nf.motorSpeed(f.M0+f.M1, 0)\n# Turn Right with 70% power for 2.5 seconds\nf.motorSpeed(f.M1, 70);\nf.motorSpeed(f.M0, -70);\ntime.sleep(2.5)\nf.motorSpeed(f.M0+f.M1, 0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Int_Motors/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Intermediate Motor Control", 
            "title": "Questions?"
        }, 
        {
            "location": "/Int_Servos/", 
            "text": "Servo Control\n\n\n\n\nThe Servo toolbox contains blocks for controlling the four servo ports.\n\n\n\n\nConnect via servo port \nS0\n to \nS3\n.\n\n\nServo Target ranges from \n0\n to \n255\n.\n\n\nValue of \n128\n is the center of rotation and the starting position of a servo.\n\n\n\n\nServo Python Library Information\n\n\nList of available blocks:\n  \n\n\n\n\nServo Target\n\n\n\n\nServo Target\n\n\n\n\nSet the servo to a set target position from \n0\n to \n255\n. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nf.servoEnable(f.S0, 1)\n\n\n\n\n\nCode:\n\n\n\n\nf.servoTarget(f.S0, 128)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\n\n\n\n\n\n\n\n\n\nf = Fusion.driver()\nf.servoEnable(f.S0, 1)\nf.servoEnable(f.S2, 1)\nf.servoTarget(f.S0, 10)\nf.servoTarget(f.S2, 245)\ntime.sleep(1)\n\nf.servoTarget(f.S0, 245)\nf.servoTarget(f.S2, 10)\ntime.sleep(1)\n\nf.servoTarget(f.S0, 128)\nf.servoTarget(f.S2, 128)\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Intermediate Servo Control", 
            "title": "Servos"
        }, 
        {
            "location": "/Int_Servos/#servo-control", 
            "text": "The Servo toolbox contains blocks for controlling the four servo ports.   Connect via servo port  S0  to  S3 .  Servo Target ranges from  0  to  255 .  Value of  128  is the center of rotation and the starting position of a servo.   Servo Python Library Information  List of available blocks:      Servo Target", 
            "title": "Servo Control"
        }, 
        {
            "location": "/Int_Servos/#servo-target", 
            "text": "Set the servo to a set target position from  0  to  255 . Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.", 
            "title": "Servo Target"
        }, 
        {
            "location": "/Int_Servos/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Int_Servos/#code-produced", 
            "text": "Setup:   f.servoEnable(f.S0, 1)   Code:   f.servoTarget(f.S0, 128)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Int_Servos/#example", 
            "text": "Code:   import Fusion\nimport time     f = Fusion.driver()\nf.servoEnable(f.S0, 1)\nf.servoEnable(f.S2, 1)\nf.servoTarget(f.S0, 10)\nf.servoTarget(f.S2, 245)\ntime.sleep(1)\n\nf.servoTarget(f.S0, 245)\nf.servoTarget(f.S2, 10)\ntime.sleep(1)\n\nf.servoTarget(f.S0, 128)\nf.servoTarget(f.S2, 128)", 
            "title": "Example:"
        }, 
        {
            "location": "/Int_Servos/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Intermediate Servo Control", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_usbGamepad/", 
            "text": "USB Gamepad\n\n\n\n\nThis library allows you to connect a wired or wireless USB gamepad to the Fusion for control.\n\n\n\n\nUSB Gamepad Python Library Information\n  \n\n\nUSB Gamepad Button Mapping\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nRead Axis\n\n\nRead Axis Float\n\n\nAxis Mixer\n\n\nRead Button\n\n\nRead Hat\n\n\n\n\nRead Axis\n\n\n\n\nRead the selected axis from the USB Gamepad as an integer. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability.\n\n\nInvert\n will flip the positive/negative direction of the axis.\n\nRead Axis returns a value between -100 and 100.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\n\n\n\n\n\nCode:\n\n\n\n\nusbg.readAxis(0, False)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\ncode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_0_axis = None\nusbg = Fusion.usbGamepad()\nmy_0_axis = usbg.readAxis(0, False)\n\n\n\n\n\n\n\n\n\nRead Axis Float\n\n\n\n\nRead the selected axis from the USB Gamepad as a floating point number. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability.\n\n\nInvert\n will flip the positive/negative direction of the axis.\n\nRead Axis returns a value between -1.00 and 1.00.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\n\n\n\n\n\nCode:\n\n\n\n\nusbg.readAxisFloat(0, False)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_0_axis_float = None\nusbg = Fusion.usbGamepad()\nmy_0_axis_float = usbg.readAxisFloat(0, False)\n\n\n\n\n\n\n\n\n\nAxis Mixer\n\n\n\n\nCombines 2 joystick values to create a proportional tank drive. The \nX-Axis\n is the joystick value for turning left or right. The \nY-Axis\n is the joystick value for driving forward and backward. The \nX-Invert\n and \nY-Invert\n can flip the value of a joystick between positive and negative. Therefore if the robot drives or turns in the opposite direction of the joystick, invert the appropriate axis.\n\nAxis Mixer returns (M0, M1) where M0 and M1 range from -100 to 100.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\n\n\n\n\n\nCode:\n\n\n\n\nusbg.axisMixer()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nMotorPowers = None\nusbg = Fusion.usbGamepad()\nwhile True:\n    MotorPowers = usbg.mixer(0, 1, False, 1,)\n    f.motorSpeed(f.M0, MotorPowers[0])\n    f.motorSpeed(f.M1, MotorPowers[1])\n\n\n\n\n\n\n\n\n\nRead Button\n\n\n\n\nRead the selected button from the USB Gamepad. The available number of buttons is dependent on the USB Gamepad. Refer to the diagrams for availability. \nRead Button returns a value that is 0 when the button is not being pressed and a 1 when the button is being pressed.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\n\n\n\n\n\nCode:\n\n\n\n\nusbg.readButton()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_0_button = None\nusbg = Fusion.usbGamepad()\nmy_0_button = usbg.readButton(0)\n\n\n\n\n\n\n\n\n\nRead Hat\n\n\n\n\nRead the hat of the USB Gamepad. The hat may also be called the directional pad (D-pad). The hat can return a possibility of 9 possible combinations of values.\nRead Hat returns (X, Y) where X and Y can be equal to -1, 0 or 1.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\n\n\n\n\n\nCode:\n\n\n\n\nusbg.readHat()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_hat = None\nusbg = Fusion.usbGamepad()\nmy_hat = usbg.readHat()\nprint(my_hat[0])\nprint(my_hat[1])\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly USB Gamepad\n\n\n\n\n\n\n\n\n\n\n\n\n\nUSB Gamepads\n\n\n\n\nLogitech F310 Gamepad\n\n\n\n\nXbox 360 Game Controller", 
            "title": "USB Gamepad"
        }, 
        {
            "location": "/Blk_usbGamepad/#usb-gamepad", 
            "text": "This library allows you to connect a wired or wireless USB gamepad to the Fusion for control.   USB Gamepad Python Library Information     USB Gamepad Button Mapping   List of available blocks:      Read Axis  Read Axis Float  Axis Mixer  Read Button  Read Hat", 
            "title": "USB Gamepad"
        }, 
        {
            "location": "/Blk_usbGamepad/#read-axis", 
            "text": "Read the selected axis from the USB Gamepad as an integer. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability.  Invert  will flip the positive/negative direction of the axis. \nRead Axis returns a value between -100 and 100.", 
            "title": "Read Axis"
        }, 
        {
            "location": "/Blk_usbGamepad/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_usbGamepad/#code-produced", 
            "text": "Setup:   import Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()   Code:   usbg.readAxis(0, False)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_usbGamepad/#example", 
            "text": "code:   import Fusion\nf = Fusion.driver()\nmy_0_axis = None\nusbg = Fusion.usbGamepad()\nmy_0_axis = usbg.readAxis(0, False)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_usbGamepad/#read-axis-float", 
            "text": "Read the selected axis from the USB Gamepad as a floating point number. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability.  Invert  will flip the positive/negative direction of the axis. \nRead Axis returns a value between -1.00 and 1.00.", 
            "title": "Read Axis Float"
        }, 
        {
            "location": "/Blk_usbGamepad/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_usbGamepad/#code-produced_1", 
            "text": "Setup:   import Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()   Code:   usbg.readAxisFloat(0, False)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_usbGamepad/#example_1", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_0_axis_float = None\nusbg = Fusion.usbGamepad()\nmy_0_axis_float = usbg.readAxisFloat(0, False)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_usbGamepad/#axis-mixer", 
            "text": "Combines 2 joystick values to create a proportional tank drive. The  X-Axis  is the joystick value for turning left or right. The  Y-Axis  is the joystick value for driving forward and backward. The  X-Invert  and  Y-Invert  can flip the value of a joystick between positive and negative. Therefore if the robot drives or turns in the opposite direction of the joystick, invert the appropriate axis. \nAxis Mixer returns (M0, M1) where M0 and M1 range from -100 to 100.", 
            "title": "Axis Mixer"
        }, 
        {
            "location": "/Blk_usbGamepad/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_usbGamepad/#code-produced_2", 
            "text": "Setup:   import Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()   Code:   usbg.axisMixer()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_usbGamepad/#example_2", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nMotorPowers = None\nusbg = Fusion.usbGamepad()\nwhile True:\n    MotorPowers = usbg.mixer(0, 1, False, 1,)\n    f.motorSpeed(f.M0, MotorPowers[0])\n    f.motorSpeed(f.M1, MotorPowers[1])", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_usbGamepad/#read-button", 
            "text": "Read the selected button from the USB Gamepad. The available number of buttons is dependent on the USB Gamepad. Refer to the diagrams for availability. \nRead Button returns a value that is 0 when the button is not being pressed and a 1 when the button is being pressed.", 
            "title": "Read Button"
        }, 
        {
            "location": "/Blk_usbGamepad/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_usbGamepad/#code-produced_3", 
            "text": "Setup:   import Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()   Code:   usbg.readButton()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_usbGamepad/#example_3", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_0_button = None\nusbg = Fusion.usbGamepad()\nmy_0_button = usbg.readButton(0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_usbGamepad/#read-hat", 
            "text": "Read the hat of the USB Gamepad. The hat may also be called the directional pad (D-pad). The hat can return a possibility of 9 possible combinations of values.\nRead Hat returns (X, Y) where X and Y can be equal to -1, 0 or 1.", 
            "title": "Read Hat"
        }, 
        {
            "location": "/Blk_usbGamepad/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_usbGamepad/#code-produced_4", 
            "text": "Setup:   import Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()   Code:   usbg.readHat()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_usbGamepad/#example_4", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_hat = None\nusbg = Fusion.usbGamepad()\nmy_hat = usbg.readHat()\nprint(my_hat[0])\nprint(my_hat[1])", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_usbGamepad/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly USB Gamepad", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_usbGamepad/#usb-gamepads", 
            "text": "", 
            "title": "USB Gamepads"
        }, 
        {
            "location": "/Blk_usbGamepad/#logitech-f310-gamepad", 
            "text": "", 
            "title": "Logitech F310 Gamepad"
        }, 
        {
            "location": "/Blk_usbGamepad/#xbox-360-game-controller", 
            "text": "", 
            "title": "Xbox 360 Game Controller"
        }, 
        {
            "location": "/Blk_VirtualGamepad/", 
            "text": "Virtual Gamepad\n\n\n\n\nThis library allows you to display and use a virtual gamepad right on your touch screen device to control the Fusion. The Virtual Gamepad comes with 2 joysticks and 4 buttons that are controlled using the functions below.  \n\n\nOnce the code is written, start the python program and click the Virtual Gamepad button on the toolbar to open the window. The Virtual Gamepad window will open on the current IP address on port 5000 (Default: \nmy.bot:5000\n or \n192.168.50.1:5000\n) in a new tab.\n\n\n\n\nVirtual Gamepad Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nRead Joystick\n\n\nRead Button\n\n\nTelemetry\n\n\nCamera\n\n\n\n\n\n\nRead Joystick\n\n\n\n\nRead the X-axis and Y-axis of the \nLeft\n or \nRight\n joystick. The values range from -100 to 100 on each axis.\n\nSetting \nMixer\n to True will combine the X-axis and Y-axis values to allow for tank style driving. \n\nThe \nX-Invert\n and \nY-Invert\n will flip the positive/negative direction of the joystick.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n\n\n\n\n\nCode:\n\n\n\n\nv.leftJoystick(False, False, False)\nor\nv.rightJoystick(False, False, False)\n\n\n\n\n\n\n\nExample:\n\n\n  \n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport VirtualGamepad\nf = Fusion.driver()\nv = VirtualGamepad.service()\nleft = None\nright = None\nwhile True:\n    left = v.leftJoystick(False, False, False)\n    right = v.rightJoystick(False, False, False)\n    f.motorSpeed(f.M0, right[1])\n    f.motorSpeed(f.M1, left[1])\n\n\n\n\n\n\n\n\n\nRead Button\n\n\n\n\n\n\nRead a button from the Virtual Gamepad. The button returns a \n1\n when it is pressed and a \n0\n when it is not pressed.\n\nThere are 4 available buttons: \n\n\n\n\nA\n  \n\n\nB\n  \n\n\nX\n  \n\n\nY\n\n\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n\n\n\n\n\nCode:\n\n\n\n\nv.readButton('A')\n\n\n\n\n\n\n\n\n\nTelemetry\n\n\n\n\nPrint valuable data to the Virtual Gamepad screen. This is very useful when wanting to read the return values from sensors or the Virtual Gamepad functions.\n\nThe \nLine\n parameter refers to which line of the Virtual Gamepad screen that data will print to. \nValue\n is the data you want to print to the screen. You can print plain text or the return of a sensor or joystick block.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n\n\n\n\n\nCode:\n\n\n\n\nv.telemetry(0, 'abc')\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport VirtualGamepad\nf = Fusion.driver()\nv = VirtualGamepad.service()\nwhile True:\n    v.telemetry(0, str(str('left joystick = ') + str(v.leftJoystick(False, False, False))))\n    v.telemetry(1, str(str('right joystick = ') + str(v.rightJoystick(False, False, False))))\n    v.telemetry(2, str(str('Btn A = ') + str(v.readButton('A'))))\n    v.telemetry(3, str(str('Btn B = ') + str(v.readButton('B'))))\n    v.telemetry(4, str(str('Btn X = ') + str(v.readButton('X'))))\n    v.telemetry(5, str(str('Btn Y = ') + str(v.readButton('Y'))))\n\n\n\n\n\n\n\n\n\nCamera\n\n\n\n\nAdding this block will enable the use of a USB camera or PiCamera to live stream video back to the virtual gamepad background. A camera must be attached to the Fusion in order to use this block or an exception will occur when the drivers are initialized. This block can be added or removed to an existing program and is necessary only for camera feedback.\n\nThe \nResolution\n fields allow the user to change the default resolution of \n(320x240)\n to any defined value supported by their selected camera.\n\n\nFrames Per Second\n is the rate at which the live stream frames are displayed to screen. Default is \n10\nfps however can be increased depending on the camera abilities and WiFi connection strength.\n\n\nMode\n refers to the type of camera that is connected to the device. The default mode is \n'YUV'\n however \n'MJPG'\n and \n'PICAM'\n are also supported. Certain cameras may work better on one mode than the other and the user should refer to the manufacturer documentation or support to determine what modes are supported.  \n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nAdding the camera block modifies the VirtualGamepad setup as shown:\n\n\n\n\nChanges this:\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n\n\n\nTo this:\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service(True, (320,240), 10, 'YUV')\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport VirtualGamepad\nf = Fusion.driver()\nv = VirtualGamepad.service(True, (320,240), 10, 'YUV')\nleft = None\nwhile True:\n    left = v.leftJoystick(True, False, False)\n    f.motorSpeed(f.M0, left[0])\n    f.motorSpeed(f.M1, left[1])\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Virtual Gamepad", 
            "title": "Virtual Gamepad"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#virtual-gamepad", 
            "text": "This library allows you to display and use a virtual gamepad right on your touch screen device to control the Fusion. The Virtual Gamepad comes with 2 joysticks and 4 buttons that are controlled using the functions below.    Once the code is written, start the python program and click the Virtual Gamepad button on the toolbar to open the window. The Virtual Gamepad window will open on the current IP address on port 5000 (Default:  my.bot:5000  or  192.168.50.1:5000 ) in a new tab.   Virtual Gamepad Python Library Information      List of available blocks:      Read Joystick  Read Button  Telemetry  Camera", 
            "title": "Virtual Gamepad"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#read-joystick", 
            "text": "Read the X-axis and Y-axis of the  Left  or  Right  joystick. The values range from -100 to 100 on each axis. \nSetting  Mixer  to True will combine the X-axis and Y-axis values to allow for tank style driving.  \nThe  X-Invert  and  Y-Invert  will flip the positive/negative direction of the joystick.", 
            "title": "Read Joystick"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#code-produced", 
            "text": "Setup:   import VirtualGamepad\nv = VirtualGamepad.service()   Code:   v.leftJoystick(False, False, False)\nor\nv.rightJoystick(False, False, False)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#example", 
            "text": "Code:   import Fusion\nimport VirtualGamepad\nf = Fusion.driver()\nv = VirtualGamepad.service()\nleft = None\nright = None\nwhile True:\n    left = v.leftJoystick(False, False, False)\n    right = v.rightJoystick(False, False, False)\n    f.motorSpeed(f.M0, right[1])\n    f.motorSpeed(f.M1, left[1])", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#read-button", 
            "text": "Read a button from the Virtual Gamepad. The button returns a  1  when it is pressed and a  0  when it is not pressed. \nThere are 4 available buttons:    A     B     X     Y", 
            "title": "Read Button"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#code-produced_1", 
            "text": "Setup:   import VirtualGamepad\nv = VirtualGamepad.service()   Code:   v.readButton('A')", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#telemetry", 
            "text": "Print valuable data to the Virtual Gamepad screen. This is very useful when wanting to read the return values from sensors or the Virtual Gamepad functions. \nThe  Line  parameter refers to which line of the Virtual Gamepad screen that data will print to.  Value  is the data you want to print to the screen. You can print plain text or the return of a sensor or joystick block.", 
            "title": "Telemetry"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#code-produced_2", 
            "text": "Setup:   import VirtualGamepad\nv = VirtualGamepad.service()   Code:   v.telemetry(0, 'abc')", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#example_1", 
            "text": "Code:   import Fusion\nimport VirtualGamepad\nf = Fusion.driver()\nv = VirtualGamepad.service()\nwhile True:\n    v.telemetry(0, str(str('left joystick = ') + str(v.leftJoystick(False, False, False))))\n    v.telemetry(1, str(str('right joystick = ') + str(v.rightJoystick(False, False, False))))\n    v.telemetry(2, str(str('Btn A = ') + str(v.readButton('A'))))\n    v.telemetry(3, str(str('Btn B = ') + str(v.readButton('B'))))\n    v.telemetry(4, str(str('Btn X = ') + str(v.readButton('X'))))\n    v.telemetry(5, str(str('Btn Y = ') + str(v.readButton('Y'))))", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#camera", 
            "text": "Adding this block will enable the use of a USB camera or PiCamera to live stream video back to the virtual gamepad background. A camera must be attached to the Fusion in order to use this block or an exception will occur when the drivers are initialized. This block can be added or removed to an existing program and is necessary only for camera feedback. \nThe  Resolution  fields allow the user to change the default resolution of  (320x240)  to any defined value supported by their selected camera.  Frames Per Second  is the rate at which the live stream frames are displayed to screen. Default is  10 fps however can be increased depending on the camera abilities and WiFi connection strength.  Mode  refers to the type of camera that is connected to the device. The default mode is  'YUV'  however  'MJPG'  and  'PICAM'  are also supported. Certain cameras may work better on one mode than the other and the user should refer to the manufacturer documentation or support to determine what modes are supported.", 
            "title": "Camera"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#code-produced_3", 
            "text": "Adding the camera block modifies the VirtualGamepad setup as shown:   Changes this:  import VirtualGamepad\nv = VirtualGamepad.service()  To this:  import VirtualGamepad\nv = VirtualGamepad.service(True, (320,240), 10, 'YUV')", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#example_2", 
            "text": "Code:   import Fusion\nimport VirtualGamepad\nf = Fusion.driver()\nv = VirtualGamepad.service(True, (320,240), 10, 'YUV')\nleft = None\nwhile True:\n    left = v.leftJoystick(True, False, False)\n    f.motorSpeed(f.M0, left[0])\n    f.motorSpeed(f.M1, left[1])", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_VirtualGamepad/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Virtual Gamepad", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Analog_Digital/", 
            "text": "Generic Analog and Digital Sensors\n\n\n\n\nThe Analog and Digital Sensors toolbox includes blocks for analog read and digital read/write control.\n\n\n\n\nConnect analog sensors via analog port \nA0\n - \nA7\n.\n\n\nConnect digital sensors via digital port \nD0\n - \nD7\n.  \n\n\n\n\n\n\nFusion Driver Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nAnalog Read\n\n\nDigital Read\n\n\nDigital Write\n\n\n\n\nAnalog - Read\n\n\n\n\nRead from the sensor connected to the corresponding analog port.\n\n\n\n\nThe returned reading ranges from \n0\n and \n1023\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nanalog_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\nCode:\n\n\n\n\nanalog_A0.read()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_analog_value = None\nanalog_A0 = Fusion.analog(f, f.A0)\nmy_analog_value = analog_A0.read()\n\n\n\n\n\n\n\n\n\nDigital - Read\n\n\n\n\nRead from the sensor connected to the corresponding digital port.\n\n\n\n\nThe returned reading is either a \n0\n or \n1\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ndigital_D0 = Fusion.digital(f, f.D7)\n\n\n\n\n\nCode:\n\n\n\n\ndigital_D0.read()\n\n\n\n\n\n\n\n\n\nDigital - Write\n\n\n\n\nWrite to the device connected to the corresponding digital port.\n\n\n\n\nThe value written can be either a \n0\n or \n1\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ndigital_D0 = Fusion.digital(f, f.D0)\n\n\n\n\n\nCode:\n\n\n\n\ndigital_D0.write(0)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Analog/Digital", 
            "title": "Analog/Digital Sensors"
        }, 
        {
            "location": "/Blk_Analog_Digital/#generic-analog-and-digital-sensors", 
            "text": "The Analog and Digital Sensors toolbox includes blocks for analog read and digital read/write control.   Connect analog sensors via analog port  A0  -  A7 .  Connect digital sensors via digital port  D0  -  D7 .      Fusion Driver Python Library Information   List of available blocks:      Analog Read  Digital Read  Digital Write", 
            "title": "Generic Analog and Digital Sensors"
        }, 
        {
            "location": "/Blk_Analog_Digital/#analog-read", 
            "text": "Read from the sensor connected to the corresponding analog port.   The returned reading ranges from  0  and  1023 .", 
            "title": "Analog - Read"
        }, 
        {
            "location": "/Blk_Analog_Digital/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#code-produced", 
            "text": "Setup:   analog_A0 = Fusion.analog(f, f.A0)   Code:   analog_A0.read()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_analog_value = None\nanalog_A0 = Fusion.analog(f, f.A0)\nmy_analog_value = analog_A0.read()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#digital-read", 
            "text": "Read from the sensor connected to the corresponding digital port.   The returned reading is either a  0  or  1 .", 
            "title": "Digital - Read"
        }, 
        {
            "location": "/Blk_Analog_Digital/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#code-produced_1", 
            "text": "Setup:   digital_D0 = Fusion.digital(f, f.D7)   Code:   digital_D0.read()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#digital-write", 
            "text": "Write to the device connected to the corresponding digital port.   The value written can be either a  0  or  1 .", 
            "title": "Digital - Write"
        }, 
        {
            "location": "/Blk_Analog_Digital/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#code-produced_2", 
            "text": "Setup:   digital_D0 = Fusion.digital(f, f.D0)   Code:   digital_D0.write(0)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Analog_Digital/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Analog/Digital", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Compass/", 
            "text": "Compass (45-2003)\n\n\n\n\nThe Compass uses a magnetometer and an accelerometer to calculate heading data based on Earth\u2019s magnetic field. The compass can return the heading data, accelerometer data and magnetometer data to the user. Anything that generates a magnetic field must be moved away from the sensor like power cables, motor or magnetic material. This must happen because during calibration the sensor will add an offset to account for other magnetic sources in the area.\n\n\n\n\nConnect via any \nI2C\n port.\n\n\n\n\n\n\nCompass Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nGet Heading\n\n\nHard Iron Calibration\n\n\nTilt Up Calibration\n\n\nTilt Down Calibration\n\n\nAccelerometer Calibration\n\n\nGet Accelerometer Reading\n\n\nGet Magnetometer Reading\n\n\nScale Accelerometer\n\n\n\n\n\n\nGet Heading\n\n\n\n\nReturns the currently cardinal heading in degrees.\n\n\n\n\nThe returned reading is between \n0\n and \n359\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:  \n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.getHeading()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_compass_heading = None \ncompass = Fusion.compass(f)\nmy_compass_heading = compass.getHeading()\n\n\n\n\n\n\n\n\n\nHard Iron Calibration\n\n\n\n\nHard Iron Calibration (HIC) is a method of checking for magnets or an object generating a magnetic field around the sensor and generating an offset to account for the magnetic field. During HIC the sensor must be rotated 360\u00b0 in 5 seconds while keeping a constant pace. Try to start and stop the sensor pointing due North. \n\n\n\n\nRotate 360\u00b0 in 5 seconds while blue LED inside sensor is turned on.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.hardIronCalibration()\n\n\n\n\n\n\n\n\n\nTilt Up Calibration\n\n\n\n\nThis block calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 above the horizon during calibration.\n\n\n  \n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.tiltUp()\n\n\n\n\n\n\n\n\n\nTilt Down Calibration\n\n\n\n\nThis block calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 below the horizon during calibration.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.tiltDown()\n\n\n\n\n\n\n\n\n\nAccelerometer Calibration\n\n\n\n\nThis block will calibrate the \nX\n, \nY\n and \nZ\n values by zeroing them. The \nX\n and \nY\n calibration must be done with the sensor laying flat on the horizon. The \nZ\n must be calibrated with the sensor held vertical. Allow a minimum of 3 seconds for calibration of each step.\n\n\nPosition for \nX\n and \nY\n axis.\n\n\n\n\nPosition for \nZ\n axis.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.nullAccelerometer('X')\n\n\n\n\n\n\n\n\n\nGet Accelerometer Reading\n\n\n\n\nThis block returns the accelerometer values for the \nX\n, \nY\n and \nZ\n axis.\n\n\n\n\nThe returned reading is between \n-32,767\n and \n32,768\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.getAccelerometer()[0]\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\ncompass = Fusion.compass(f)\nprint('Lay the sensor flat on a surface for X and Y calibration')\ncompass.nullAccelerometer('X')\ncompass.nullAccelerometer('Y')\ntime.sleep(5)\nprint('Hold the sensor vertical with the wire pointing up')\ncompass.nullAccelerometer('Z')\nwhile True:\n    print(''.join([str(x) for x in ['X: ', compass.getAccelerometer()[0], '    Y: ', compass.getAccelerometer()[1], '    Z: ', compass.getAccelerometer()[2]]]))\n    time.sleep(0.1)\n\n\n\n\n\n\n\n\n\nGet Magnetometer Reading\n\n\n\n\nThis block returns the values of the magnetometer on the \nX\n, \nY\n and \nZ\n axis.\n\n\n\n\nThe returned reading is between \n0\n and \n1023\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.getMagnetometer()[0]\n\n\n\n\n\n\n\n\n\nScale Accelerometer\n\n\n\n\nThis block is called if the user wants to change the sensitivity of the accelerometer reading. First the sensor must be set vertical (Same position as \nZ\n calibration) and hold it there for the duration of the calibration. Once the sensor is in position the program may be ran. Once the program is completed, the scaling value will be updated within the Compass.\n\n\nPostion of sensor during scaling.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncompass = Fusion.compass(f)\n\n\n\n\n\nCode:\n\n\n\n\ncompass.scaleAccelerometer()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Compass", 
            "title": "Compass (45-2003)"
        }, 
        {
            "location": "/Blk_Compass/#compass-45-2003", 
            "text": "The Compass uses a magnetometer and an accelerometer to calculate heading data based on Earth\u2019s magnetic field. The compass can return the heading data, accelerometer data and magnetometer data to the user. Anything that generates a magnetic field must be moved away from the sensor like power cables, motor or magnetic material. This must happen because during calibration the sensor will add an offset to account for other magnetic sources in the area.   Connect via any  I2C  port.    Compass Python Library Information      List of available blocks:      Get Heading  Hard Iron Calibration  Tilt Up Calibration  Tilt Down Calibration  Accelerometer Calibration  Get Accelerometer Reading  Get Magnetometer Reading  Scale Accelerometer", 
            "title": "Compass (45-2003)"
        }, 
        {
            "location": "/Blk_Compass/#get-heading", 
            "text": "Returns the currently cardinal heading in degrees.   The returned reading is between  0  and  359 .", 
            "title": "Get Heading"
        }, 
        {
            "location": "/Blk_Compass/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced", 
            "text": "Setup:     compass = Fusion.compass(f)   Code:   compass.getHeading()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_compass_heading = None \ncompass = Fusion.compass(f)\nmy_compass_heading = compass.getHeading()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Compass/#hard-iron-calibration", 
            "text": "Hard Iron Calibration (HIC) is a method of checking for magnets or an object generating a magnetic field around the sensor and generating an offset to account for the magnetic field. During HIC the sensor must be rotated 360\u00b0 in 5 seconds while keeping a constant pace. Try to start and stop the sensor pointing due North.    Rotate 360\u00b0 in 5 seconds while blue LED inside sensor is turned on.", 
            "title": "Hard Iron Calibration"
        }, 
        {
            "location": "/Blk_Compass/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_1", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.hardIronCalibration()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#tilt-up-calibration", 
            "text": "This block calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 above the horizon during calibration.", 
            "title": "Tilt Up Calibration"
        }, 
        {
            "location": "/Blk_Compass/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_2", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.tiltUp()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#tilt-down-calibration", 
            "text": "This block calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 below the horizon during calibration.", 
            "title": "Tilt Down Calibration"
        }, 
        {
            "location": "/Blk_Compass/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_3", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.tiltDown()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#accelerometer-calibration", 
            "text": "This block will calibrate the  X ,  Y  and  Z  values by zeroing them. The  X  and  Y  calibration must be done with the sensor laying flat on the horizon. The  Z  must be calibrated with the sensor held vertical. Allow a minimum of 3 seconds for calibration of each step.  Position for  X  and  Y  axis.   Position for  Z  axis.", 
            "title": "Accelerometer Calibration"
        }, 
        {
            "location": "/Blk_Compass/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_4", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.nullAccelerometer('X')", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#get-accelerometer-reading", 
            "text": "This block returns the accelerometer values for the  X ,  Y  and  Z  axis.   The returned reading is between  -32,767  and  32,768 .", 
            "title": "Get Accelerometer Reading"
        }, 
        {
            "location": "/Blk_Compass/#block_5", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_5", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.getAccelerometer()[0]", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#example_1", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\ncompass = Fusion.compass(f)\nprint('Lay the sensor flat on a surface for X and Y calibration')\ncompass.nullAccelerometer('X')\ncompass.nullAccelerometer('Y')\ntime.sleep(5)\nprint('Hold the sensor vertical with the wire pointing up')\ncompass.nullAccelerometer('Z')\nwhile True:\n    print(''.join([str(x) for x in ['X: ', compass.getAccelerometer()[0], '    Y: ', compass.getAccelerometer()[1], '    Z: ', compass.getAccelerometer()[2]]]))\n    time.sleep(0.1)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Compass/#get-magnetometer-reading", 
            "text": "This block returns the values of the magnetometer on the  X ,  Y  and  Z  axis.   The returned reading is between  0  and  1023 .", 
            "title": "Get Magnetometer Reading"
        }, 
        {
            "location": "/Blk_Compass/#block_6", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_6", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.getMagnetometer()[0]", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#scale-accelerometer", 
            "text": "This block is called if the user wants to change the sensitivity of the accelerometer reading. First the sensor must be set vertical (Same position as  Z  calibration) and hold it there for the duration of the calibration. Once the sensor is in position the program may be ran. Once the program is completed, the scaling value will be updated within the Compass.  Postion of sensor during scaling.", 
            "title": "Scale Accelerometer"
        }, 
        {
            "location": "/Blk_Compass/#block_7", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Compass/#code-produced_7", 
            "text": "Setup:   compass = Fusion.compass(f)   Code:   compass.scaleAccelerometer()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Compass/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Compass", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Rate_Gyro/", 
            "text": "Rate Gyro (45-2004)\n\n\n\n\nThe Rate Gyro is used to detect the rate of rotation. When the Rate Gyro is completely still, the returned reading is 1.4V which produces a reading of 280\u00b0 \u00b12\u00b0. With the sensor idle at 280\u00b0 a Counter Clockwise (CCW) rotation will increase the value of the reading and then return to 280\u00b0 once movement is stopped. A Clockwise (CW) rotation of the gyro will cause a decrease in the return value and return to 280\u00b0 once the sensor is no longer moving. The readings are accurate to the degree.\n\n\n\n\nConnect via analog port \nA0\n - \nA7\n.\n\n\n\n\n\n\nRate Gyro Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nRead\n\n\n\n\n\n\nRead\n\n\n\n\nReturns the current rate of rotation detected by the sensor.\n\n\n\n\nIdle reading is \n280\u00b0\n.\n\n\nCW\n rotation results in an increase (\n+\n) in reading.\n\n\nCCW\n rotation results in a decrease (\n-\n) in reading.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSensor Declaration:\n\n\n\n\nrate_gyro_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\nSensor Code:\n\n\n\n\nrate_gyro_A0.read()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Rate Gyro", 
            "title": "Rate Gyro (45-2004)"
        }, 
        {
            "location": "/Blk_Rate_Gyro/#rate-gyro-45-2004", 
            "text": "The Rate Gyro is used to detect the rate of rotation. When the Rate Gyro is completely still, the returned reading is 1.4V which produces a reading of 280\u00b0 \u00b12\u00b0. With the sensor idle at 280\u00b0 a Counter Clockwise (CCW) rotation will increase the value of the reading and then return to 280\u00b0 once movement is stopped. A Clockwise (CW) rotation of the gyro will cause a decrease in the return value and return to 280\u00b0 once the sensor is no longer moving. The readings are accurate to the degree.   Connect via analog port  A0  -  A7 .    Rate Gyro Python Library Information   List of available blocks:      Read", 
            "title": "Rate Gyro (45-2004)"
        }, 
        {
            "location": "/Blk_Rate_Gyro/#read", 
            "text": "Returns the current rate of rotation detected by the sensor.   Idle reading is  280\u00b0 .  CW  rotation results in an increase ( + ) in reading.  CCW  rotation results in a decrease ( - ) in reading.", 
            "title": "Read"
        }, 
        {
            "location": "/Blk_Rate_Gyro/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Rate_Gyro/#code-produced", 
            "text": "Sensor Declaration:   rate_gyro_A0 = Fusion.analog(f, f.A0)   Sensor Code:   rate_gyro_A0.read()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Rate_Gyro/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Rate Gyro", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/", 
            "text": "Integrating Gyro (45-2005)\n\n\n\n\nThe Integrating Gyro uses a 3-axis chip to obtain \nX\n, \nY\n and \nZ\n coordinates as well as an integration of the z-axis to provide heading data. The integrated Z value is an integration of the z-axis over time and this value is used internally in heading calculations. The LED will blink at 1Hz during normal operation and will remain on during null operation (calibration). Once the null location is set, the sensor will maintain that reference until the sensor is recalibrated or zeroed.\n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nIntegrating Gyro Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nCalibrate\n\n\nZero\n\n\nGet Heading\n\n\n\n\n\n\nCalibrate\n\n\n\n\nSetting the gyro to null will enable the user to calibrate their gyro. The gyro must be kept perfectly still and flat during the null operation. During the null operation, the LED will be on and remain on until calibration is complete. It is recommended that this function be called rarely as this function writes to the EEPROM every time it is called. Therefore set the gyro to \n0\n without writing to the EEPROM, use the \nZero\n block.\n\n\n\n\nTakes up to \n3\n seconds to calibrate.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nint_gyro = Fusion.intGyro(f)\nint_gyro.setNull()\n\n\n\n\n\n\n\nZero\n\n\n\n\nSets the current heading to \n0\n. Does not calibrate the gyro. This is very useful for resetting the returned heading reading without needing to remain still for calibration.\n\n\n\n\nSet \n0\n without calibration.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nint_gyro = Fusion.intGyro(f)\n\n\n\n\n\nCode:\n\n\n\n\nint_gyro.setZero()\n\n\n\n\n\n\n\n\n\nGet Heading\n\n\n\n\nReturns the current heading in degrees.\n\n\n\n\nDegrees\n - Returns the cartesian reading between \n0\n and \n359\n.\n\n\nAbsolute\n - Returns the absolute reading between \n-32,768\n and \n32,768\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSensor Declaration:\n\n\n\n\nint_gyro = Fusion.intGyro(f)\n\n\n\n\n\nSensor Code:\n\n\n\n\nint_gyro.getDegrees()\n\n\n\nor\n\n\nint_gyro.getAbsolute()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setZero()\nwhile True:\n    print(''.join([str(x) for x in ['Degrees: ', int_gyro.getDegrees(), '    Absolute: ', int_gyro.getAbsolute()]]))\n    time.sleep(0.1)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Integrating Gyro", 
            "title": "Integrating Gyro (45-2005)"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#integrating-gyro-45-2005", 
            "text": "The Integrating Gyro uses a 3-axis chip to obtain  X ,  Y  and  Z  coordinates as well as an integration of the z-axis to provide heading data. The integrated Z value is an integration of the z-axis over time and this value is used internally in heading calculations. The LED will blink at 1Hz during normal operation and will remain on during null operation (calibration). Once the null location is set, the sensor will maintain that reference until the sensor is recalibrated or zeroed.   Connect via  I2C  port.    Integrating Gyro Python Library Information   List of available blocks:      Calibrate  Zero  Get Heading", 
            "title": "Integrating Gyro (45-2005)"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#calibrate", 
            "text": "Setting the gyro to null will enable the user to calibrate their gyro. The gyro must be kept perfectly still and flat during the null operation. During the null operation, the LED will be on and remain on until calibration is complete. It is recommended that this function be called rarely as this function writes to the EEPROM every time it is called. Therefore set the gyro to  0  without writing to the EEPROM, use the  Zero  block.   Takes up to  3  seconds to calibrate.", 
            "title": "Calibrate"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#code-produced", 
            "text": "int_gyro = Fusion.intGyro(f)\nint_gyro.setNull()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#zero", 
            "text": "Sets the current heading to  0 . Does not calibrate the gyro. This is very useful for resetting the returned heading reading without needing to remain still for calibration.   Set  0  without calibration.", 
            "title": "Zero"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#code-produced_1", 
            "text": "Setup:   int_gyro = Fusion.intGyro(f)   Code:   int_gyro.setZero()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#get-heading", 
            "text": "Returns the current heading in degrees.   Degrees  - Returns the cartesian reading between  0  and  359 .  Absolute  - Returns the absolute reading between  -32,768  and  32,768 .", 
            "title": "Get Heading"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#code-produced_2", 
            "text": "Sensor Declaration:   int_gyro = Fusion.intGyro(f)   Sensor Code:   int_gyro.getDegrees()  or  int_gyro.getAbsolute()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#example", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setZero()\nwhile True:\n    print(''.join([str(x) for x in ['Degrees: ', int_gyro.getDegrees(), '    Absolute: ', int_gyro.getAbsolute()]]))\n    time.sleep(0.1)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Integrating_Gyro/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Integrating Gyro", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/", 
            "text": "Optical Distance Sensor (45-2006)\n\n\n\n\nThe Optical Distance Sensor (ODS) is an analog sensor that uses electro optical proximity detection to approximate distance from an object based on the intensity of the reflected light. This sensor can typical detect distances between 1cm to 15cm. Lighter colored objects will return a more accurate and consistent reading, and the material also plays a part on the returned value. Try different colors and material to see what works best for you. The ODS can be used for object detection, line detection and the difference between light and dark.\n\n\n\n\nConnect via analog port \nA0\n - \nA7\n.\n\n\n\n\n\n\nOptical Distance Sensor Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nRead\n\n\n\n\n\n\nRead\n\n\n\n\nRead the proximity of an object using pulsed visible light.\n\n\n\n\nThe returned reading ranges from \n0\n - \n1023\n.\n\n\nDetectable proximity ranges from \n1\n cm to \n15\n cm.\n\n\nReturned reading is an exponential decay.\n\n\nValue increases as the object approached the sensor.\n\n\n\n\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nods_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\nCode:\n\n\n\n\nods_A0.read()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_ods = None\nods_A2 = Fusion.analog(f, f.A2)   \nmy_ods = ods_A2.read()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Optical Distance Sensor", 
            "title": "Optical Distance Sensor (45-2006)"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/#optical-distance-sensor-45-2006", 
            "text": "The Optical Distance Sensor (ODS) is an analog sensor that uses electro optical proximity detection to approximate distance from an object based on the intensity of the reflected light. This sensor can typical detect distances between 1cm to 15cm. Lighter colored objects will return a more accurate and consistent reading, and the material also plays a part on the returned value. Try different colors and material to see what works best for you. The ODS can be used for object detection, line detection and the difference between light and dark.   Connect via analog port  A0  -  A7 .    Optical Distance Sensor Python Library Information      List of available blocks:      Read", 
            "title": "Optical Distance Sensor (45-2006)"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/#read", 
            "text": "Read the proximity of an object using pulsed visible light.   The returned reading ranges from  0  -  1023 .  Detectable proximity ranges from  1  cm to  15  cm.  Returned reading is an exponential decay.  Value increases as the object approached the sensor.", 
            "title": "Read"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/#code-produced", 
            "text": "Setup:   ods_A0 = Fusion.analog(f, f.A0)   Code:   ods_A0.read()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_ods = None\nods_A2 = Fusion.analog(f, f.A2)   \nmy_ods = ods_A2.read()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Optical_Distance_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Optical Distance Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Touch_Sensor/", 
            "text": "Touch Sensor (45-2007)\n\n\n\n\nThe Touch Sensor can be used for an array of different tasks including object detection, a counter, a standard push button and many more. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.\n\n\n\n\nConnect via digital port \nD0\n - \nD7\n.\n\n\n\n\n\n\nTouch Sensor Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nPressed\n\n\n\n\n\n\nPressed\n\n\n\n\nThe Touch Sensor can be used as a toggle or limit switch. \n\n\n\n\nCan be read as either \nPressed\n or \nNot Pressed\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ntouch_D7 = Fusion.digital(f, f.D7)\n\n\n\n\n\nCode:\n\n\n\n\ntouch_D7.read()==1\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ntouch_D7 = Fusion.digital(f, f.D7)\nif touch_D7.read()==1:\n    f.setLED(f.BLUE, 1)\nelse:\n    f.setLED(f.BLUE, 0)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Touch Sensor", 
            "title": "Touch Sensor (45-2007)"
        }, 
        {
            "location": "/Blk_Touch_Sensor/#touch-sensor-45-2007", 
            "text": "The Touch Sensor can be used for an array of different tasks including object detection, a counter, a standard push button and many more. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.   Connect via digital port  D0  -  D7 .    Touch Sensor Python Library Information   List of available blocks:      Pressed", 
            "title": "Touch Sensor (45-2007)"
        }, 
        {
            "location": "/Blk_Touch_Sensor/#pressed", 
            "text": "The Touch Sensor can be used as a toggle or limit switch.    Can be read as either  Pressed  or  Not Pressed .", 
            "title": "Pressed"
        }, 
        {
            "location": "/Blk_Touch_Sensor/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Touch_Sensor/#code-produced", 
            "text": "Setup:   touch_D7 = Fusion.digital(f, f.D7)   Code:   touch_D7.read()==1", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Touch_Sensor/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\ntouch_D7 = Fusion.digital(f, f.D7)\nif touch_D7.read()==1:\n    f.setLED(f.BLUE, 1)\nelse:\n    f.setLED(f.BLUE, 0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Touch_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Touch Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Range_Sensor/", 
            "text": "Range Sensor (45-2008)\n\n\n\n\nThe Range Sensor combines ultrasonic and optical measuring elements to obtain a reading between 1cm and 255cm. The ultrasonic accurately measures distance to a target up to 255cm away, but it losses accuracy if the object is closer than 5cm. This is where the optical sensor comes into play as it can measure from 1cm out to about 7cm. The target shape and surface material will influence the detectable range.\n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nRange Sensor Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nUltrasonic\n\n\nOptical\n\n\n\n\n\n\nUltrasonic\n\n\n\n\nRead the distance of an object using ultrasonic sound.\n\n\n\n\nReturns reading in centimeters (cm).\n\n\nDetectable distance ranges from \n1\n cm to \n255\n cm.\n\n\nReturned reading is linear.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nrange = Fusion.range(f)\n\n\n\n\n\nCode:\n\n\n\n\nrange.ultrasonic()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_range_ultrasonic = None\nrange = Fusion.range(f)\nmy_range_ultrasonic = range.ultrasonic()\n\n\n\n\n\n\n\n\n\nOptical\n\n\n\n\nRead the proximity of an object using infrared light.\n\n\n\n\nThe returned reading ranges from \n0\n - \n1023\n.\n\n\nDetectable proximity ranges from \n1\n cm to \n15\n cm.\n\n\nReturned reading is an exponential decay.\n\n\nValue increases as the object approached the sensor.\n\n\n\n\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nrange = Fusion.range(f)\n\n\n\n\n\nCode:\n\n\n\n\nrange.optical()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_range_optical = None\nrange = Fusion.range(f)\nmy_range_optical = range.optical()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Range Sensor", 
            "title": "Range Sensor (45-2008)"
        }, 
        {
            "location": "/Blk_Range_Sensor/#range-sensor-45-2008", 
            "text": "The Range Sensor combines ultrasonic and optical measuring elements to obtain a reading between 1cm and 255cm. The ultrasonic accurately measures distance to a target up to 255cm away, but it losses accuracy if the object is closer than 5cm. This is where the optical sensor comes into play as it can measure from 1cm out to about 7cm. The target shape and surface material will influence the detectable range.   Connect via  I2C  port.    Range Sensor Python Library Information   List of available blocks:      Ultrasonic  Optical", 
            "title": "Range Sensor (45-2008)"
        }, 
        {
            "location": "/Blk_Range_Sensor/#ultrasonic", 
            "text": "Read the distance of an object using ultrasonic sound.   Returns reading in centimeters (cm).  Detectable distance ranges from  1  cm to  255  cm.  Returned reading is linear.", 
            "title": "Ultrasonic"
        }, 
        {
            "location": "/Blk_Range_Sensor/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Range_Sensor/#code-produced", 
            "text": "Setup:   range = Fusion.range(f)   Code:   range.ultrasonic()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Range_Sensor/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_range_ultrasonic = None\nrange = Fusion.range(f)\nmy_range_ultrasonic = range.ultrasonic()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Range_Sensor/#optical", 
            "text": "Read the proximity of an object using infrared light.   The returned reading ranges from  0  -  1023 .  Detectable proximity ranges from  1  cm to  15  cm.  Returned reading is an exponential decay.  Value increases as the object approached the sensor.", 
            "title": "Optical"
        }, 
        {
            "location": "/Blk_Range_Sensor/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Range_Sensor/#code-produced_1", 
            "text": "Setup:   range = Fusion.range(f)   Code:   range.optical()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Range_Sensor/#example_1", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_range_optical = None\nrange = Fusion.range(f)\nmy_range_optical = range.optical()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Range_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Range Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_IR_Locator_360/", 
            "text": "IR Locator 360\u00b0 (45-2009)\n\n\n\n\nThe IR Locator 360\u00b0 utilizes an array of 4 photodiodes to detect the direction and distance from a 1200Hz or 600Hz pulsed infrared source with a  5\u00b0resolution. Both the 600Hz and 1200Hz frequencies can be read at the same time allowing up to two directional sources to be used. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. \n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nIR Locator 360\u00b0 Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nHeading\n\n\nIntensity\n\n\n\n\n\n\nHeading\n\n\n\n\nReads incoming infrared light in a 360\u00b0 field around the sensor. The returned reading is in 5\u00b0 increments.\n\n\n\n\nRead incoming infrared light at a frequency of \n600Hz\n or \n1200Hz\n.\n\n\nThe returned heading reading ranges from \n0\n - \n71\n.\n\n\nCW\n rotation results in an increase (\n+\n) in reading from \n0\n.\n\n\nCCW\n rotation results in a decrease (\n-\n) in reading from \n71\n.\n\n\n\n\nDegrees\n \n=\n Heading Reading \nx\n 5\u00b0\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nlocator = Fusion.locator360(f)\n\n\n\n\n\nCode:\n\n\n\n\nlocator.getHeading(1200)\n\n\n\n\n\n\n\n\n\nIntensity\n\n\n\n\nMeasures the amount of infrared light being detected which corresponds to the distance between the sensor and source.\n\n\n\n\nRead incoming infrared light at a frequency of \n600Hz\n or \n1200Hz\n.\n\n\nThe returned intensity value increases as the source approaches the sensor.\n\n\nValue is \n0\n if no infrared light is detected.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nlocator = Fusion.locator360(f)\n\n\n\n\n\nCode:\n\n\n\n\nlocator.getIntensity(1200)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly IR Locator 360", 
            "title": "IR Locator 360\u00b0 (45-2009)"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#ir-locator-360-45-2009", 
            "text": "The IR Locator 360\u00b0 utilizes an array of 4 photodiodes to detect the direction and distance from a 1200Hz or 600Hz pulsed infrared source with a  5\u00b0resolution. Both the 600Hz and 1200Hz frequencies can be read at the same time allowing up to two directional sources to be used. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used.    Connect via  I2C  port.    IR Locator 360\u00b0 Python Library Information      List of available blocks:      Heading  Intensity", 
            "title": "IR Locator 360\u00b0 (45-2009)"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#heading", 
            "text": "Reads incoming infrared light in a 360\u00b0 field around the sensor. The returned reading is in 5\u00b0 increments.   Read incoming infrared light at a frequency of  600Hz  or  1200Hz .  The returned heading reading ranges from  0  -  71 .  CW  rotation results in an increase ( + ) in reading from  0 .  CCW  rotation results in a decrease ( - ) in reading from  71 .   Degrees   =  Heading Reading  x  5\u00b0", 
            "title": "Heading"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#code-produced", 
            "text": "Setup:   locator = Fusion.locator360(f)   Code:   locator.getHeading(1200)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#intensity", 
            "text": "Measures the amount of infrared light being detected which corresponds to the distance between the sensor and source.   Read incoming infrared light at a frequency of  600Hz  or  1200Hz .  The returned intensity value increases as the source approaches the sensor.  Value is  0  if no infrared light is detected.", 
            "title": "Intensity"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#code-produced_1", 
            "text": "Setup:   locator = Fusion.locator360(f)   Code:   locator.getIntensity(1200)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_IR_Locator_360/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly IR Locator 360", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Light_Sensor/", 
            "text": "Light Sensor (45-2015)\n\n\n\n\nThe Light Sensor detects the ambient light level using a phototransistor. The value returned is a quasi-logarithmic analog value. This means that the Light Sensor can detect slight changes in light and dark environments. A value of 0 indicates no light and a value of 1023 indicates the sensor is flooded with light.\n\n\n\n\nConnect via analog port \nA0\n - \nA7\n.\n\n\n\n\n\n\nLight Sensor Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nRead\n\n\n\n\n\n\nRead\n\n\n\n\nMeasures the amount of ambient light detected on the top side of the sensor.\n\n\n\n\nThe returned reading ranges from \n0\n - \n1023\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nlight_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\nCode:\n\n\n\n\nlight_A0.read()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Light Sensor", 
            "title": "Light Sensor (45-2015)"
        }, 
        {
            "location": "/Blk_Light_Sensor/#light-sensor-45-2015", 
            "text": "The Light Sensor detects the ambient light level using a phototransistor. The value returned is a quasi-logarithmic analog value. This means that the Light Sensor can detect slight changes in light and dark environments. A value of 0 indicates no light and a value of 1023 indicates the sensor is flooded with light.   Connect via analog port  A0  -  A7 .    Light Sensor Python Library Information      List of available blocks:      Read", 
            "title": "Light Sensor (45-2015)"
        }, 
        {
            "location": "/Blk_Light_Sensor/#read", 
            "text": "Measures the amount of ambient light detected on the top side of the sensor.   The returned reading ranges from  0  -  1023 .", 
            "title": "Read"
        }, 
        {
            "location": "/Blk_Light_Sensor/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Light_Sensor/#code-produced", 
            "text": "Setup:   light_A0 = Fusion.analog(f, f.A0)   Code:   light_A0.read()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Light_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Light Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Sound_Generator/", 
            "text": "Sound Generator (45-2016)\n\n\n\n\nThe Sound Generator can generate a sound based on volume, pitch and duration. This sensor also can overwrite settings during a tone to change the pitch, volume, or extend the duration of the tone.\n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nSound Generator Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSet Sound (Blocking)\n\n\nSet Sound\n\n\n\n\n\n\nSet Sound (Blocking)\n\n\n\n\nGenerate a tone based on \nVolume\n, \nPitch\n, \nDuration\n of tone and \nPause\n after the tone. Play a sound for a set duration, then wait for a specified amount of time before continuing on to the next block in the program.\n\n\n\n\nVolume\n - How loud or quiet a sound is. (\nLow\n, \nMedium\n, \nHigh\n, \nMax\n)\n\n\nPitch\n - The frequency at which the tone is played ranges from \n1 Hz\n - \n5000 Hz\n.\n\n\nDuration\n - The length of the tone ranges from \n0.1 sec\n - \n65.5 sec\n.\n\n\nPause\n - The length of time from the end of the current tone until the next block is executed.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nsound = Fusion.sound(f)\n\n\n\n\n\nCode:\n\n\n\n\nsound.setSoundBlocking(1, 440, 1000, 500)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nsound = Fusion.sound(f)\nsound.setSoundBlocking(2, 1500, 1500, 1000)\nsound.setSoundBlocking(0, 3250, 3000, 1500)\n\n\n\n\n\n\n\n\n\nSet Sound\n\n\n\n\nGenerate a tone based on \nVolume\n, \nPitch\n and \nDuration\n of tone. Play a sound for a set duration and continue on to the next block in the program.\n\n\n\n\nVolume\n - How loud or quiet a sound is. (\nLow\n, \nMedium\n, \nHigh\n, \nMax\n)\n\n\nPitch\n - The frequency at which the tone is played ranges from \n1 Hz\n - \n5000 Hz\n.\n\n\nDuration\n - The length of the tone ranges from \n0.1 sec\n - \n2.55 sec\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nsound = Fusion.sound(f)\n\n\n\n\n\nCode:\n\n\n\n\nsound.setSound(3, 1500, 2550);\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nImports:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\nsound = Fusion.sound(f)\nsound.setSound(3, 2000, 1000)\ntime.sleep(1)\nsound.setSound(0, 2500, 1750)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Sound Generator", 
            "title": "Sound Generator (45-2016)"
        }, 
        {
            "location": "/Blk_Sound_Generator/#sound-generator-45-2016", 
            "text": "The Sound Generator can generate a sound based on volume, pitch and duration. This sensor also can overwrite settings during a tone to change the pitch, volume, or extend the duration of the tone.   Connect via  I2C  port.    Sound Generator Python Library Information   List of available blocks:      Set Sound (Blocking)  Set Sound", 
            "title": "Sound Generator (45-2016)"
        }, 
        {
            "location": "/Blk_Sound_Generator/#set-sound-blocking", 
            "text": "Generate a tone based on  Volume ,  Pitch ,  Duration  of tone and  Pause  after the tone. Play a sound for a set duration, then wait for a specified amount of time before continuing on to the next block in the program.   Volume  - How loud or quiet a sound is. ( Low ,  Medium ,  High ,  Max )  Pitch  - The frequency at which the tone is played ranges from  1 Hz  -  5000 Hz .  Duration  - The length of the tone ranges from  0.1 sec  -  65.5 sec .  Pause  - The length of time from the end of the current tone until the next block is executed.", 
            "title": "Set Sound (Blocking)"
        }, 
        {
            "location": "/Blk_Sound_Generator/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Sound_Generator/#code-produced", 
            "text": "Setup:   sound = Fusion.sound(f)   Code:   sound.setSoundBlocking(1, 440, 1000, 500)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Sound_Generator/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nsound = Fusion.sound(f)\nsound.setSoundBlocking(2, 1500, 1500, 1000)\nsound.setSoundBlocking(0, 3250, 3000, 1500)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Sound_Generator/#set-sound", 
            "text": "Generate a tone based on  Volume ,  Pitch  and  Duration  of tone. Play a sound for a set duration and continue on to the next block in the program.   Volume  - How loud or quiet a sound is. ( Low ,  Medium ,  High ,  Max )  Pitch  - The frequency at which the tone is played ranges from  1 Hz  -  5000 Hz .  Duration  - The length of the tone ranges from  0.1 sec  -  2.55 sec .", 
            "title": "Set Sound"
        }, 
        {
            "location": "/Blk_Sound_Generator/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Sound_Generator/#code-produced_1", 
            "text": "Setup:   sound = Fusion.sound(f)   Code:   sound.setSound(3, 1500, 2550);", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Sound_Generator/#example_1", 
            "text": "Imports:   import Fusion\nimport time\nf = Fusion.driver()\nsound = Fusion.sound(f)\nsound.setSound(3, 2000, 1000)\ntime.sleep(1)\nsound.setSound(0, 2500, 1750)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Sound_Generator/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Sound Generator", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/", 
            "text": "IR Seeker V3 (45-2017)\n\n\n\n\nThe IR Seeker V3 consists of 2 photodiodes to locate the direction and intensity of an IR source relative to the front of the sensor. The sensor can detect pulsed infrared light at 600Hz and 1200Hz with a 150\u00b0 field of view. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. Overall detection range is based on the intensity of the IR source being used. \n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nIR Seeker V3 Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nHeading\n\n\nIntensity\n\n\n\n\n\n\nHeading\n\n\n\n\nThe value is \n0\n if the source is directly in front with a \n+\n/\n-\n change if the source moves to either side.\n\n\n\n\nRead incoming infrared light at a frequency of \n600Hz\n or \n1200Hz\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nseeker = Fusion.seekerV3(f)\n\n\n\n\n\nCode:\n\n\n\n\nseeker.getHeading(1200)\n\n\n\n\n\n\n\n\n\nIntensity\n\n\n\n\nMeasures the amount of infrared light being detected which corresponds to the distance between the sensor and source.\n\n\n\n\nRead incoming infrared light at a frequency of \n600Hz\n or \n1200Hz\n.\n\n\nThe returned intensity value increases as the source approaches the sensor.\n\n\nValue is \n0\n if no infrared light is detected.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nseeker = Fusion.seekerV3(f)\n\n\n\n\n\nCode:\n\n\n\n\nseeker.getIntensity(1200)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly IR Seeker V3", 
            "title": "IR Seeker V3 (45-2017)"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#ir-seeker-v3-45-2017", 
            "text": "The IR Seeker V3 consists of 2 photodiodes to locate the direction and intensity of an IR source relative to the front of the sensor. The sensor can detect pulsed infrared light at 600Hz and 1200Hz with a 150\u00b0 field of view. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. Overall detection range is based on the intensity of the IR source being used.    Connect via  I2C  port.    IR Seeker V3 Python Library Information   List of available blocks:      Heading  Intensity", 
            "title": "IR Seeker V3 (45-2017)"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#heading", 
            "text": "The value is  0  if the source is directly in front with a  + / -  change if the source moves to either side.   Read incoming infrared light at a frequency of  600Hz  or  1200Hz .", 
            "title": "Heading"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#code-produced", 
            "text": "Setup:   seeker = Fusion.seekerV3(f)   Code:   seeker.getHeading(1200)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#intensity", 
            "text": "Measures the amount of infrared light being detected which corresponds to the distance between the sensor and source.   Read incoming infrared light at a frequency of  600Hz  or  1200Hz .  The returned intensity value increases as the source approaches the sensor.  Value is  0  if no infrared light is detected.", 
            "title": "Intensity"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#code-produced_1", 
            "text": "Setup:   seeker = Fusion.seekerV3(f)   Code:   seeker.getIntensity(1200)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_IR_Seeker_V3/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly IR Seeker V3", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Color_Sensor/", 
            "text": "Color Sensor (45-2018)\n\n\n\n\nThe Color Sensor is used to detect the color of an object or a visible light source. Along with raw and adjusted RGB values, the device can also return a color number corresponding to a the colors listed below in the documentation. Calibration steps must be taken as needed based on the environment and ambient lighting for the most accurate readings. Maximum detection distance of the color sensor is approximately 7cm and it is recommended that during active mode the device is placed at a slight angle to avoid white light reflecting from the LED. \n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nColor Sensor Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSet Mode\n\n\nGet Color Number\n\n\nGet RGB\n\n\n\n\n\n\nSet Mode\n\n\n\n\nSet the reading mode and frequency. Values are saved within the sensor memory, therefore this block only needs to be called when the mode needs to be changed.\n\n\n\n\nMode:\n\n\nActive\n (Default)\n\n\nPassive\n\n\n\n\n\n\nFrequency:\n\n\n60 Hz\n (Default)\n\n\n50 Hz\n\n\n\n\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncolour = Fusion.color(f)\n\n\n\n\n\nCode:\n\n\n\n\ncolour.colorSetup(colour.ACTIVE, colour.SIXTY_HZ)\n\n\n\n\n\n\n\n\n\nGet Color Number\n\n\n\n\nReturns a value representing a color based on the color chart below.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncolour = Fusion.color(f)\n\n\n\n\n\nCode:\n\n\n\n\ncolour.getColorNumber()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_color = None\ncolour = Fusion.color(f)\nmy_color = colour.getColorNumber()\n\n\n\n\n\n\n\n\n\nGet RGB\n\n\n\n\nReturns the \nRed\n, \nGreen\n or \nBlue\n reading from the current object in front of the sensor.\n\n\n\n\nCan read the \nRed\n, \nGreen\n or \nBlue\n value.\n\n\nThe returned ranges from \n0\n to \n255\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\ncolour = Fusion.color(f)\n\n\n\n\n\nCode:\n\n\n\n\ncolour.getRGBIndex()[0]\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_red = None\nmy_green = None\nmy_blue = None\ncolour = Fusion.color(f)\nmy_red = colour.getRGBIndex()[0]\nmy_green = colour.getRGBIndex()[1]\nmy_blue = colour.getRGBIndex()[2]\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Color Sensor", 
            "title": "Color Sensor (45-2018)"
        }, 
        {
            "location": "/Blk_Color_Sensor/#color-sensor-45-2018", 
            "text": "The Color Sensor is used to detect the color of an object or a visible light source. Along with raw and adjusted RGB values, the device can also return a color number corresponding to a the colors listed below in the documentation. Calibration steps must be taken as needed based on the environment and ambient lighting for the most accurate readings. Maximum detection distance of the color sensor is approximately 7cm and it is recommended that during active mode the device is placed at a slight angle to avoid white light reflecting from the LED.    Connect via  I2C  port.    Color Sensor Python Library Information      List of available blocks:      Set Mode  Get Color Number  Get RGB", 
            "title": "Color Sensor (45-2018)"
        }, 
        {
            "location": "/Blk_Color_Sensor/#set-mode", 
            "text": "Set the reading mode and frequency. Values are saved within the sensor memory, therefore this block only needs to be called when the mode needs to be changed.   Mode:  Active  (Default)  Passive    Frequency:  60 Hz  (Default)  50 Hz", 
            "title": "Set Mode"
        }, 
        {
            "location": "/Blk_Color_Sensor/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#code-produced", 
            "text": "Setup:   colour = Fusion.color(f)   Code:   colour.colorSetup(colour.ACTIVE, colour.SIXTY_HZ)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#get-color-number", 
            "text": "Returns a value representing a color based on the color chart below.", 
            "title": "Get Color Number"
        }, 
        {
            "location": "/Blk_Color_Sensor/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#code-produced_1", 
            "text": "Setup:   colour = Fusion.color(f)   Code:   colour.getColorNumber()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_color = None\ncolour = Fusion.color(f)\nmy_color = colour.getColorNumber()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#get-rgb", 
            "text": "Returns the  Red ,  Green  or  Blue  reading from the current object in front of the sensor.   Can read the  Red ,  Green  or  Blue  value.  The returned ranges from  0  to  255 .", 
            "title": "Get RGB"
        }, 
        {
            "location": "/Blk_Color_Sensor/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#code-produced_2", 
            "text": "Setup:   colour = Fusion.color(f)   Code:   colour.getRGBIndex()[0]", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#example_1", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_red = None\nmy_green = None\nmy_blue = None\ncolour = Fusion.color(f)\nmy_red = colour.getRGBIndex()[0]\nmy_green = colour.getRGBIndex()[1]\nmy_blue = colour.getRGBIndex()[2]", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Color_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Color Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Color_Beacon/", 
            "text": "Color Beacon (45-2019)\n\n\n\n\nThe Color Beacon is used to display one of seven colors or any set custom color based on RGB values.\n\nThe beacon can also indicate \nRed\n/\nBlue\n team colors with the use of a magnet. There is no code or setup needed to operate as a team indicator. There is a Hall Effect sensor located on the left side of the sensors (wire pointed toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to \nRed\n, \nBlue\n or \nOff\n. This can be done at any time and will overwrite any custom color or color number. When the beacon is \nRed\n or \nBlue\n from the Hall Effect sensor, it will be locked in that mode until turned \nOff\n using a magnet or disconnecting the sensor.\n\n\n\n\nConnect via \nI2C\n port.\n\n\n\n\n\n\nColor Beacon Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSet Color\n\n\nSet Custom Color\n\n\n\n\n\n\nSet Color\n\n\n\n\nSet the color of the Color Beacon to one of the preset colors.\n\n\n\n\n\n    \nNumber\nColor\n\n    \n0\nOff\n\n    \n1\nRed\n\n    \n2\nGreen\n\n    \n3\nYellow\n\n    \n4\nBlue\n\n    \n5\nPurple\n\n    \n6\nTeal\n\n    \n7\nWhite\n\n\n\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nbeacon = Fusion.colorBeacon(f)\n\n\n\n\n\nCode:\n\n\n\n\nbeacon.setColor(1)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\nbeacon = Fusion.colorBeacon(f)\nbeacon.setColor(1)\ntime.sleep(1)\nbeacon.setColor(4)\ntime.sleep(1)\nbeacon.setColor(3)\ntime.sleep(1)\nbeacon.setColor(0)\n\n\n\n\n\n\n\n\n\nSet Custom Color\n\n\n\n\nSet a custom color using Red, Green and Blue (RGB) values.\n\n\n\n\nRGB value ranges from \n0\n - \n255\n.\n\n\nSome online sources may represent the color in hexadecimal (\n0x00\n - \n0xFF\n). Use a hexadecimal to decimal converter to get the appropriate value to enter. You can also use built-in Windows calculator, just change to programmer mode.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nbeacon = Fusion.colorBeacon(f)\n\n\n\n\n\nCode:\n\n\n\n\nbeacon.setCustomColor(100,0,255)\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nSetup:\n\n\n\n\nbeacon = Fusion.colorBeacon(f)\ncolour = Fusion.color(f)\n\n\n\n\n\nCode:\n\n\n\n\nbeacon.setCustomColor(colour.getRGBIndex()[0],colour.getRGBIndex()[1],colour.getRGBIndex()[2])\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Color Beacon", 
            "title": "Color Beacon (45-2019)"
        }, 
        {
            "location": "/Blk_Color_Beacon/#color-beacon-45-2019", 
            "text": "The Color Beacon is used to display one of seven colors or any set custom color based on RGB values. \nThe beacon can also indicate  Red / Blue  team colors with the use of a magnet. There is no code or setup needed to operate as a team indicator. There is a Hall Effect sensor located on the left side of the sensors (wire pointed toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to  Red ,  Blue  or  Off . This can be done at any time and will overwrite any custom color or color number. When the beacon is  Red  or  Blue  from the Hall Effect sensor, it will be locked in that mode until turned  Off  using a magnet or disconnecting the sensor.   Connect via  I2C  port.    Color Beacon Python Library Information   List of available blocks:      Set Color  Set Custom Color", 
            "title": "Color Beacon (45-2019)"
        }, 
        {
            "location": "/Blk_Color_Beacon/#set-color", 
            "text": "Set the color of the Color Beacon to one of the preset colors.   \n     Number Color \n     0 Off \n     1 Red \n     2 Green \n     3 Yellow \n     4 Blue \n     5 Purple \n     6 Teal \n     7 White", 
            "title": "Set Color"
        }, 
        {
            "location": "/Blk_Color_Beacon/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Color_Beacon/#code-produced", 
            "text": "Setup:   beacon = Fusion.colorBeacon(f)   Code:   beacon.setColor(1)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Color_Beacon/#example", 
            "text": "Code:   import Fusion\nimport time\nf = Fusion.driver()\nbeacon = Fusion.colorBeacon(f)\nbeacon.setColor(1)\ntime.sleep(1)\nbeacon.setColor(4)\ntime.sleep(1)\nbeacon.setColor(3)\ntime.sleep(1)\nbeacon.setColor(0)", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Color_Beacon/#set-custom-color", 
            "text": "Set a custom color using Red, Green and Blue (RGB) values.   RGB value ranges from  0  -  255 .  Some online sources may represent the color in hexadecimal ( 0x00  -  0xFF ). Use a hexadecimal to decimal converter to get the appropriate value to enter. You can also use built-in Windows calculator, just change to programmer mode.", 
            "title": "Set Custom Color"
        }, 
        {
            "location": "/Blk_Color_Beacon/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Color_Beacon/#code-produced_1", 
            "text": "Setup:   beacon = Fusion.colorBeacon(f)   Code:   beacon.setCustomColor(100,0,255)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Color_Beacon/#example_1", 
            "text": "Setup:   beacon = Fusion.colorBeacon(f)\ncolour = Fusion.color(f)   Code:   beacon.setCustomColor(colour.getRGBIndex()[0],colour.getRGBIndex()[1],colour.getRGBIndex()[2])", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Color_Beacon/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Color Beacon", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/", 
            "text": "Magnetic Sensor (45-2020)\n\n\n\n\nThe Magnetic Sensor detects a magnetic field and returns the strength based on the distance between the sensor element and the magnet. The default returned by the sensor when no magnetic field is present is approximately 340. When the returned value is increasing, the sensor is detecting the \"North Pole\" of the magnet. If the value returned is decreasing, then the sensor is detecting the \"South Pole\" of the magnet.\n\n\n\n\nConnect via analog port \nA0\n - \nA7\n.\n\n\n\n\n\n\nMagnetic Sensor Python Library Information\n\n\n\n\nList of available blocks:\n  \n\n\n\n\nRead\n\n\n\n\n\n\nRead\n\n\n\n\nMeasures the intensity of a magnetic field.\n\n\n\n\nThe returned reading ranges from \n0\n - \n1023\n.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nSetup:\n\n\n\n\nmagnetic_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\nCode:\n\n\n\n\nmagnetic_A0.read()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmy_magnet = None\nmagnetic_A3 = Fusion.analog(f, f.A3)\nmy_magnet = magnetic_A3.read()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Magnetic Sensor", 
            "title": "Magnetic Sensor (45-2020)"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/#magnetic-sensor-45-2020", 
            "text": "The Magnetic Sensor detects a magnetic field and returns the strength based on the distance between the sensor element and the magnet. The default returned by the sensor when no magnetic field is present is approximately 340. When the returned value is increasing, the sensor is detecting the \"North Pole\" of the magnet. If the value returned is decreasing, then the sensor is detecting the \"South Pole\" of the magnet.   Connect via analog port  A0  -  A7 .    Magnetic Sensor Python Library Information   List of available blocks:      Read", 
            "title": "Magnetic Sensor (45-2020)"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/#read", 
            "text": "Measures the intensity of a magnetic field.   The returned reading ranges from  0  -  1023 .", 
            "title": "Read"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/#code-produced", 
            "text": "Setup:   magnetic_A0 = Fusion.analog(f, f.A0)   Code:   magnetic_A0.read()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/#example", 
            "text": "Code:   import Fusion\nf = Fusion.driver()\nmy_magnet = None\nmagnetic_A3 = Fusion.analog(f, f.A3)\nmy_magnet = magnetic_A3.read()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_Magnetic_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Magnetic Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/time/", 
            "text": "Time\n\n\n\n\nThe Time toolbox contains blocks for delaying or sleeping the program as well as capuring timestamps.\n\n\nWait in Seconds\n\n\n\n\nWait \nX\n number of seconds before continuing to the next line of code.\n\n\n\n\nX\n is a positive number.\n\n\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nImport:\n\n\n\n\nimport time\n\n\n\n\n\nCode:\n\n\n\n\ntime.sleep(1)\n\n\n\n\n\n\n\n\n\nGet time\n\n\n\n\nReturns a current timestamp of the system clock.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\nImport:\n\n\n\n\nimport time\n\n\n\n\n\nCode:\n\n\n\n\ntime.time()\n\n\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nimport time\nStartTime = None\nStartTime = time.time()\nprint(StartTime)\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Time", 
            "title": "Time"
        }, 
        {
            "location": "/time/#time", 
            "text": "The Time toolbox contains blocks for delaying or sleeping the program as well as capuring timestamps.", 
            "title": "Time"
        }, 
        {
            "location": "/time/#wait-in-seconds", 
            "text": "Wait  X  number of seconds before continuing to the next line of code.   X  is a positive number.", 
            "title": "Wait in Seconds"
        }, 
        {
            "location": "/time/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/time/#code-produced", 
            "text": "Import:   import time   Code:   time.sleep(1)", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/time/#get-time", 
            "text": "Returns a current timestamp of the system clock.", 
            "title": "Get time"
        }, 
        {
            "location": "/time/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/time/#code-produced_1", 
            "text": "Import:   import time   Code:   time.time()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/time/#example", 
            "text": "Code:   import time\nStartTime = None\nStartTime = time.time()\nprint(StartTime)", 
            "title": "Example:"
        }, 
        {
            "location": "/time/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Time", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_File_Handling/", 
            "text": "File Handling\n\n\n\n\nThis library allows you to handle file manipulation(reading/writing) using Blockly.\n\n\nList of available blocks:\n  \n\n\n\n\nOpen File\n\n\nWrite to File\n\n\nClose File\n\n\n\n\nOpen File\n\n\n\n\nSearches for the desired filename and returns a file object or list of text.\n\n\nBlock:\n\n\n\n\nOptions\n\n\n\n\nAppend - Appends text to an existing file or creates file if does not exist.\n\n\nOverwrite - Overwrites an existing file or creates a file if does not exist.\n\n\nRead - Returns a list of strings of all the lines in the file, throws error if file does not exist.\n\n\n\n\n\nCode Produced:\n\n\n\n\nopen(\"filename.txt\", \"a\")\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nBlocklyFile = None\nBlocklyFile = open(\"filename.txt\", \"a\")\n\n\n\n\n\n\n\n\n\nWrite to File\n\n\n\n\nWrites a string of text to the file.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\n.write('' + '\\n')\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nBlocklyFile.write('Some Text' + '\\n')\n\n\n\n\n\n\n\n\n\nClose File\n\n\n\n\nCloses the file and prevents future reading and writing. In Python It is good practice to close files after using them.\n\n\nBlock:\n\n\n\n\nCode Produced:\n\n\n\n\n.close()\n\n\n\n\n\nExample:\n\n\n\n\n\n\nCode:\n\n\n\n\nBlocklyFile.close()\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly File Handling", 
            "title": "File Handling"
        }, 
        {
            "location": "/Blk_File_Handling/#file-handling", 
            "text": "This library allows you to handle file manipulation(reading/writing) using Blockly.  List of available blocks:      Open File  Write to File  Close File", 
            "title": "File Handling"
        }, 
        {
            "location": "/Blk_File_Handling/#open-file", 
            "text": "Searches for the desired filename and returns a file object or list of text.", 
            "title": "Open File"
        }, 
        {
            "location": "/Blk_File_Handling/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_File_Handling/#options", 
            "text": "Append - Appends text to an existing file or creates file if does not exist.  Overwrite - Overwrites an existing file or creates a file if does not exist.  Read - Returns a list of strings of all the lines in the file, throws error if file does not exist.", 
            "title": "Options"
        }, 
        {
            "location": "/Blk_File_Handling/#code-produced", 
            "text": "open(\"filename.txt\", \"a\")", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_File_Handling/#example", 
            "text": "Code:   BlocklyFile = None\nBlocklyFile = open(\"filename.txt\", \"a\")", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_File_Handling/#write-to-file", 
            "text": "Writes a string of text to the file.", 
            "title": "Write to File"
        }, 
        {
            "location": "/Blk_File_Handling/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_File_Handling/#code-produced_1", 
            "text": ".write('' + '\\n')", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_File_Handling/#example_1", 
            "text": "Code:   BlocklyFile.write('Some Text' + '\\n')", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_File_Handling/#close-file", 
            "text": "Closes the file and prevents future reading and writing. In Python It is good practice to close files after using them.", 
            "title": "Close File"
        }, 
        {
            "location": "/Blk_File_Handling/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_File_Handling/#code-produced_2", 
            "text": ".close()", 
            "title": "Code Produced:"
        }, 
        {
            "location": "/Blk_File_Handling/#example_2", 
            "text": "Code:   BlocklyFile.close()", 
            "title": "Example:"
        }, 
        {
            "location": "/Blk_File_Handling/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly File Handling", 
            "title": "Questions?"
        }, 
        {
            "location": "/Default_Logic/", 
            "text": "Logic Conditionals and Comparisons\n\n\n\n\nConditional statements are central to computer programming.  They make it possible to express statements like:\n\n\n\n\nIf there is a path to the left, turn left.\n\n\nIf score = 100, print \"Well done!\".\n\n\n\n\nSee \nadditional information about conditional statements\n.\n\n\nIf blocks\n\n\n\n\nThe simplest conditional statement is an \nif\n block, as shown:\n\n\n\n\nWhen run, this will compare the value of the variable \nx\n to 100.  If it is larger, \"What a big number!\" will be printed.  Otherwise, nothing happens.\n\n\n\n\nIf-Else blocks\n\n\n\n\nIt is also possible to specify that something should happen if the condition is \nnot\n true, as shown in this example:\n\n\n\n\nAs with the previous block, \"What a big number!\" will be printed if \nx\n \n 100; otherwise, \"That's not very big.\" will be printed.\n\n\nAn \nif\n block may have zero or one \nelse\n sections but not more than one.\n\n\n\n\nIf-Else-If blocks\n\n\n\n\nIt is also possible to test multiple conditions with a single \nif\n block by adding \nelse if\n clauses:\n\n\n\n\nThe block first checks if \nx\n \n 100, printing \"What a big number!\" if it is.  If it is not, it goes on to check if \nx\n = 42.  If so, it prints \"That's my lucky number.\"  Otherwise, nothing happens.\n\n\nAn \nif\n block may have any number of \nelse if\n sections.  Conditions are evaluated top to bottom until one is satisfied, or until no more conditions are left.\n\n\n\n\n\nIf-Else-If-Else blocks\n\n\n\n\nAs shown here, \nif\n blocks may have both \nelse if\n and \nelse\n sections:\n\n\n\n\nThe \nelse\n section guarantees that some action is performed, even if none of the prior conditions are true.\n\n\nAn \nelse\n section may occur after any number of \nelse if\n sections, including zero.\n\n\n\n\nBlock Modification\n\n\n\n\nOnly the plain \nif\n block appears in the toolbox:\n\n\n\n\nTo add \nelse if\n and \nelse\n clauses, the user needs to click on the gear icon, which opens a new window:\n\n\n\n\nThe user can then drag \nelse if\n and \nelse\n clauses into the \nif\n block, as well as reordering and removing them.  When finished, the user should click on the minus sign, which closes the window, as shown here:\n\n\n\n\nNote that the shapes of the blocks allows any number of \nelse if\n subblocks to be added but only up to one \nelse\n block.\n\n\n\n\nBoolean\n\n\n\n\nBoolean algebra\n is a mathematical system that has two values:\n\n\n\n\ntrue\n\n\nfalse\n\n\n\n\nBoolean values (also called \nconditions\n) are used in these control block, which contain examples:\n\n\n\n\nconditional blocks\n\n\nrepeat blocks\n\n\n\n\nOne of the many examples from those pages is:\n\n\n\n\nIf the value of the variable \nx\n is greater than 100, the condition is \ntrue\n, and the text \"What a big number!\" is printed.  If the value of \nx\n is not greater than 100, the condition is \nfalse\n, and \"That's not very big.\" is printed.\n\n\nBoolean values can also be stored in variables and passed to procedures, the same as number, text, and list values.\n\n\nIf a block expects a Boolean value as an input, it usually interprets an absent input as \nfalse\n.  An example is provided below.  Non-Boolean values cannot be directly plugged in where Boolean values are expected, although it is possible (but inadvisable) to store a non-Boolean value in a variable, then plug that into the input.  Neither of these practices are recommended, and their behaviour could change in future versions of Blockly.\n\n\n\n\nValues\n\n\n\n\nA single block, with a dropdown specifying either \ntrue\n or \nfalse\n, can be used to get a boolean value:\n\n\n\n\n\n\nComparisons\n\n\n\n\nThere are six comparison operators.  Each takes two inputs (normally numbers) and returns true or false depending on how the inputs compare with each other.\n\n\n\n\nThe six operators are: equals, not equals, less than, less than or equal, greater than, greater than or equal.\n\n\n\n\nLogical Operations\n\n\n\n\nThe \nand\n block will return \ntrue\n only if both of its two inputs are also true.\n\n\n\n\nThe \nor\n block will return \ntrue\n if either of its two inputs are true.\n\n\n\n\n\n\nNot\n\n\n\n\nThe \nnot\n block converts its Boolean input into its opposite.  For example, the result of:\n\n\n\n\nis false.\n\n\nAs mentioned above, if no input is provided, a value of \ntrue\n is assumed, so the following block produces the value \nfalse\n:\n\n\n\n\nLeaving an input empty is not recommended, however.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Blockly Logic", 
            "title": "Logic"
        }, 
        {
            "location": "/Default_Logic/#logic-conditionals-and-comparisons", 
            "text": "Conditional statements are central to computer programming.  They make it possible to express statements like:   If there is a path to the left, turn left.  If score = 100, print \"Well done!\".   See  additional information about conditional statements .", 
            "title": "Logic Conditionals and Comparisons"
        }, 
        {
            "location": "/Default_Logic/#if-blocks", 
            "text": "The simplest conditional statement is an  if  block, as shown:   When run, this will compare the value of the variable  x  to 100.  If it is larger, \"What a big number!\" will be printed.  Otherwise, nothing happens.", 
            "title": "If blocks"
        }, 
        {
            "location": "/Default_Logic/#if-else-blocks", 
            "text": "It is also possible to specify that something should happen if the condition is  not  true, as shown in this example:   As with the previous block, \"What a big number!\" will be printed if  x    100; otherwise, \"That's not very big.\" will be printed.  An  if  block may have zero or one  else  sections but not more than one.", 
            "title": "If-Else blocks"
        }, 
        {
            "location": "/Default_Logic/#if-else-if-blocks", 
            "text": "It is also possible to test multiple conditions with a single  if  block by adding  else if  clauses:   The block first checks if  x    100, printing \"What a big number!\" if it is.  If it is not, it goes on to check if  x  = 42.  If so, it prints \"That's my lucky number.\"  Otherwise, nothing happens.  An  if  block may have any number of  else if  sections.  Conditions are evaluated top to bottom until one is satisfied, or until no more conditions are left.", 
            "title": "If-Else-If blocks"
        }, 
        {
            "location": "/Default_Logic/#if-else-if-else-blocks", 
            "text": "As shown here,  if  blocks may have both  else if  and  else  sections:   The  else  section guarantees that some action is performed, even if none of the prior conditions are true.  An  else  section may occur after any number of  else if  sections, including zero.", 
            "title": "If-Else-If-Else blocks"
        }, 
        {
            "location": "/Default_Logic/#block-modification", 
            "text": "Only the plain  if  block appears in the toolbox:   To add  else if  and  else  clauses, the user needs to click on the gear icon, which opens a new window:   The user can then drag  else if  and  else  clauses into the  if  block, as well as reordering and removing them.  When finished, the user should click on the minus sign, which closes the window, as shown here:   Note that the shapes of the blocks allows any number of  else if  subblocks to be added but only up to one  else  block.", 
            "title": "Block Modification"
        }, 
        {
            "location": "/Default_Logic/#boolean", 
            "text": "Boolean algebra  is a mathematical system that has two values:   true  false   Boolean values (also called  conditions ) are used in these control block, which contain examples:   conditional blocks  repeat blocks   One of the many examples from those pages is:   If the value of the variable  x  is greater than 100, the condition is  true , and the text \"What a big number!\" is printed.  If the value of  x  is not greater than 100, the condition is  false , and \"That's not very big.\" is printed.  Boolean values can also be stored in variables and passed to procedures, the same as number, text, and list values.  If a block expects a Boolean value as an input, it usually interprets an absent input as  false .  An example is provided below.  Non-Boolean values cannot be directly plugged in where Boolean values are expected, although it is possible (but inadvisable) to store a non-Boolean value in a variable, then plug that into the input.  Neither of these practices are recommended, and their behaviour could change in future versions of Blockly.", 
            "title": "Boolean"
        }, 
        {
            "location": "/Default_Logic/#values", 
            "text": "A single block, with a dropdown specifying either  true  or  false , can be used to get a boolean value:", 
            "title": "Values"
        }, 
        {
            "location": "/Default_Logic/#comparisons", 
            "text": "There are six comparison operators.  Each takes two inputs (normally numbers) and returns true or false depending on how the inputs compare with each other.   The six operators are: equals, not equals, less than, less than or equal, greater than, greater than or equal.", 
            "title": "Comparisons"
        }, 
        {
            "location": "/Default_Logic/#logical-operations", 
            "text": "The  and  block will return  true  only if both of its two inputs are also true.   The  or  block will return  true  if either of its two inputs are true.", 
            "title": "Logical Operations"
        }, 
        {
            "location": "/Default_Logic/#not", 
            "text": "The  not  block converts its Boolean input into its opposite.  For example, the result of:   is false.  As mentioned above, if no input is provided, a value of  true  is assumed, so the following block produces the value  false :   Leaving an input empty is not recommended, however.", 
            "title": "Not"
        }, 
        {
            "location": "/Default_Logic/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Blockly Logic", 
            "title": "Questions?"
        }, 
        {
            "location": "/Default_Loops/", 
            "text": "Blocks for Loop Creation\n\n\n\n\nThe \nControl\n category holds blocks that control whether other blocks placed in their \nbody\n are run.  (For example, in the below \"repeat\" block, the body contains the \"print\" block and its input.)  There are two types of control blocks: \nIf-Else\n (described on their own page) and these, which control how many times the body is run and, in some cases, the value of a variable used within the body.  These structures are called \nloops\n since the body is repeated (possibly) multiple times, reminiscent of a rope containing loops.  Each pass through the loop is called an \niteration\n.\n\n\nRepeat\n\n\n\n\nThe simplest \"repeat\" block runs the code in its body the specified number of times.  For example, the following block will print \"Hello!\" ten times.\n\n\n\n\n\n\nRepeat While\n\n\n\n\nImagine a game in which a player rolls a die and adds up all of the values rolled as long as the total is less than 30.  The following blocks implement that game:\n\n\n\n\nA variable named \ntotal\n gets an initial value of 0.\n\n\nThe loop begins with a check that \ntotal\n is less than 30.  If so, the blocks in the body are run.\n\n\nA random number in the range 1 to 6 is generated (simulating a die roll) and stored in a variable named \nroll\n.\n\n\nThe number rolled is printed.\n\n\nThe variable \ntotal\n gets increased by \nroll\n.\n\n\nThe end of the loop having been reached, control goes back to step 2.\n\n\n\n\n\n\nWhen the loop completes, any subsequent blocks (not shown) would be run.  In our example, the loop would end after some number of random numbers in the range 1 to 6 had been printed, and the variable \ntotal\n would hold the sum of these numbers, which would be guaranteed to be at least 30.\n\n\nFor more information, see \nwhile loop\n.\n\n\n\n\nRepeat Until\n\n\n\n\n\"Repeat while\" loops repeat their bodies \nwhile\n some condition is true.  Repeat-until loops are similar except that they repeat their bodies \nuntil\n some condition is true.  The following blocks are equivalent to the previous example because the loop contains until \ntotal\n is greater than or equal to 30.\n\n\n\n\n\n\nCount With\n\n\n\n\nThe \ncount with\n block (called a \nfor loop\n in most programming languages) advances a variable from the first value to the second value by the increment amount (third value), running the body once for each value.  For example, the following program prints the numbers 1, 3, and 5.\n\n\n\n\nAs shown by the two following loops, each of which prints the numbers 5, 3, and 1, the first input may be larger than the second.  The behavior is the same whether the increment amount (third value) is positive or negative.\n\n\n\n\n\n\nFor Each\n\n\n\n\nThe \nfor each\n block (see \nForeach\n) is similar, except instead of giving the loop variable values in a numeric sequence, it uses the values from a list in turn.  The following program prints each element of the list: \"alpha\", \"beta\", \"gamma\".\n\n\n\n\n\n\nLoop Termination Blocks\n\n\n\n\nMost loops run until the terminating condition (in the case of  \nrepeat\n blocks) is met or until all values have been taken by the loop variable (in the case of \ncount with\n and \nfor each\n loops).  Two rarely needed but occasionally useful blocks provide additional means for controlling loop behavior.  Although the below examples are for \nfor each\n loops, they can be used with any type of loop.\n\n\nContinue with next iteration\n\n\n\n\nThe \ncontinue with next iteration\n (called \ncontinue\n in most programming languages) causes the remaining code in the body to be skipped and for the next iteration (pass) of the loop to begin.\n\n\nThe following program prints \"alpha\" on the first iteration of the loop.  On the second iteration, the \ncontinue with next iteration\n block is run, skipping the printing of \"beta\".  On the final iteration, \"gamma\" is printed.\n\n\n\n\n\n\nBreak out of loop\n\n\n\n\nThe \nbreak out of loop\n block provides \nan early exit from a loop\n.  The following program prints \"alpha\" on the first iteration and \"breaks out\" of the loop on the second iteration when the loop variable is equal to \"beta\".  The third item in the list is never reached.\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Blockly Loops", 
            "title": "Loops"
        }, 
        {
            "location": "/Default_Loops/#blocks-for-loop-creation", 
            "text": "The  Control  category holds blocks that control whether other blocks placed in their  body  are run.  (For example, in the below \"repeat\" block, the body contains the \"print\" block and its input.)  There are two types of control blocks:  If-Else  (described on their own page) and these, which control how many times the body is run and, in some cases, the value of a variable used within the body.  These structures are called  loops  since the body is repeated (possibly) multiple times, reminiscent of a rope containing loops.  Each pass through the loop is called an  iteration .", 
            "title": "Blocks for Loop Creation"
        }, 
        {
            "location": "/Default_Loops/#repeat", 
            "text": "The simplest \"repeat\" block runs the code in its body the specified number of times.  For example, the following block will print \"Hello!\" ten times.", 
            "title": "Repeat"
        }, 
        {
            "location": "/Default_Loops/#repeat-while", 
            "text": "Imagine a game in which a player rolls a die and adds up all of the values rolled as long as the total is less than 30.  The following blocks implement that game:   A variable named  total  gets an initial value of 0.  The loop begins with a check that  total  is less than 30.  If so, the blocks in the body are run.  A random number in the range 1 to 6 is generated (simulating a die roll) and stored in a variable named  roll .  The number rolled is printed.  The variable  total  gets increased by  roll .  The end of the loop having been reached, control goes back to step 2.    When the loop completes, any subsequent blocks (not shown) would be run.  In our example, the loop would end after some number of random numbers in the range 1 to 6 had been printed, and the variable  total  would hold the sum of these numbers, which would be guaranteed to be at least 30.  For more information, see  while loop .", 
            "title": "Repeat While"
        }, 
        {
            "location": "/Default_Loops/#repeat-until", 
            "text": "\"Repeat while\" loops repeat their bodies  while  some condition is true.  Repeat-until loops are similar except that they repeat their bodies  until  some condition is true.  The following blocks are equivalent to the previous example because the loop contains until  total  is greater than or equal to 30.", 
            "title": "Repeat Until"
        }, 
        {
            "location": "/Default_Loops/#count-with", 
            "text": "The  count with  block (called a  for loop  in most programming languages) advances a variable from the first value to the second value by the increment amount (third value), running the body once for each value.  For example, the following program prints the numbers 1, 3, and 5.   As shown by the two following loops, each of which prints the numbers 5, 3, and 1, the first input may be larger than the second.  The behavior is the same whether the increment amount (third value) is positive or negative.", 
            "title": "Count With"
        }, 
        {
            "location": "/Default_Loops/#for-each", 
            "text": "The  for each  block (see  Foreach ) is similar, except instead of giving the loop variable values in a numeric sequence, it uses the values from a list in turn.  The following program prints each element of the list: \"alpha\", \"beta\", \"gamma\".", 
            "title": "For Each"
        }, 
        {
            "location": "/Default_Loops/#loop-termination-blocks", 
            "text": "Most loops run until the terminating condition (in the case of   repeat  blocks) is met or until all values have been taken by the loop variable (in the case of  count with  and  for each  loops).  Two rarely needed but occasionally useful blocks provide additional means for controlling loop behavior.  Although the below examples are for  for each  loops, they can be used with any type of loop.", 
            "title": "Loop Termination Blocks"
        }, 
        {
            "location": "/Default_Loops/#continue-with-next-iteration", 
            "text": "The  continue with next iteration  (called  continue  in most programming languages) causes the remaining code in the body to be skipped and for the next iteration (pass) of the loop to begin.  The following program prints \"alpha\" on the first iteration of the loop.  On the second iteration, the  continue with next iteration  block is run, skipping the printing of \"beta\".  On the final iteration, \"gamma\" is printed.", 
            "title": "Continue with next iteration"
        }, 
        {
            "location": "/Default_Loops/#break-out-of-loop", 
            "text": "The  break out of loop  block provides  an early exit from a loop .  The following program prints \"alpha\" on the first iteration and \"breaks out\" of the loop on the second iteration when the loop variable is equal to \"beta\".  The third item in the list is never reached.", 
            "title": "Break out of loop"
        }, 
        {
            "location": "/Default_Loops/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Blockly Loops", 
            "title": "Questions?"
        }, 
        {
            "location": "/Default_Text/", 
            "text": "Text Toolbox\n\n\n\n\nExamples of pieces of text are:  \n\n\n\n\n\"thing #1\"  \n\n\n\"March 12, 2010\"  \n\n\n\"\" (the empty text)  \n\n\n\n\nText can contain letters (which may be lower-case or upper-case), numbers, punctuation marks, other symbols, and blank spaces between words. (The non-Blockly term for all of these different types of text is character.) \n\n\nText creation\n\n\n\n\nThe following block creates the piece of text \"hello\" and stores it in the variable named \ngreeting\n.\n\n\n\n\nThe \ncreate text with\n block combines (concatenates) the value of the \ngreeting\n variable and the new text \"world\" to create the text \"helloworld\".  Note that there is no space between them, since none was in either original text.\n\n\n\n\nTo increase the number of text inputs, click on the gear icon, which changes the view to:\n\n\n\n\nAdditional inputs are added by dragging an \"item\" block from the gray toolbox on the left into the \"join\" block.\n\n\n\n\nText modification\n\n\n\n\nThe \nto...append text\n block adds the given text to the specified variable.  In this case, it changes the value of the variable \ngreeting\n from \"hello\" to \"hello, there!\"\n\n\n\n\n\n\nText length\n\n\n\n\nThe \nlength of\n blocks count the number of letters, numbers, etc., in each text.  The length of \"We're #1!\" is 9, and the length of the empty text is 0.\n\n\n\n\n\n\n\n\nChecking for empty text\n\n\n\n\nThe \nis empty\n block checks whether the given text is empty (has length 0).  The result is \ntrue\n in the first case and \nfalse\n in the second.\n\n\n\n\n\n\n\n\nFinding text\n\n\n\n\nThese blocks can be used to check whether a piece of text is in another piece of text and, if so, where it appears.  For example, this asks for the first occurrence of \"e\" in \"hello\".  The result is 2.\n\n\n\n\nThis asks for the \nlast\n occurrence of \"e\" in \"hello\", which, is also 2.\n\n\n\n\nWhether \nfirst\n or \nlast\n is selected, this block will give the result 0, since \"hello\" does not contain \"z\".\n\n\n\n\n\n\nExtracting text\n\n\n\n\nExtracting a single character\n\n\n\n\nThis gets \"b\", the second letter in \"abcde\":\n\n\n\n\nThis gets \"d\", the second \nto last\n letter in \"abcde\":\n\n\n\n\nThis gets \"a\", the first letter in \"abcde\":\n\n\n\n\nThis gets \"e\", the last letter in \"abcde\":\n\n\n\n\nThis gets any of the 5 letters in \"abcde\" with equal probability:\n\n\n\n\nNone of these modify the text on which the extraction is performed.\n\n\n\n\nExtracting a region of text\n\n\n\n\nThe \nin text...get substring\n block allows a region of text to be extracted, starting with either:\n\n\n\n\nletter #  \n\n\nletter # from end  \n\n\nthe first letter  \n\n\n\n\nand ending with:\n\n\n\n\nletter #  \n\n\nletter # from end  \n\n\nthe last letter  \n\n\n\n\nIn the following example, \"abc\" is extracted.\n\n\n\n\n\n\n\n\nAdjusting text case\n\n\n\n\nThis block creates a version of the input text that is either:\n\n\n\n\nUPPER CASE (all letters upper-case)  \n\n\nlower case  \n\n\nTitle Case (first letters upper-case, other letters lower-case)  \n\n\n\n\nThe result of the following block is \"HELLO\".\n\n\n\n\nNon-alphabetic characters are not affected.  Note that this block on text in languages without case, such as Chinese.\n\n\n\n\nTrimming (removing) spaces\n\n\n\n\nThe following block removes space characters from:\n\n\n\n\nthe beginning of the text  \n\n\nthe end of the text  \n\n\nboth sides of the text  \n\n\n\n\nThe result of the following block is \"hi \n there\".  (Spaces in the middle of the text are not affected.)\n\n\n\n\n\n\nPrinting text\n\n\n\n\nThe \nprint\n block causes the input value to be displayed in a pop-up window, as shown:\n\n\n\n\nIf the code is exported as JavaScript, Python, or Dart, it will be printed to the Program Output.  In no case is it sent to the printer, as the name might suggest.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Blockly Text", 
            "title": "Text"
        }, 
        {
            "location": "/Default_Text/#text-toolbox", 
            "text": "Examples of pieces of text are:     \"thing #1\"    \"March 12, 2010\"    \"\" (the empty text)     Text can contain letters (which may be lower-case or upper-case), numbers, punctuation marks, other symbols, and blank spaces between words. (The non-Blockly term for all of these different types of text is character.)", 
            "title": "Text Toolbox"
        }, 
        {
            "location": "/Default_Text/#text-creation", 
            "text": "The following block creates the piece of text \"hello\" and stores it in the variable named  greeting .   The  create text with  block combines (concatenates) the value of the  greeting  variable and the new text \"world\" to create the text \"helloworld\".  Note that there is no space between them, since none was in either original text.   To increase the number of text inputs, click on the gear icon, which changes the view to:   Additional inputs are added by dragging an \"item\" block from the gray toolbox on the left into the \"join\" block.", 
            "title": "Text creation"
        }, 
        {
            "location": "/Default_Text/#text-modification", 
            "text": "The  to...append text  block adds the given text to the specified variable.  In this case, it changes the value of the variable  greeting  from \"hello\" to \"hello, there!\"", 
            "title": "Text modification"
        }, 
        {
            "location": "/Default_Text/#text-length", 
            "text": "The  length of  blocks count the number of letters, numbers, etc., in each text.  The length of \"We're #1!\" is 9, and the length of the empty text is 0.", 
            "title": "Text length"
        }, 
        {
            "location": "/Default_Text/#checking-for-empty-text", 
            "text": "The  is empty  block checks whether the given text is empty (has length 0).  The result is  true  in the first case and  false  in the second.", 
            "title": "Checking for empty text"
        }, 
        {
            "location": "/Default_Text/#finding-text", 
            "text": "These blocks can be used to check whether a piece of text is in another piece of text and, if so, where it appears.  For example, this asks for the first occurrence of \"e\" in \"hello\".  The result is 2.   This asks for the  last  occurrence of \"e\" in \"hello\", which, is also 2.   Whether  first  or  last  is selected, this block will give the result 0, since \"hello\" does not contain \"z\".", 
            "title": "Finding text"
        }, 
        {
            "location": "/Default_Text/#extracting-text", 
            "text": "", 
            "title": "Extracting text"
        }, 
        {
            "location": "/Default_Text/#extracting-a-single-character", 
            "text": "This gets \"b\", the second letter in \"abcde\":   This gets \"d\", the second  to last  letter in \"abcde\":   This gets \"a\", the first letter in \"abcde\":   This gets \"e\", the last letter in \"abcde\":   This gets any of the 5 letters in \"abcde\" with equal probability:   None of these modify the text on which the extraction is performed.", 
            "title": "Extracting a single character"
        }, 
        {
            "location": "/Default_Text/#extracting-a-region-of-text", 
            "text": "The  in text...get substring  block allows a region of text to be extracted, starting with either:   letter #    letter # from end    the first letter     and ending with:   letter #    letter # from end    the last letter     In the following example, \"abc\" is extracted.", 
            "title": "Extracting a region of text"
        }, 
        {
            "location": "/Default_Text/#adjusting-text-case", 
            "text": "This block creates a version of the input text that is either:   UPPER CASE (all letters upper-case)    lower case    Title Case (first letters upper-case, other letters lower-case)     The result of the following block is \"HELLO\".   Non-alphabetic characters are not affected.  Note that this block on text in languages without case, such as Chinese.", 
            "title": "Adjusting text case"
        }, 
        {
            "location": "/Default_Text/#trimming-removing-spaces", 
            "text": "The following block removes space characters from:   the beginning of the text    the end of the text    both sides of the text     The result of the following block is \"hi   there\".  (Spaces in the middle of the text are not affected.)", 
            "title": "Trimming (removing) spaces"
        }, 
        {
            "location": "/Default_Text/#printing-text", 
            "text": "The  print  block causes the input value to be displayed in a pop-up window, as shown:   If the code is exported as JavaScript, Python, or Dart, it will be printed to the Program Output.  In no case is it sent to the printer, as the name might suggest.", 
            "title": "Printing text"
        }, 
        {
            "location": "/Default_Text/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Blockly Text", 
            "title": "Questions?"
        }, 
        {
            "location": "/Default_Lists/", 
            "text": "Lists Toolbox\n\n\n\n\nAs in everyday speech, a Blockly list is an ordered collection of items, such as a \"to do\" list or a shopping list.  Items in a list may be of any type, and the same value may appear more than once in a list.\n\n\nList Creation\n\n\n\n\ncreate empty list\n\n\nThe simplest list is the empty list, which is created with the \ncreate empty list\n block:\n\n\n\n\ncreate list with\n\n\n\n\nbasic usage\n\n\nThe \ncreate list with\n block allows the user to specify the initial values in a new list.  In this example, a list of words is being created and placed in a variable named \nletters\n:\n\n\n\n\nFor this document, we'll denote this list as [\"alpha\", \"beta\", \"gamma\"], and we will refer below to the variables defined in this section.\n\n\nThis shows the creation of a list of numbers:\n\n\n\n\nThis creates a list of colours:\n\n\n\n\nIt is less common, but possible, to create a list with values of different types:\n\n\n\n\nchanging number of inputs\n\n\nTo change the number of inputs, click on the gear icon.  This opens a new window:\n\n\n\n\nYou can then drag \nitem\n sublocks from the left side of the window into the \nif\n block on the right side to add a new input, as shown:\n\n\n\n\nWhile the new item was added at the bottom in this example, it can be added anywhere.  Similarly, unwanted \nitem\n subblocks can be dragged off the \nif\n block to the left.\n\n\n\n\ncreate list with item\n\n\nThe \ncreate list with item\n block lets you create a list that has the specified number of copies of an item.  For example, the following blocks set the variable \nwords\n to the list containing [\"very\", \"very\", \"very\"].\n\n\n\n\n\n\nChecking a List's Length\n\n\n\n\nis empty\n\n\nThe value of an \nis empty\n block is \ntrue\n if its input is the empty list and \nfalse\n if it is anything else (including a non-list).  IS THIS TRUE?  The value of the following blocks would be \nfalse\n because the variable \ncolours\n is not empty: it has three items.\n\n\n\n\nNote the similarity to the \n\"is empty\" block for text\n.\n\n\nlength of\n\n\nThe value of the \nlength of\n block is the number of elements in the list used as an input.  For example, the value of the following blocks would be 3 because colour has three items.\n\n\n\n\nNote that the \nlength of\n block tells you how many items are in the list, not how many \ndifferent\n items are in it.  For example, the following has the value 3, even though \nwords\n consists of three copies of the same text ([\"very\", \"very\", \"very\"]).\n\n\n\n\nNote the similarity to the \n\"length of\" block for text\n.\n\n\n\n\nFinding Items in a List\n\n\n\n\nThese blocks find the position of an item in a list.  For example, the following has a value of 1 because the first appearance of \"very\" is as the beginning of the \nwords\n list ([\"very\", \"very\", \"very\"]).\n\n\n\n\nThe result of the following is 3 because the last appearance of \"very\" in \nwords\n is in position 3.\n\n\n\n\nIf the item is nowhere in the list, the result is in the value 0, as in this example:\n\n\n\n\nThese blocks are analogous to \nthe ones for finding letters in text\n.\n\n\n\n\nGetting Items from a List\n\n\n\n\nGetting a single item\n\n\nRecall the definition of the list \ncolours\n:\n\n\n\n\nThe following block gets the colour \nfont color='blue'blue\n/font because it is the second element in the list (counting from the beginning on the left):\n\n\n\n\nThis gets \nfont color='green'green\n/font because it is the second element counting from the right end:\n\n\n\nThis gets the first element, \nfont color='red'red\n/font:\n\n\n\n\nThis gets the last element, \nfont color='orange'yellow\n/font:\n\n\n\n\nThis randomly selects an item from the list, returning any of \nfont color='red'red\n/font, \nfont color='blue'blue\n/font, \nfont color='green'green\n/font, or \nfont color='orange'yellow\n/font with equal likelihood.\n\n\n\n\nGetting and removing an item\n\n\nA dropdown menu on the \nin list ... get\n block changes it to \nin list ... get and remove\n, which provides the same otuput but also modifies the original list:\n\n\n\n\nThis example sets the variable \nfirst letter\n to \"alpha\" and leaves \nletters\n as: [\"beta\", \"gamma\"].\n\n\n\n\nRemoving an item\n\n\nSelecting \"remove\" on the dropdown causes the plug on the left of the block to disappear:\n\n\n\n\nThis removes the first item from \nletters\n.\n\n\nGetting a sublist\n\n\nThe \nin list ... get sublist\n block is similar to the \nin list ... get\n block except that it extracts a sublist, rather than an individual item.  There are several options for how the start and end of the sublist can be specified:\n\n\n\n\n\n\nIn this example, a new list \nfirst letters\n is created.  This new list has two elements: [\"alpha\", \"beta\"].\n\n\n\n\nNote that this block does not modify the original list.\n\n\n\n\nAdding Items to a List\n\n\n\n\nin list ... set\n\n\nThe \nin list ... set\n block replaces the item at a specified location in a list with a different item.\n\n\n\n\nFor the meaning of each of the dropdown options, see the \nprevious section\n.\n\n\nThe following example does two things:\n\n  1. The list \nwords\n is created with 3 items: [\"very\", \"very\", \"very\"].\n\n  2. The third item in the list is replaced by \"good\".  The new value of \nwords\n is [\"very\", \"very\", \"good\"].\n\n\n\n\nin list ... insert at\n\n\nThe \nin list ... insert at\n block is obtained by using the dropdown menu on the \nin list ... set\n block:\n\n\n\n\nIt inserts a new item into the list at the specified location, before the item previously at that location.  The following example (built on an earlier one) does three things:\n\n\n\n\nThe list \nwords\n is created with 3 items: [\"very\", \"very\", \"very\"].\n\n\nThe third item in the list is replaced by \"good\".  The new value of \nwords\n is [\"very\", \"very\", \"good\"].\n\n\nThe word \"you're\" is inserted at the beginning of the list.  The final value of \nwords\n is [\"You're\", \"very\", \"very\", \"good\"].\n\n\n\n\n\n\n\n\nSplitting strings and joining lists\n\n\n\n\nmake list from text\n\n\nThe \nmake list from text\n block splits the given text into pieces using a delimiter:\n\n\n\n\nIn the above example, a new list is returned containing three pieces of text: \"311\", \"555\", and \"2368\".\n\n\nmake text from list\n\n\nThe \nmake text from list\n block joins a list into a single text using a delimiter:\n\n\n\n\nIn the above example, a new text is returned with the value: \"311-555-2368\".\n\n\n\n\nRelated Blocks\n\n\n\n\nPrinting a list\n\n\nThe \nprint block\n in the Text category can print lists.  The result of the following program is the shown alert box:\n\n\n\n\nDoing something for each item in a list\n\n\nThe \nfor-each block\n in the Control category performs an operation on every item in a list.  For example, these blocks individually print each item in the list:\n\n\n\n\nThis does not remove the items from the original list.\n\n\nSee also the examples of the \nloop termination blocks\n.\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Blockly Lists", 
            "title": "Lists"
        }, 
        {
            "location": "/Default_Lists/#lists-toolbox", 
            "text": "As in everyday speech, a Blockly list is an ordered collection of items, such as a \"to do\" list or a shopping list.  Items in a list may be of any type, and the same value may appear more than once in a list.", 
            "title": "Lists Toolbox"
        }, 
        {
            "location": "/Default_Lists/#list-creation", 
            "text": "", 
            "title": "List Creation"
        }, 
        {
            "location": "/Default_Lists/#create-empty-list", 
            "text": "The simplest list is the empty list, which is created with the  create empty list  block:", 
            "title": "create empty list"
        }, 
        {
            "location": "/Default_Lists/#create-list-with", 
            "text": "", 
            "title": "create list with"
        }, 
        {
            "location": "/Default_Lists/#basic-usage", 
            "text": "The  create list with  block allows the user to specify the initial values in a new list.  In this example, a list of words is being created and placed in a variable named  letters :   For this document, we'll denote this list as [\"alpha\", \"beta\", \"gamma\"], and we will refer below to the variables defined in this section.  This shows the creation of a list of numbers:   This creates a list of colours:   It is less common, but possible, to create a list with values of different types:", 
            "title": "basic usage"
        }, 
        {
            "location": "/Default_Lists/#changing-number-of-inputs", 
            "text": "To change the number of inputs, click on the gear icon.  This opens a new window:   You can then drag  item  sublocks from the left side of the window into the  if  block on the right side to add a new input, as shown:   While the new item was added at the bottom in this example, it can be added anywhere.  Similarly, unwanted  item  subblocks can be dragged off the  if  block to the left.", 
            "title": "changing number of inputs"
        }, 
        {
            "location": "/Default_Lists/#create-list-with-item", 
            "text": "The  create list with item  block lets you create a list that has the specified number of copies of an item.  For example, the following blocks set the variable  words  to the list containing [\"very\", \"very\", \"very\"].", 
            "title": "create list with item"
        }, 
        {
            "location": "/Default_Lists/#checking-a-lists-length", 
            "text": "", 
            "title": "Checking a List's Length"
        }, 
        {
            "location": "/Default_Lists/#is-empty", 
            "text": "The value of an  is empty  block is  true  if its input is the empty list and  false  if it is anything else (including a non-list).  IS THIS TRUE?  The value of the following blocks would be  false  because the variable  colours  is not empty: it has three items.   Note the similarity to the  \"is empty\" block for text .", 
            "title": "is empty"
        }, 
        {
            "location": "/Default_Lists/#length-of", 
            "text": "The value of the  length of  block is the number of elements in the list used as an input.  For example, the value of the following blocks would be 3 because colour has three items.   Note that the  length of  block tells you how many items are in the list, not how many  different  items are in it.  For example, the following has the value 3, even though  words  consists of three copies of the same text ([\"very\", \"very\", \"very\"]).   Note the similarity to the  \"length of\" block for text .", 
            "title": "length of"
        }, 
        {
            "location": "/Default_Lists/#finding-items-in-a-list", 
            "text": "These blocks find the position of an item in a list.  For example, the following has a value of 1 because the first appearance of \"very\" is as the beginning of the  words  list ([\"very\", \"very\", \"very\"]).   The result of the following is 3 because the last appearance of \"very\" in  words  is in position 3.   If the item is nowhere in the list, the result is in the value 0, as in this example:   These blocks are analogous to  the ones for finding letters in text .", 
            "title": "Finding Items in a List"
        }, 
        {
            "location": "/Default_Lists/#getting-items-from-a-list", 
            "text": "", 
            "title": "Getting Items from a List"
        }, 
        {
            "location": "/Default_Lists/#getting-a-single-item", 
            "text": "Recall the definition of the list  colours :   The following block gets the colour  font color='blue'blue /font because it is the second element in the list (counting from the beginning on the left):   This gets  font color='green'green /font because it is the second element counting from the right end:  This gets the first element,  font color='red'red /font:   This gets the last element,  font color='orange'yellow /font:   This randomly selects an item from the list, returning any of  font color='red'red /font,  font color='blue'blue /font,  font color='green'green /font, or  font color='orange'yellow /font with equal likelihood.", 
            "title": "Getting a single item"
        }, 
        {
            "location": "/Default_Lists/#getting-and-removing-an-item", 
            "text": "A dropdown menu on the  in list ... get  block changes it to  in list ... get and remove , which provides the same otuput but also modifies the original list:   This example sets the variable  first letter  to \"alpha\" and leaves  letters  as: [\"beta\", \"gamma\"].", 
            "title": "Getting and removing an item"
        }, 
        {
            "location": "/Default_Lists/#removing-an-item", 
            "text": "Selecting \"remove\" on the dropdown causes the plug on the left of the block to disappear:   This removes the first item from  letters .", 
            "title": "Removing an item"
        }, 
        {
            "location": "/Default_Lists/#getting-a-sublist", 
            "text": "The  in list ... get sublist  block is similar to the  in list ... get  block except that it extracts a sublist, rather than an individual item.  There are several options for how the start and end of the sublist can be specified:    In this example, a new list  first letters  is created.  This new list has two elements: [\"alpha\", \"beta\"].   Note that this block does not modify the original list.", 
            "title": "Getting a sublist"
        }, 
        {
            "location": "/Default_Lists/#adding-items-to-a-list", 
            "text": "", 
            "title": "Adding Items to a List"
        }, 
        {
            "location": "/Default_Lists/#in-list-set", 
            "text": "The  in list ... set  block replaces the item at a specified location in a list with a different item.   For the meaning of each of the dropdown options, see the  previous section .  The following example does two things: \n  1. The list  words  is created with 3 items: [\"very\", \"very\", \"very\"]. \n  2. The third item in the list is replaced by \"good\".  The new value of  words  is [\"very\", \"very\", \"good\"].", 
            "title": "in list ... set"
        }, 
        {
            "location": "/Default_Lists/#in-list-insert-at", 
            "text": "The  in list ... insert at  block is obtained by using the dropdown menu on the  in list ... set  block:   It inserts a new item into the list at the specified location, before the item previously at that location.  The following example (built on an earlier one) does three things:   The list  words  is created with 3 items: [\"very\", \"very\", \"very\"].  The third item in the list is replaced by \"good\".  The new value of  words  is [\"very\", \"very\", \"good\"].  The word \"you're\" is inserted at the beginning of the list.  The final value of  words  is [\"You're\", \"very\", \"very\", \"good\"].", 
            "title": "in list ... insert at"
        }, 
        {
            "location": "/Default_Lists/#splitting-strings-and-joining-lists", 
            "text": "", 
            "title": "Splitting strings and joining lists"
        }, 
        {
            "location": "/Default_Lists/#make-list-from-text", 
            "text": "The  make list from text  block splits the given text into pieces using a delimiter:   In the above example, a new list is returned containing three pieces of text: \"311\", \"555\", and \"2368\".", 
            "title": "make list from text"
        }, 
        {
            "location": "/Default_Lists/#make-text-from-list", 
            "text": "The  make text from list  block joins a list into a single text using a delimiter:   In the above example, a new text is returned with the value: \"311-555-2368\".", 
            "title": "make text from list"
        }, 
        {
            "location": "/Default_Lists/#related-blocks", 
            "text": "", 
            "title": "Related Blocks"
        }, 
        {
            "location": "/Default_Lists/#printing-a-list", 
            "text": "The  print block  in the Text category can print lists.  The result of the following program is the shown alert box:", 
            "title": "Printing a list"
        }, 
        {
            "location": "/Default_Lists/#doing-something-for-each-item-in-a-list", 
            "text": "The  for-each block  in the Control category performs an operation on every item in a list.  For example, these blocks individually print each item in the list:   This does not remove the items from the original list.  See also the examples of the  loop termination blocks .", 
            "title": "Doing something for each item in a list"
        }, 
        {
            "location": "/Default_Lists/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Blockly Lists", 
            "title": "Questions?"
        }, 
        {
            "location": "/Default_Variables/", 
            "text": "Variables\n\n\n\n\nWe use the term \nvariable\n the same as it is used in mathematics and in other programming languages: a named value that can be changed (varies).  \n\n\nVariables can be created in several different ways.\n\n\n\n\nEvery \ncount with\n and \nfor each\n block uses a variable and defines its values.  These values can only be used within the block.  A traditional computer science term for these are loop variables.\n\n\nUser-defined functions (also known as \"procedures\") can define inputs, which creates variables that can be used only within the function.  These are traditionally called \"parameters\" or \"arguments\".\n\n\nUsers may create variables at any time through the \"set\" block.  These are traditionally called \"global variables\".\n\n\nBlockly does not support local variables.\n\n\n\n\nDefault Names\n\n\nWhile users can choose any name for a variable, core Blockly provides a default name, \"item\", as shown in the below picture.  Some applications provide other default values, such as \"value\", also shown below.\n\n\nDropdown Menu\n\n\n\n\nClicking on a variable's dropdown symbol (triangle) gives the following menu:\n\n\n\n\nThe menu provides the following options.\n\n\n\n\nThe names of all variables defined in the program.\n\n\n\"Rename variable...\", which changes the name of this variable wherever it appears in the program.  Selecting this opens a small window that prompts the user for the new name with the text: \"Rename all %1 variables to:\", where %1 is replaced by the old name (here \"item\").\n\n\n\"New variable...\", which enables the user to enter a new name for the variable, without replacing or changing variables with the old name (here \"item\").  Selecting this opens a small window that prompts the user for the new name with the text \"New variable name:\".\n\n\n\n\n\n\nSet Variable\n\n\n\n\nThe \nset\n block assigns a value to a variable, creating the variable if it doesn't already exist.  For example, this sets the value of the variable named \"age\" to 12.\n\n\n\n\n\n\nGet Variable\n\n\n\n\nThe \nget\n block provides the value stored in a variable, without changing it.\n\n\n\n\nIt is possible, but a bad idea, to write a program in which a \nget\n appears without a corresponding \nset\n.\n\n\n\n\nExample\n\n\n\n\nConsider the following example code:\n\n\n\n\nThe first row of blocks creates a variable named \"age\" and sets its initial value to the number 12.  The second row of blocks gets the value 12, adds 1 to it, and stores the sum (13) into the variable.  The final row displays the message: \"Happy birthday!  You are now 13\"\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Blockly Variables", 
            "title": "Variables"
        }, 
        {
            "location": "/Default_Variables/#variables", 
            "text": "We use the term  variable  the same as it is used in mathematics and in other programming languages: a named value that can be changed (varies).    Variables can be created in several different ways.   Every  count with  and  for each  block uses a variable and defines its values.  These values can only be used within the block.  A traditional computer science term for these are loop variables.  User-defined functions (also known as \"procedures\") can define inputs, which creates variables that can be used only within the function.  These are traditionally called \"parameters\" or \"arguments\".  Users may create variables at any time through the \"set\" block.  These are traditionally called \"global variables\".  Blockly does not support local variables.", 
            "title": "Variables"
        }, 
        {
            "location": "/Default_Variables/#default-names", 
            "text": "While users can choose any name for a variable, core Blockly provides a default name, \"item\", as shown in the below picture.  Some applications provide other default values, such as \"value\", also shown below.", 
            "title": "Default Names"
        }, 
        {
            "location": "/Default_Variables/#dropdown-menu", 
            "text": "Clicking on a variable's dropdown symbol (triangle) gives the following menu:   The menu provides the following options.   The names of all variables defined in the program.  \"Rename variable...\", which changes the name of this variable wherever it appears in the program.  Selecting this opens a small window that prompts the user for the new name with the text: \"Rename all %1 variables to:\", where %1 is replaced by the old name (here \"item\").  \"New variable...\", which enables the user to enter a new name for the variable, without replacing or changing variables with the old name (here \"item\").  Selecting this opens a small window that prompts the user for the new name with the text \"New variable name:\".", 
            "title": "Dropdown Menu"
        }, 
        {
            "location": "/Default_Variables/#set-variable", 
            "text": "The  set  block assigns a value to a variable, creating the variable if it doesn't already exist.  For example, this sets the value of the variable named \"age\" to 12.", 
            "title": "Set Variable"
        }, 
        {
            "location": "/Default_Variables/#get-variable", 
            "text": "The  get  block provides the value stored in a variable, without changing it.   It is possible, but a bad idea, to write a program in which a  get  appears without a corresponding  set .", 
            "title": "Get Variable"
        }, 
        {
            "location": "/Default_Variables/#example", 
            "text": "Consider the following example code:   The first row of blocks creates a variable named \"age\" and sets its initial value to the number 12.  The second row of blocks gets the value 12, adds 1 to it, and stores the sum (13) into the variable.  The final row displays the message: \"Happy birthday!  You are now 13\"", 
            "title": "Example"
        }, 
        {
            "location": "/Default_Variables/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Blockly Variables", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Constants/", 
            "text": "Constants\n\n\n\n\nLED Attributes\n\n\n\n\nYELLOW\n = 0x00\n\n\nBLUE\n = 0x01\n\n\n\n\nDigital Attributes\n\n\n\n\nINPUT\n = 0x00\n\n\nOUTPUT\n = 0x01\n\n\n\n\nDigital Ports\n\n\n\n\nD0\n = 0x0001\n\n\nD1\n = 0x0002\n\n\nD2\n = 0x0004\n\n\nD3\n = 0x0008\n\n\nD4\n = 0x0010\n\n\nD5\n = 0x0020\n\n\nD6\n = 0x0040\n\n\nD7\n = 0x0080 \n\n\n\n\nAnalog Ports\n\n\n\n\nA0\n = 0x0101\n\n\nA1\n = 0x0102\n\n\nA2\n = 0x0104\n\n\nA3\n = 0x0108\n\n\nA4\n = 0x0110\n\n\nA5\n = 0x0120\n\n\nA6\n = 0x0140\n\n\nA7\n = 0x0180 \n\n\n\n\nI2C Attributes\n\n\n\n\ni2cError\n = None\n\n\n\n\nMotor Attributes\n\n\n\n\nFLOAT\n = 0x00\n\n\nBRAKE\n = 0x01\n\n\n\n\nMotor Ports\n\n\n\n\nM0\n = 0x01\n\n\nM1\n = 0x02\n\n\n\n\nServo Attributes\n\n\n\n\nENABLE\n = 0x01\n\n\nDISABLE\n = 0x00\n\n\n\n\nServo Ports\n\n\n\n\nS0\n = 0x01\n\n\nS1\n = 0x02\n\n\nS2\n = 0x04\n\n\nS3\n = 0x08\n\n\n\n\nSound Generator\n\n\n\n\nLOW\n = 0x00\n\n\nMED\n = 0x01\n\n\nHIGH\n = 0x02\n\n\nMAX\n = 0x03\n\n\n\n\nColor Sensor\n\n\n\n\nACTIVE\n = 0x00\n\n\nPASSIVE\n = 0x01\n\n\nFIFTY_HZ\n = 0x35\n\n\nSIXTY_HZ\n = 0x36", 
            "title": "Constants"
        }, 
        {
            "location": "/Py_Constants/#constants", 
            "text": "", 
            "title": "Constants"
        }, 
        {
            "location": "/Py_Constants/#led-attributes", 
            "text": "YELLOW  = 0x00  BLUE  = 0x01", 
            "title": "LED Attributes"
        }, 
        {
            "location": "/Py_Constants/#digital-attributes", 
            "text": "INPUT  = 0x00  OUTPUT  = 0x01", 
            "title": "Digital Attributes"
        }, 
        {
            "location": "/Py_Constants/#digital-ports", 
            "text": "D0  = 0x0001  D1  = 0x0002  D2  = 0x0004  D3  = 0x0008  D4  = 0x0010  D5  = 0x0020  D6  = 0x0040  D7  = 0x0080", 
            "title": "Digital Ports"
        }, 
        {
            "location": "/Py_Constants/#analog-ports", 
            "text": "A0  = 0x0101  A1  = 0x0102  A2  = 0x0104  A3  = 0x0108  A4  = 0x0110  A5  = 0x0120  A6  = 0x0140  A7  = 0x0180", 
            "title": "Analog Ports"
        }, 
        {
            "location": "/Py_Constants/#i2c-attributes", 
            "text": "i2cError  = None", 
            "title": "I2C Attributes"
        }, 
        {
            "location": "/Py_Constants/#motor-attributes", 
            "text": "FLOAT  = 0x00  BRAKE  = 0x01", 
            "title": "Motor Attributes"
        }, 
        {
            "location": "/Py_Constants/#motor-ports", 
            "text": "M0  = 0x01  M1  = 0x02", 
            "title": "Motor Ports"
        }, 
        {
            "location": "/Py_Constants/#servo-attributes", 
            "text": "ENABLE  = 0x01  DISABLE  = 0x00", 
            "title": "Servo Attributes"
        }, 
        {
            "location": "/Py_Constants/#servo-ports", 
            "text": "S0  = 0x01  S1  = 0x02  S2  = 0x04  S3  = 0x08", 
            "title": "Servo Ports"
        }, 
        {
            "location": "/Py_Constants/#sound-generator", 
            "text": "LOW  = 0x00  MED  = 0x01  HIGH  = 0x02  MAX  = 0x03", 
            "title": "Sound Generator"
        }, 
        {
            "location": "/Py_Constants/#color-sensor", 
            "text": "ACTIVE  = 0x00  PASSIVE  = 0x01  FIFTY_HZ  = 0x35  SIXTY_HZ  = 0x36", 
            "title": "Color Sensor"
        }, 
        {
            "location": "/Py_Driver/", 
            "text": "Fusion Driver\n\n\n\n\nThe Fusion Driver Class contains code for base controller functionality, LED control, motor controller, servo control and generic analog/digital control functions. \n\n\nList of available functions:\n  \n\n\n\n\nFusion.driver()\n  \n\n\nreadBattRaw()\n\n\nreadBatt()\n\n\nsetLED(\nled\n, \nvalue\n)\n\n\nanalogRead(\nport\n)\n\n\ndigitalRead(\nport\n)\n\n\ndigitalState(\nport\n, \nstate\n)\n\n\ndigitalWrite(\nport\n, \nstate\n)\n\n\ni2cRead(\naddr\n, \nreg\n, \nlen\n)\n\n\ni2cWrite(\naddr\n, \nreg\n, \nbuf[]\n)\n\n\n\n\nFusion.driver()\n\n\n\n\nDefinition\n\n\n\n\nThe following class is used to provide base functionality of the Fusion control board and provide drivers to interface with the various array of sensors, servos and motors.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nFusion Driver Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\n\n\n\n\n\n\n\nreadBattRaw()\n\n\n\n\nDefinition\n\n\n\n\nRead the raw value of the battery voltage from the on-board ADC converter.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nRaw Voltage\n : int (0 - 1023)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nprint f.readBattRaw()\n\n\n\n\n\n\n\nreadBatt()\n\n\n\n\nDefinition\n\n\n\n\nRead the scaled value of the battery voltage from the on-board ADC converter.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nVoltage\n : float (volts)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nprint f.readBatt()\n\n\n\n\n\n\n\nsetLED(\nled\n, \nvalue\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the selected on-board LED or \nON\n (1) or \nOFF\n (0).\n\n\n\n\nSet LED Visual Programming Block\n\n\n\n\n\n\nParameters\n\n\n\n\nled\n : BLUE or YELLOW\n\n\nvalue\n : int (1 or 0)\n\n\nReturns\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.setLED(f.YELLOW, 1)\n\n\n\n\n\n\n\nanalogRead( \nport\n )\n\n\n\n\nDefinition\n\n\n\n\nUsed to read analog devices connected to ports \nA0\n - \nA7\n.\n\n\n\n\nParameters\n\n\n\n\nport\n : A0 - A7\n\n\n\n\nReturns\n\n\n\n\nValue\n : int (0 - 1023)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nprint f.analogRead(f.A0)\n\n\n\n\n\n\n\ndigitalRead(\nport\n)\n\n\n\n\nDefinition\n\n\n\n\nUsed to read digital devices connected to ports \nD0\n - \nD7\n.\n\n\n\n\nParameters\n\n\n\n\nport\n : D0 - D7\n\n\n\n\nReturns\n\n\n\n\nValue\n : int (0 - 1)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nprint f.digitalRead(f.D0)\n\n\n\n\n\n\n\ndigitalState(\nport\n, \nstate\n)\n\n\n\n\nDefinition\n\n\n\n\nSets the state of the selected digital port \nD0\n - \nD7\n as input or output.\n\n\n\n\nParameters\n\n\n\n\nport\n : D0 - D7\n\n\nstate\n : INPUT or OUTPUT\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.digitalState(f.D0, f.OUTPUT)\n\n\n\n\n\n\n\ndigitalWrite(\nport\n, \nstate\n)\n\n\n\n\nDefinition\n\n\n\n\nSets the value of the selected digital port \nD0\n - \nD7\n when in output mode.\n\n\n\n\nParameters\n\n\n\n\nport\n : D0 - D7\n\n\nstate\n : int (1 or 0)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.digitalState(f.D0, f.OUTPUT)\nf.digitalWrite(f.D0, 1)\n\n\n\n\n\n\n\ni2cRead(\naddr\n, \nreg\n, \nlen\n)\n\n\n\n\nDefinition\n\n\n\n\nRead up to 32 bytes from a device on the I2C buffer.\n\n\n\n\nParameters\n\n\n\n\naddr\n : Device I2C Address\n\n\nreg\n : First register to read from\n\n\nlen\n : Number of registers to read\n\n\n\n\nReturns\n\n\n\n\nbuf[reg1, reg2, ...]\n\n\ni2c_error\n : A global value can be read or cleared at any time, displays errors detected during the last I2C transaction. \n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nprint f.i2cRead(0x20, 0x00, 3)\n\n\n\n\n\n\n\ni2cWrite(\naddr\n, \nreg\n, \nbuf[ ]\n )\n\n\n\n\nDefinition\n\n\n\n\nWrite a buffer of up to 32 bytes to a device on the I2C buffer. The length is determined based on the length of the buffer being written.\n\n\n\n\nParameters\n\n\n\n\naddr\n : Device I2C Address\n\n\nreg\n : First register to read from\n\n\nbuf[]\n : Buffer of up to 32 bytes\n\n\n\n\nReturns\n\n\n\n\ni2c_error\n : A global value can be read or cleared at any time, displays errors detected during the last I2C transaction. \n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nbuf = [1, 2]\nf.i2cWrite(0x20, 0x00, buf)\nf.i2cWrite(0x20, 0x02, [3, 4])\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Driver", 
            "title": "Fusion Driver"
        }, 
        {
            "location": "/Py_Driver/#fusion-driver", 
            "text": "The Fusion Driver Class contains code for base controller functionality, LED control, motor controller, servo control and generic analog/digital control functions.   List of available functions:      Fusion.driver()     readBattRaw()  readBatt()  setLED( led ,  value )  analogRead( port )  digitalRead( port )  digitalState( port ,  state )  digitalWrite( port ,  state )  i2cRead( addr ,  reg ,  len )  i2cWrite( addr ,  reg ,  buf[] )", 
            "title": "Fusion Driver"
        }, 
        {
            "location": "/Py_Driver/#fusiondriver", 
            "text": "", 
            "title": "Fusion.driver()"
        }, 
        {
            "location": "/Py_Driver/#definition", 
            "text": "The following class is used to provide base functionality of the Fusion control board and provide drivers to interface with the various array of sensors, servos and motors.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns", 
            "text": "Fusion Driver Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example", 
            "text": "import Fusion\nf = Fusion.driver()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#readbattraw", 
            "text": "", 
            "title": "readBattRaw()"
        }, 
        {
            "location": "/Py_Driver/#definition_1", 
            "text": "Read the raw value of the battery voltage from the on-board ADC converter.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_1", 
            "text": "Raw Voltage  : int (0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nprint f.readBattRaw()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#readbatt", 
            "text": "", 
            "title": "readBatt()"
        }, 
        {
            "location": "/Py_Driver/#definition_2", 
            "text": "Read the scaled value of the battery voltage from the on-board ADC converter.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_2", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_2", 
            "text": "Voltage  : float (volts)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\nprint f.readBatt()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#setledled-value", 
            "text": "", 
            "title": "setLED(led, value)"
        }, 
        {
            "location": "/Py_Driver/#definition_3", 
            "text": "Set the selected on-board LED or  ON  (1) or  OFF  (0).   Set LED Visual Programming Block", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_3", 
            "text": "led  : BLUE or YELLOW  value  : int (1 or 0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_3", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_3", 
            "text": "import Fusion\nf = Fusion.driver()\nf.setLED(f.YELLOW, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#analogread-port", 
            "text": "", 
            "title": "analogRead( port )"
        }, 
        {
            "location": "/Py_Driver/#definition_4", 
            "text": "Used to read analog devices connected to ports  A0  -  A7 .", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_4", 
            "text": "port  : A0 - A7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_4", 
            "text": "Value  : int (0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_4", 
            "text": "import Fusion\nf = Fusion.driver()\nprint f.analogRead(f.A0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#digitalreadport", 
            "text": "", 
            "title": "digitalRead(port)"
        }, 
        {
            "location": "/Py_Driver/#definition_5", 
            "text": "Used to read digital devices connected to ports  D0  -  D7 .", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_5", 
            "text": "port  : D0 - D7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_5", 
            "text": "Value  : int (0 - 1)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_5", 
            "text": "import Fusion\nf = Fusion.driver()\nprint f.digitalRead(f.D0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#digitalstateport-state", 
            "text": "", 
            "title": "digitalState(port, state)"
        }, 
        {
            "location": "/Py_Driver/#definition_6", 
            "text": "Sets the state of the selected digital port  D0  -  D7  as input or output.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_6", 
            "text": "port  : D0 - D7  state  : INPUT or OUTPUT", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_6", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_6", 
            "text": "import Fusion\nf = Fusion.driver()\nf.digitalState(f.D0, f.OUTPUT)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#digitalwriteport-state", 
            "text": "", 
            "title": "digitalWrite(port, state)"
        }, 
        {
            "location": "/Py_Driver/#definition_7", 
            "text": "Sets the value of the selected digital port  D0  -  D7  when in output mode.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_7", 
            "text": "port  : D0 - D7  state  : int (1 or 0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_7", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_7", 
            "text": "import Fusion\nf = Fusion.driver()\nf.digitalState(f.D0, f.OUTPUT)\nf.digitalWrite(f.D0, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#i2creadaddr-reg-len", 
            "text": "", 
            "title": "i2cRead(addr, reg, len)"
        }, 
        {
            "location": "/Py_Driver/#definition_8", 
            "text": "Read up to 32 bytes from a device on the I2C buffer.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_8", 
            "text": "addr  : Device I2C Address  reg  : First register to read from  len  : Number of registers to read", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_8", 
            "text": "buf[reg1, reg2, ...]  i2c_error  : A global value can be read or cleared at any time, displays errors detected during the last I2C transaction.", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_8", 
            "text": "import Fusion\nf = Fusion.driver()\nprint f.i2cRead(0x20, 0x00, 3)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#i2cwriteaddr-reg-buf", 
            "text": "", 
            "title": "i2cWrite(addr, reg, buf[ ] )"
        }, 
        {
            "location": "/Py_Driver/#definition_9", 
            "text": "Write a buffer of up to 32 bytes to a device on the I2C buffer. The length is determined based on the length of the buffer being written.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Driver/#parameters_9", 
            "text": "addr  : Device I2C Address  reg  : First register to read from  buf[]  : Buffer of up to 32 bytes", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Driver/#returns_9", 
            "text": "i2c_error  : A global value can be read or cleared at any time, displays errors detected during the last I2C transaction.", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Driver/#example_9", 
            "text": "import Fusion\nf = Fusion.driver()\nbuf = [1, 2]\nf.i2cWrite(0x20, 0x00, buf)\nf.i2cWrite(0x20, 0x02, [3, 4])", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Driver/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Driver", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Motors/", 
            "text": "Fusion Motors\n\n\n\n\nUsing the \nFusion Driver Class\n, this section outlines the available functions for the motor ports. \n\n\nMotor Visual Programming Blocks\n  \n\n\nList of available functions:\n  \n\n\n\n\nmotorMode(\nmotor\n, \nmode\n)\n\n\nmotorSpeed(\nmotor\n, \nspeed\n)\n\n\n\n\nmotorMode(\nmotor\n, \nmode\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the stop mode of the motor on the selected port. \n\n\n\n\nDefault value is \nFLOAT\n.\n\n\nFLOAT\n : Motors spin freely when a value of \n0\n is applied.\n\n\nBRAKE\n : Motors are held in once place when a value of \n0\n is applied.\n\n\n\n\n\n\nParameters\n\n\n\n\nmotor\n : M0 or M1\n\n\nmode\n : FLOAT or BRAKE\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.motorMode(f.M0, f.FLOAT)\n\n\n\nor\n\n\nimport Fusion\nf = Fusion.driver()\nf.motorMode(f.M0+f.M1, f.BRAKE)\n\n\n\n\n\n\n\nmotorSpeed(\nmotor\n, \nspeed\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the speed of the motor on the selected port.\n\n\n\n\nParameters\n\n\n\n\nmotor\n : M0 or M1\n\n\nspeed\n : int (\u00b1100)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.motorSpeed(f.M0, 100)\nf.motorSpeed(f.M1, -100)\n\n\n\nor\n\n\nimport Fusion\nf = Fusion.driver()\nf.motorSpeed(f.M0+f.M1, 100)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Motors", 
            "title": "Motors"
        }, 
        {
            "location": "/Py_Motors/#fusion-motors", 
            "text": "Using the  Fusion Driver Class , this section outlines the available functions for the motor ports.   Motor Visual Programming Blocks     List of available functions:      motorMode( motor ,  mode )  motorSpeed( motor ,  speed )", 
            "title": "Fusion Motors"
        }, 
        {
            "location": "/Py_Motors/#motormodemotor-mode", 
            "text": "", 
            "title": "motorMode(motor, mode)"
        }, 
        {
            "location": "/Py_Motors/#definition", 
            "text": "Set the stop mode of the motor on the selected port.    Default value is  FLOAT .  FLOAT  : Motors spin freely when a value of  0  is applied.  BRAKE  : Motors are held in once place when a value of  0  is applied.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Motors/#parameters", 
            "text": "motor  : M0 or M1  mode  : FLOAT or BRAKE", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Motors/#returns", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Motors/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nf.motorMode(f.M0, f.FLOAT)  or  import Fusion\nf = Fusion.driver()\nf.motorMode(f.M0+f.M1, f.BRAKE)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Motors/#motorspeedmotor-speed", 
            "text": "", 
            "title": "motorSpeed(motor, speed)"
        }, 
        {
            "location": "/Py_Motors/#definition_1", 
            "text": "Set the speed of the motor on the selected port.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Motors/#parameters_1", 
            "text": "motor  : M0 or M1  speed  : int (\u00b1100)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Motors/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Motors/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nf.motorSpeed(f.M0, 100)\nf.motorSpeed(f.M1, -100)  or  import Fusion\nf = Fusion.driver()\nf.motorSpeed(f.M0+f.M1, 100)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Motors/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Motors", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Servos/", 
            "text": "Fusion Servos\n\n\n\n\nUsing the \nFusion Driver Class\n, this section outlines the Fusion servos and their functions. \n\n\nServo Visual Programming Blocks\n\n\nList of available functions:\n  \n\n\n\n\nservoEnable(\nservo\n, \nstate\n, \nextended\n)\n\n\nservoTarget(\nservo\n, \ntarget\n)\n\n\n\n\nservoEnable(\nservo\n, \nstate\n, \nextended\n)\n\n\n\n\nDefinition\n\n\n\n\nEnable or disable the Pulse Width Modulation (PWM) of the selected port. \n\n\n\n\nParameters\n\n\n\n\nservo\n : S0 - S3\n\n\nstate\n : int (0 or 1)\n\n\nextended\n : bool (True / Flase)  \n\n\n\n\nExtends the servo range by modifying the limits of the PWM signal.  \n\n\nFalse\n = 750\u00b5s - 2250\u00b5s (\nDefault\n)  \n\n\nTrue\n = 500\u00b5s - 2500\u00b5s\n\n\nBe careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.\n\n\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.servoEnable(f.S0, 1)\nf.servoEnable(f.S1, 1, True)\nf.servoEnable(f.S2+f.S3, 1)\n\n\n\n\n\n\n\nservoTarget(\nservo\n, \ntarget\n)\n\n\n\n\nDefinition\n\n\n\n\nSets the target position of the servo on the selected port.\n\n\n\n\nParameters\n\n\n\n\nservo\n : S0 - S3\n\n\ntarget\n : int (0 - 255) (\nDefault\n 128 when enabled) \n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nf.servoTarget(f.S0, 10)\nf.servoTarget(f.S1, 245)\nf.servoTarget(f.S2+f.S3, 128)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Servos", 
            "title": "Servos"
        }, 
        {
            "location": "/Py_Servos/#fusion-servos", 
            "text": "Using the  Fusion Driver Class , this section outlines the Fusion servos and their functions.   Servo Visual Programming Blocks  List of available functions:      servoEnable( servo ,  state ,  extended )  servoTarget( servo ,  target )", 
            "title": "Fusion Servos"
        }, 
        {
            "location": "/Py_Servos/#servoenableservo-state-extended", 
            "text": "", 
            "title": "servoEnable(servo, state, extended)"
        }, 
        {
            "location": "/Py_Servos/#definition", 
            "text": "Enable or disable the Pulse Width Modulation (PWM) of the selected port.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Servos/#parameters", 
            "text": "servo  : S0 - S3  state  : int (0 or 1)  extended  : bool (True / Flase)     Extends the servo range by modifying the limits of the PWM signal.    False  = 750\u00b5s - 2250\u00b5s ( Default )    True  = 500\u00b5s - 2500\u00b5s  Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Servos/#returns", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Servos/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nf.servoEnable(f.S0, 1)\nf.servoEnable(f.S1, 1, True)\nf.servoEnable(f.S2+f.S3, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Servos/#servotargetservo-target", 
            "text": "", 
            "title": "servoTarget(servo, target)"
        }, 
        {
            "location": "/Py_Servos/#definition_1", 
            "text": "Sets the target position of the servo on the selected port.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Servos/#parameters_1", 
            "text": "servo  : S0 - S3  target  : int (0 - 255) ( Default  128 when enabled)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Servos/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Servos/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nf.servoTarget(f.S0, 10)\nf.servoTarget(f.S1, 245)\nf.servoTarget(f.S2+f.S3, 128)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Servos/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Servos", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_usbGamepad/", 
            "text": "USB Gamepad\n\n\n\n\nThis library allows you to connect a wired or wireless USB gamepad to the Fusion for control.\n\n\n\n\nUSB Gamepad Visual Programming Blocks\n\n\nUSB Gamepad Button Mapping\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.usbGamepad(\npad_num\n)\n\n\nreadAxis(\naxis\n, \ninv\n)\n\n\nreadAxisFloat(\naxis\n, \ninv\n)\n\n\nmixer(\nx_axis\n, \ny_axis\n, \nx_inv\n, \ny_inv\n)\n\n\nreadButton(\nbutton\n)\n\n\nreadHat(\nhat\n)\n\n\n\n\nFusion.usbGamepad(\npad_num\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for the USB Gamepad and must be called at the beginning of the program before using any other class functions. The first USB Gamepad connected to the Fusion has a \npad_num\n equal to 0. Every additional USB Gamepad connected after increases the \npad_num\n by 1.\n\n\n\n\nParameters\n\n\n\n\npad_num\n : Which USB Gamepad to connect to (Default 0)\n\n\n\n\nReturns\n\n\n\n\nUSB Gamepad Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\n# First Controller Connected (Default)\nusbg0 = Fusion.usbGamepad()\n# Second Controller Connected\nusbg1 = Fusion.usbGamepad(1)\n\n\n\n\n\n\n\nreadAxis(\naxis\n, \ninv\n)\n\n\n\n\nDefinition\n\n\n\n\nRead the selected axis from the USB Gamepad as an integer. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability. \n\n\n\n\n\n\nParameters\n\n\n\n\naxis\n : The number for which axis you want to read from.\n\n\ninv\n : Flip the positive/negative values of the axis.\n\n\n\n\nReturns\n\n\n\n\nvalue\n : int (-100 - 100)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nusbg = Fusion.usbGamepad()\nprint usbg.readAxis(0)\nprint usbg.readAxis(3)\n\n\n\n\n\n\n\nreadAxisFloat(\naxis\n, \ninv\n)\n\n\n\n\nDefinition\n\n\n\n\nRead the selected axis from the USB Gamepad as a floating point number. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability. \n\n\n\n\nParameters\n\n\n\n\naxis\n : The number for which axis you want to read from.\n\n\ninv\n : Flip the positive/negative values of the axis.\n\n\n\n\nReturns\n\n\n\n\nvalue\n : int (-1.00 - 1.00)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nusbg = Fusion.usbGamepad()\nprint usbg.readAxisFloat(0)\nprint usbg.readAxisFloat(3)\n\n\n\n\n\n\n\nmixer(\nx_axis\n, \ny_axis\n, \nx_inv\n, \ny_inv\n)\n\n\n\n\nDefinition\n\n\n\n\nCombines 2 joystick values to create a proportional tank drive. The \nX-Axis\n is the joystick value for turning left or right. The \nY-Axis\n is the joystick value for driving forward and backward. The \nX-Invert\n and \nY-Invert\n can flip the value of a joystick between positive and negative. Therefore if the robot drives or turns in the opposite direction of the joystick, invert the appropriate axis.\n\nAxis Mixer returns (M0, M1) where M0 and M1 range from -100 to 100.\n\n\n\n\nParameters\n\n\n\n\nx_axis\n : The number for which axis you want to read from for the X-Axis(turn).\n\n\ny_axis\n : The number for which axis you want to read from for the Y-Axis(drive).  \n\n\nx_inv\n : Inverts the x_axis values. (Default \nFalse\n)\n\n\ny_inv\n : Inverts the y_axis values. (Default \nFalse\n)  \n\n\n\n\nReturns\n\n\n\n\nvalue\n : tuple (X, Y) where X/Y = -100 to 100\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nusbg = Fusion.usbGamepad()\nmotorpower = usbg.mixer(0,1)\nprint motorpower    # (-50,100)\nprint motorpower[0] # -50\nprint motorpower[1] # 100\n\n\n\nor\n\n\nimport Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\nwhile True:\n    (left, right) = usbg.mixer(0,1,False,True)\n    f.motorSpeed(f.M0, right)\n    f.motorSpeed(f.M1, left)\n\n\n\n\n\n\n\nreadButton(\nbutton\n)\n\n\n\n\nDefinition\n\n\n\n\nRead the selected button from the USB Gamepad. The available number of buttons is dependent on the USB Gamepad. Refer to the diagrams for availability. \n\n\n\n\nParameters\n\n\n\n\nbutton\n : The number for which button you want to read from.\n\n\n\n\nReturns\n\n\n\n\nvalue\n : int (0 or 1)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nusbg = Fusion.usbGamepad()\nprint usbg.readButton(0)\nprint usbg.readButton(3)\n\n\n\n\n\n\n\nreadHat(\nhat\n)\n\n\n\n\nDefinition\n\n\n\n\nRead the hat of the USB Gamepad. The hat may also be called the directional pad (D-pad). The hat can return a possibility of 9 possible combinations of values.\n\n\n\n\n\n\nParameters\n\n\n\n\nhat\n : The number for which hat you want to read from. Most USB Gamepads only have 1 physical hat, therefore this parameter can be left blank which will default to 0.\n\n\n\n\nReturns\n\n\n\n\nvalue\n : tuple (X, Y) where X/Y = -1, 0, 1\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nusbg = Fusion.usbGamepad()\nhat = usbg.mixer(0,1)\nprint hat       # (-1,1)\nprint hat[0]    # -1\nprint hat[1]    # 1\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python USB Gamepad\n\n\n\n\n\n\n\n\n\n\n\n\n\nUSB Gamepads\n\n\n\n\nLogitech F310 Gamepad\n\n\n\n\nXbox 360 Game Controller", 
            "title": "USB Gamepad"
        }, 
        {
            "location": "/Py_usbGamepad/#usb-gamepad", 
            "text": "This library allows you to connect a wired or wireless USB gamepad to the Fusion for control.   USB Gamepad Visual Programming Blocks  USB Gamepad Button Mapping   List of available functions:      Fusion.usbGamepad( pad_num )  readAxis( axis ,  inv )  readAxisFloat( axis ,  inv )  mixer( x_axis ,  y_axis ,  x_inv ,  y_inv )  readButton( button )  readHat( hat )", 
            "title": "USB Gamepad"
        }, 
        {
            "location": "/Py_usbGamepad/#fusionusbgamepadpad_num", 
            "text": "", 
            "title": "Fusion.usbGamepad(pad_num)"
        }, 
        {
            "location": "/Py_usbGamepad/#definition", 
            "text": "This class contains the necessary drivers for the USB Gamepad and must be called at the beginning of the program before using any other class functions. The first USB Gamepad connected to the Fusion has a  pad_num  equal to 0. Every additional USB Gamepad connected after increases the  pad_num  by 1.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_usbGamepad/#parameters", 
            "text": "pad_num  : Which USB Gamepad to connect to (Default 0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_usbGamepad/#returns", 
            "text": "USB Gamepad Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_usbGamepad/#example", 
            "text": "import Fusion\n# First Controller Connected (Default)\nusbg0 = Fusion.usbGamepad()\n# Second Controller Connected\nusbg1 = Fusion.usbGamepad(1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_usbGamepad/#readaxisaxis-inv", 
            "text": "", 
            "title": "readAxis(axis, inv)"
        }, 
        {
            "location": "/Py_usbGamepad/#definition_1", 
            "text": "Read the selected axis from the USB Gamepad as an integer. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_usbGamepad/#parameters_1", 
            "text": "axis  : The number for which axis you want to read from.  inv  : Flip the positive/negative values of the axis.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_usbGamepad/#returns_1", 
            "text": "value  : int (-100 - 100)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_usbGamepad/#example_1", 
            "text": "import Fusion\nusbg = Fusion.usbGamepad()\nprint usbg.readAxis(0)\nprint usbg.readAxis(3)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_usbGamepad/#readaxisfloataxis-inv", 
            "text": "", 
            "title": "readAxisFloat(axis, inv)"
        }, 
        {
            "location": "/Py_usbGamepad/#definition_2", 
            "text": "Read the selected axis from the USB Gamepad as a floating point number. The available number of axes is dependent on the USB Gamepad. Refer to the diagrams for availability.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_usbGamepad/#parameters_2", 
            "text": "axis  : The number for which axis you want to read from.  inv  : Flip the positive/negative values of the axis.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_usbGamepad/#returns_2", 
            "text": "value  : int (-1.00 - 1.00)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_usbGamepad/#example_2", 
            "text": "import Fusion\nusbg = Fusion.usbGamepad()\nprint usbg.readAxisFloat(0)\nprint usbg.readAxisFloat(3)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_usbGamepad/#mixerx_axis-y_axis-x_inv-y_inv", 
            "text": "", 
            "title": "mixer(x_axis, y_axis, x_inv, y_inv)"
        }, 
        {
            "location": "/Py_usbGamepad/#definition_3", 
            "text": "Combines 2 joystick values to create a proportional tank drive. The  X-Axis  is the joystick value for turning left or right. The  Y-Axis  is the joystick value for driving forward and backward. The  X-Invert  and  Y-Invert  can flip the value of a joystick between positive and negative. Therefore if the robot drives or turns in the opposite direction of the joystick, invert the appropriate axis. \nAxis Mixer returns (M0, M1) where M0 and M1 range from -100 to 100.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_usbGamepad/#parameters_3", 
            "text": "x_axis  : The number for which axis you want to read from for the X-Axis(turn).  y_axis  : The number for which axis you want to read from for the Y-Axis(drive).    x_inv  : Inverts the x_axis values. (Default  False )  y_inv  : Inverts the y_axis values. (Default  False )", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_usbGamepad/#returns_3", 
            "text": "value  : tuple (X, Y) where X/Y = -100 to 100", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_usbGamepad/#example_3", 
            "text": "import Fusion\nusbg = Fusion.usbGamepad()\nmotorpower = usbg.mixer(0,1)\nprint motorpower    # (-50,100)\nprint motorpower[0] # -50\nprint motorpower[1] # 100  or  import Fusion\nf = Fusion.driver()\nusbg = Fusion.usbGamepad()\nwhile True:\n    (left, right) = usbg.mixer(0,1,False,True)\n    f.motorSpeed(f.M0, right)\n    f.motorSpeed(f.M1, left)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_usbGamepad/#readbuttonbutton", 
            "text": "", 
            "title": "readButton(button)"
        }, 
        {
            "location": "/Py_usbGamepad/#definition_4", 
            "text": "Read the selected button from the USB Gamepad. The available number of buttons is dependent on the USB Gamepad. Refer to the diagrams for availability.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_usbGamepad/#parameters_4", 
            "text": "button  : The number for which button you want to read from.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_usbGamepad/#returns_4", 
            "text": "value  : int (0 or 1)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_usbGamepad/#example_4", 
            "text": "import Fusion\nusbg = Fusion.usbGamepad()\nprint usbg.readButton(0)\nprint usbg.readButton(3)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_usbGamepad/#readhathat", 
            "text": "", 
            "title": "readHat(hat)"
        }, 
        {
            "location": "/Py_usbGamepad/#definition_5", 
            "text": "Read the hat of the USB Gamepad. The hat may also be called the directional pad (D-pad). The hat can return a possibility of 9 possible combinations of values.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_usbGamepad/#parameters_5", 
            "text": "hat  : The number for which hat you want to read from. Most USB Gamepads only have 1 physical hat, therefore this parameter can be left blank which will default to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_usbGamepad/#returns_5", 
            "text": "value  : tuple (X, Y) where X/Y = -1, 0, 1", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_usbGamepad/#example_5", 
            "text": "import Fusion\nusbg = Fusion.usbGamepad()\nhat = usbg.mixer(0,1)\nprint hat       # (-1,1)\nprint hat[0]    # -1\nprint hat[1]    # 1", 
            "title": "Example"
        }, 
        {
            "location": "/Py_usbGamepad/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python USB Gamepad", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_usbGamepad/#usb-gamepads", 
            "text": "", 
            "title": "USB Gamepads"
        }, 
        {
            "location": "/Py_usbGamepad/#logitech-f310-gamepad", 
            "text": "", 
            "title": "Logitech F310 Gamepad"
        }, 
        {
            "location": "/Py_usbGamepad/#xbox-360-game-controller", 
            "text": "", 
            "title": "Xbox 360 Game Controller"
        }, 
        {
            "location": "/Py_VirtualGamepad/", 
            "text": "Virtual Gamepad\n\n\n\n\nThis library allows you to display and use a virtual gamepad right on your touch screen device to control the Fusion. The Virtual Gamepad comes with 2 joysticks and 4 buttons that are controlled using the functions below.\n\nOnce the code is written, start the python program and click the Virtual Gamepad button on the toolbar to open the window. The Virtual Gamepad window will open on the current IP address on port 5000 (Default: \nmy.bot:5000\n or \n192.168.50.1:5000\n) in a new tab.\n\n\n\n\nVirtual Gamepad Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nVirtualGamepad.service()\n\n\nVirtualGamepad.service(\ncam\n, \nresolution\n, \nfps\n, \nmode\n)\n\n\nleftJoystick(\nmixer\n, \nx_inv\n, \ny_inv\n)\n\n\nrightJoystick(\nmixer\n, \nx_inv\n, \ny_inv\n)\n\n\nreadButton(\nbutton\n)\n\n\ntelemetry(\nline\n, \nvalue\n)\n\n\n\n\n\n\nVirtualGamepad.service()\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for the Virtual Gamepad and must be called at the beginning of the program before using any other class functions. This call also starts the server for the Virtual Gamepad.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nVirtual Gamepad Object\n\n\n\n\nExample\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n\n\n\n\n\n\n\nVirtualGamepad.service(\ncam\n, \nresolution\n, \nfps\n, \nmode\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for the Virtual Gamepad and must be called at the beginning of the program before using any other class functions. This call also starts the server for the Virtual Gamepad. Using this function with all the parameters will enable you to use a USB camera. Use the standard \nVirtualGamepad.service()\n function if you do not have a camera attached.\n\n\n\n\nParameters\n\n\n\n\ncam\n : If set to \nTrue\n it will enable the use of a USB camera or PiCamera to live stream video back to the virtual gamepad background. A camera must be attached to the Fusion in order to use this block or an exception will occur when the drivers are initialized. Use \nVirtualGamepad.service()\n if you do not have a camera attached.\n\n\nresolution\n : The resolution parameter allows the user to change the default resolution of \n(320x240)\n to any defined value supported by their selected camera by entering \n(width, height)\n.\n\n\nfps\n : Frames per second is the rate at which the live stream frames are displayed to screen. Default is \n10\nfps however can be increased depending on the camera abilities and WiFi connection strength.\n\n\nmode\n : Mode refers to the type of camera that is connected to the device. The default mode is \n'YUV'\n however \n'MJPG'\n and \n'PICAM'\n are also supported. Certain cameras may work better on one mode than the other and the user should refer to the manufacturer documentation or support to determine what modes are supported. \n\n\n\n\nReturns\n\n\n\n\nVirtual Gamepad Object\n\n\n\n\nExample\n\n\n\n\n# Use default values\nimport VirtualGamepad\nv = VirtualGamepad.service(True)\n\n# Use custom values\nimport VirtualGamepad\nv = VirtualGamepad.service(True, (800,600), 30, \"MJPG\")\n\n# Change a single parameter\nimport VirtualGamepad\nv = VirtualGamepad.service(True, fps=60)\n\n\n\n\n\n\n\nleftJoystick(\nmixer\n, \nx_inv\n, \ny_inv\n)\n\n\n\n\nDefinition\n\n\n\n\nRead the X-axis and Y-axis of the left joystick. The values range from -100 to 100 on each axis.\n\n\n\n\nParameters\n\n\n\n\nmixer\n : When set to \nTrue\n the mixer will combine the X and Y values to create a tank drive style of control. Default is set to \nFalse\n.\n\n\nx_inv\n : Invert the X-Axis value. Default is set to \nFalse\n.\n\n\ny_inv\n : Invert the Y-Axis value. Default is set to \nFalse\n.  \n\n\n\n\nReturns\n\n\n\n\naxis value\n : tuple (X-axis, Y-axis) where X-axis/Y-axis = -100 to 100\n\n\n\n\nExample\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n# Use Default Joystick\nleft = v.leftJoystick()\nprint left       # (100,0)\nprint left[0]    # 100\nprint left[1]    # 0\n# Use Mixer\nleft = v.leftJoystick(True)\n# Change a single parameter\nleft = v.leftJoystick(y_inv=True)\n# Change the Joystick\nleft = v.leftJoystick(True, False, True)\n\n\n\n\n\n\n\nrightJoystick(\nmixer\n, \nx_inv\n, \ny_inv\n)\n\n\n\n\nDefinition\n\n\n\n\nRead the X-axis and Y-axis of the right joystick. The values range from -100 to 100 on each axis.\n\n\n\n\nParameters\n\n\n\n\nmixer\n : When set to \nTrue\n the mixer will combine the X and Y values to create a tank drive style of control. Default is set to \nFalse\n.\n\n\nx_inv\n : Invert the X-Axis value. Default is set to \nFalse\n.\n\n\ny_inv\n : Invert the Y-Axis value. Default is set to \nFalse\n.  \n\n\n\n\nReturns\n\n\n\n\naxis value\n : tuple (X-axis, Y-axis) where X-axis/Y-axis = -100 to 100\n\n\n\n\nExample\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\n# Use Default Joystick\nright = v.rightJoystick()\nprint right       # (100,0)\nprint right[0]    # 100\nprint right[1]    # 0\n# Use Mixer\nright = v.rightJoystick(True)\n# Change a single parameter\nright = v.rightJoystick(y_inv=True)\n# Change the Joystick\nright = v.rightJoystick(True, False, True)\n\n\n\n\n\n\n\nreadButton(\nbutton\n)\n\n\n\n\nDefinition\n\n\n\n\nRead a button from the Virtual Gamepad. There are 4 available buttons: \n\n\n\n\nA\n = 0  \n\n\nB\n = 1  \n\n\nX\n = 2  \n\n\nY\n = 3  \n\n\n\n\n\n\nParameters\n\n\n\n\nbutton\n : The select button that you want to read from.\n\n\n\n\nReturns\n\n\n\n\nvalue\n : int (0 or 1)\n\n\n\n\nExample\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\nA = v.readButton('A')\nA = v.readButton(0)\nX = v.readButton('X')\nX = v.readButton(2)\n\n\n\n\n\n\n\ntelemetry(\nline\n, \nvalue\n)\n\n\n\n\nDefinition\n\n\n\n\nPrint valuable data to the Virtual Gamepad screen. This is very useful when wanting to read the return values from sensors or the Virtual Gamepad functions.\n\n\n\n\nParameters\n\n\n\n\nline\n : The line number the data should be printed on starting with 0.\n\n\nvalue\n : The data that is printed to the line.\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport VirtualGamepad\nv = VirtualGamepad.service()\nwhile True:\n    (left_x, left_y) = v.leftJoystick(True, y_inv=True)\n    (right_x, right_y) = v.leftJoystick(True, y_inv=True)\n    v.telemetry(0, \"left_x value = \" + str(left_x))\n    v.telemetry(1, \"left_y value = \" + str(left_y))\n    v.telemetry(2, \"right_x value = \" + str(right_x))\n    v.telemetry(3, \"right_y value = \" + str(right_y))\n    v.telemetry(4, \"A value = \" + str(v.readButton('A')))\n    v.telemetry(5, \"B value = \" + str(v.readButton('B')))\n    v.telemetry(6, \"X value = \" + str(v.readButton('X')))\n    v.telemetry(7, \"Y value = \" + str(v.readButton('Y')))\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Virtual Gamepad", 
            "title": "Virtual Gamepad"
        }, 
        {
            "location": "/Py_VirtualGamepad/#virtual-gamepad", 
            "text": "This library allows you to display and use a virtual gamepad right on your touch screen device to control the Fusion. The Virtual Gamepad comes with 2 joysticks and 4 buttons that are controlled using the functions below. \nOnce the code is written, start the python program and click the Virtual Gamepad button on the toolbar to open the window. The Virtual Gamepad window will open on the current IP address on port 5000 (Default:  my.bot:5000  or  192.168.50.1:5000 ) in a new tab.   Virtual Gamepad Visual Programming Blocks   List of available functions:      VirtualGamepad.service()  VirtualGamepad.service( cam ,  resolution ,  fps ,  mode )  leftJoystick( mixer ,  x_inv ,  y_inv )  rightJoystick( mixer ,  x_inv ,  y_inv )  readButton( button )  telemetry( line ,  value )", 
            "title": "Virtual Gamepad"
        }, 
        {
            "location": "/Py_VirtualGamepad/#virtualgamepadservice", 
            "text": "", 
            "title": "VirtualGamepad.service()"
        }, 
        {
            "location": "/Py_VirtualGamepad/#definition", 
            "text": "This class contains the necessary drivers for the Virtual Gamepad and must be called at the beginning of the program before using any other class functions. This call also starts the server for the Virtual Gamepad.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_VirtualGamepad/#parameters", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_VirtualGamepad/#returns", 
            "text": "Virtual Gamepad Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_VirtualGamepad/#example", 
            "text": "import VirtualGamepad\nv = VirtualGamepad.service()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_VirtualGamepad/#virtualgamepadservicecam-resolution-fps-mode", 
            "text": "", 
            "title": "VirtualGamepad.service(cam, resolution, fps, mode)"
        }, 
        {
            "location": "/Py_VirtualGamepad/#definition_1", 
            "text": "This class contains the necessary drivers for the Virtual Gamepad and must be called at the beginning of the program before using any other class functions. This call also starts the server for the Virtual Gamepad. Using this function with all the parameters will enable you to use a USB camera. Use the standard  VirtualGamepad.service()  function if you do not have a camera attached.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_VirtualGamepad/#parameters_1", 
            "text": "cam  : If set to  True  it will enable the use of a USB camera or PiCamera to live stream video back to the virtual gamepad background. A camera must be attached to the Fusion in order to use this block or an exception will occur when the drivers are initialized. Use  VirtualGamepad.service()  if you do not have a camera attached.  resolution  : The resolution parameter allows the user to change the default resolution of  (320x240)  to any defined value supported by their selected camera by entering  (width, height) .  fps  : Frames per second is the rate at which the live stream frames are displayed to screen. Default is  10 fps however can be increased depending on the camera abilities and WiFi connection strength.  mode  : Mode refers to the type of camera that is connected to the device. The default mode is  'YUV'  however  'MJPG'  and  'PICAM'  are also supported. Certain cameras may work better on one mode than the other and the user should refer to the manufacturer documentation or support to determine what modes are supported.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_VirtualGamepad/#returns_1", 
            "text": "Virtual Gamepad Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_VirtualGamepad/#example_1", 
            "text": "# Use default values\nimport VirtualGamepad\nv = VirtualGamepad.service(True)\n\n# Use custom values\nimport VirtualGamepad\nv = VirtualGamepad.service(True, (800,600), 30, \"MJPG\")\n\n# Change a single parameter\nimport VirtualGamepad\nv = VirtualGamepad.service(True, fps=60)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_VirtualGamepad/#leftjoystickmixer-x_inv-y_inv", 
            "text": "", 
            "title": "leftJoystick(mixer, x_inv, y_inv)"
        }, 
        {
            "location": "/Py_VirtualGamepad/#definition_2", 
            "text": "Read the X-axis and Y-axis of the left joystick. The values range from -100 to 100 on each axis.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_VirtualGamepad/#parameters_2", 
            "text": "mixer  : When set to  True  the mixer will combine the X and Y values to create a tank drive style of control. Default is set to  False .  x_inv  : Invert the X-Axis value. Default is set to  False .  y_inv  : Invert the Y-Axis value. Default is set to  False .", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_VirtualGamepad/#returns_2", 
            "text": "axis value  : tuple (X-axis, Y-axis) where X-axis/Y-axis = -100 to 100", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_VirtualGamepad/#example_2", 
            "text": "import VirtualGamepad\nv = VirtualGamepad.service()\n# Use Default Joystick\nleft = v.leftJoystick()\nprint left       # (100,0)\nprint left[0]    # 100\nprint left[1]    # 0\n# Use Mixer\nleft = v.leftJoystick(True)\n# Change a single parameter\nleft = v.leftJoystick(y_inv=True)\n# Change the Joystick\nleft = v.leftJoystick(True, False, True)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_VirtualGamepad/#rightjoystickmixer-x_inv-y_inv", 
            "text": "", 
            "title": "rightJoystick(mixer, x_inv, y_inv)"
        }, 
        {
            "location": "/Py_VirtualGamepad/#definition_3", 
            "text": "Read the X-axis and Y-axis of the right joystick. The values range from -100 to 100 on each axis.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_VirtualGamepad/#parameters_3", 
            "text": "mixer  : When set to  True  the mixer will combine the X and Y values to create a tank drive style of control. Default is set to  False .  x_inv  : Invert the X-Axis value. Default is set to  False .  y_inv  : Invert the Y-Axis value. Default is set to  False .", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_VirtualGamepad/#returns_3", 
            "text": "axis value  : tuple (X-axis, Y-axis) where X-axis/Y-axis = -100 to 100", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_VirtualGamepad/#example_3", 
            "text": "import VirtualGamepad\nv = VirtualGamepad.service()\n# Use Default Joystick\nright = v.rightJoystick()\nprint right       # (100,0)\nprint right[0]    # 100\nprint right[1]    # 0\n# Use Mixer\nright = v.rightJoystick(True)\n# Change a single parameter\nright = v.rightJoystick(y_inv=True)\n# Change the Joystick\nright = v.rightJoystick(True, False, True)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_VirtualGamepad/#readbuttonbutton", 
            "text": "", 
            "title": "readButton(button)"
        }, 
        {
            "location": "/Py_VirtualGamepad/#definition_4", 
            "text": "Read a button from the Virtual Gamepad. There are 4 available buttons:    A  = 0    B  = 1    X  = 2    Y  = 3", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_VirtualGamepad/#parameters_4", 
            "text": "button  : The select button that you want to read from.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_VirtualGamepad/#returns_4", 
            "text": "value  : int (0 or 1)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_VirtualGamepad/#example_4", 
            "text": "import VirtualGamepad\nv = VirtualGamepad.service()\nA = v.readButton('A')\nA = v.readButton(0)\nX = v.readButton('X')\nX = v.readButton(2)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_VirtualGamepad/#telemetryline-value", 
            "text": "", 
            "title": "telemetry(line, value)"
        }, 
        {
            "location": "/Py_VirtualGamepad/#definition_5", 
            "text": "Print valuable data to the Virtual Gamepad screen. This is very useful when wanting to read the return values from sensors or the Virtual Gamepad functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_VirtualGamepad/#parameters_5", 
            "text": "line  : The line number the data should be printed on starting with 0.  value  : The data that is printed to the line.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_VirtualGamepad/#returns_5", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_VirtualGamepad/#example_5", 
            "text": "import VirtualGamepad\nv = VirtualGamepad.service()\nwhile True:\n    (left_x, left_y) = v.leftJoystick(True, y_inv=True)\n    (right_x, right_y) = v.leftJoystick(True, y_inv=True)\n    v.telemetry(0, \"left_x value = \" + str(left_x))\n    v.telemetry(1, \"left_y value = \" + str(left_y))\n    v.telemetry(2, \"right_x value = \" + str(right_x))\n    v.telemetry(3, \"right_y value = \" + str(right_y))\n    v.telemetry(4, \"A value = \" + str(v.readButton('A')))\n    v.telemetry(5, \"B value = \" + str(v.readButton('B')))\n    v.telemetry(6, \"X value = \" + str(v.readButton('X')))\n    v.telemetry(7, \"Y value = \" + str(v.readButton('Y')))", 
            "title": "Example"
        }, 
        {
            "location": "/Py_VirtualGamepad/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Virtual Gamepad", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Compass/", 
            "text": "Compass (45-2003)\n\n\n\n\nThe Compass uses a magnetometer and an accelerometer to calculate heading data based on Earth\u2019s magnetic field. The compass can return the heading data, accelerometer data and magnetometer data to the user. Anything that generates a magnetic field must be moved away from the sensor like power cables, motor or magnetic material. This must happen because during calibration the sensor will add an offset to account for other magnetic sources in the area.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x24\n\n\nSensor ID Code\n : 0x63\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nCompass Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.compass(\ndriver\n, \naddr\n)\n\n\nhardIronCalibration()\n\n\ngetHeading()\n\n\nnullAccelerometer(\naxis\n)\n\n\ngetAccelerometer()\n\n\ntiltUp()\n\n\ntiltDown()\n\n\ngetMagnetometer()\n\n\nscaleAccelerometer())\n\n\n\n\n\n\nFusion.compass(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Compass and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nCompass Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp1 = Fusion.compass(f)\ncmp2 = Fusion.compass(f, 0x40)\n\n\n\n\n\n\n\nhardIronCalibration()\n\n\n\n\nDefinition\n\n\n\n\nHard Iron Calibration (HIC) is a method of checking for magnets or an object generating a magnetic field around the sensor and generating an offset to account for the magnetic field. During HIC the sensor must be rotated 360\u00b0 in 5 seconds while keeping a constant pace. Try to start and stop the sensor pointing due North. \n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.hardIronCalibration()\n\n\n\n\n\n\n\ngetHeading()\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the heading that ranges between 0\u00b0 and 359\u00b0. The heading is calculated from the accelerometer readings, the magnetometer readings, and the data collected during calibration.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nHeading(Degrees)\n : int (0 - 359)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\nprint cmp.getHeading()\n\n\n\n\n\n\n\nnullAccelerometer(\naxis\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function will calibrate the \nX\n, \nY\n and \nZ\n values by zeroing them. The \nX\n and \nY\n calibration must be done with the sensor laying flat on the horizon. The \nZ\n must be calibrated with the sensor held vertical. Allow a minimum of 3 seconds for calibration.\n\n\nPosition for \nX\n and \nY\n axis.\n\n\n\n\nPosition for \nZ\n axis.\n\n\n\n\n\n\nParameters\n\n\n\n\naxis\n : char ( 'X' , 'Y' , 'Z')\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.nullAccelerometer('X')\ncmp.nullAccelerometer('Y')\ncmp.nullAccelerometer('Z')\n\n\n\n\n\n\n\ngetAccelerometer()\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the accelerometer values for the \nX\n, \nY\n and \nZ\n axis.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nAccelerometer\n : int [ \nX\n , \nY\n , \nZ\n ] (-32,767 - 32,768)\n\n\n\n\nExample\n\n\n\n\nThe following example returns an array of size \n3\n and stores it into the variables \nX\n, \nY\n, and \nZ\n.\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\n(X, Y, Z) = cmp.getAccelerometer()\nprint X\n\n\n\nTo collect a single value instead of the array, reference the index. This will print the \nX\n value.\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\nprint cmp.getAccelerometer()[0]\n\n\n\n\n\n\n\ntiltUp()\n\n\n\n\nDefinition\n\n\n\n\nThis function calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 above the horizon during calibration.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.tiltUp()\n\n\n\n\n\n\n\ntiltDown()\n\n\n\n\nDefinition\n\n\n\n\nThis function calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 below the horizon during calibration.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.tiltDown()\n\n\n\n\n\n\n\ngetMagnetometer()\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the values of the magnetometer on the \nX\n, \nY\n and \nZ\n axis.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nMagnetometer\n : int [ \nX\n , \nY\n , \nZ\n ] (0 - 1023)\n\n\n\n\nExample\n\n\n\n\nThe following example returns an array of size \n3\n and stores it into the variables \nX\n, \nY\n, \nZ\n.\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\n(X, Y, Z) = cmp.getMagnetometer()\nprint X\n\n\n\nTo collect a single value instead of the array, reference the index. This will print the \nX\n value.\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\nprint cmp.getMagnetometer()[0]\n\n\n\n\n\n\n\nscaleAccelerometer()\n\n\n\n\nDefinition\n\n\n\n\nThis function is called if the user wants to change the sensitivity of the accelerometer reading. First the sensor must be set vertical (Same position as \nZ\n calibration) and hold it there for the duration of the calibration. Once the sensor is in position the program may be ran. Once the program is completed, the scaling value will be updated within the Compass.\n\n\nPostion of sensor during scaling.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.scaleAccelerometer()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Compass", 
            "title": "Compass (45-2003)"
        }, 
        {
            "location": "/Py_Compass/#compass-45-2003", 
            "text": "The Compass uses a magnetometer and an accelerometer to calculate heading data based on Earth\u2019s magnetic field. The compass can return the heading data, accelerometer data and magnetometer data to the user. Anything that generates a magnetic field must be moved away from the sensor like power cables, motor or magnetic material. This must happen because during calibration the sensor will add an offset to account for other magnetic sources in the area.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x24  Sensor ID Code  : 0x63  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  Compass Visual Programming Blocks   List of available functions:      Fusion.compass( driver ,  addr )  hardIronCalibration()  getHeading()  nullAccelerometer( axis )  getAccelerometer()  tiltUp()  tiltDown()  getMagnetometer()  scaleAccelerometer())", 
            "title": "Compass (45-2003)"
        }, 
        {
            "location": "/Py_Compass/#fusioncompassdriver-addr", 
            "text": "", 
            "title": "Fusion.compass(driver, addr)"
        }, 
        {
            "location": "/Py_Compass/#definition", 
            "text": "This class contains the necessary drivers for our Compass and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns", 
            "text": "Compass Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp1 = Fusion.compass(f)\ncmp2 = Fusion.compass(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#hardironcalibration", 
            "text": "", 
            "title": "hardIronCalibration()"
        }, 
        {
            "location": "/Py_Compass/#definition_1", 
            "text": "Hard Iron Calibration (HIC) is a method of checking for magnets or an object generating a magnetic field around the sensor and generating an offset to account for the magnetic field. During HIC the sensor must be rotated 360\u00b0 in 5 seconds while keeping a constant pace. Try to start and stop the sensor pointing due North.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.hardIronCalibration()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#getheading", 
            "text": "", 
            "title": "getHeading()"
        }, 
        {
            "location": "/Py_Compass/#definition_2", 
            "text": "This function returns the heading that ranges between 0\u00b0 and 359\u00b0. The heading is calculated from the accelerometer readings, the magnetometer readings, and the data collected during calibration.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_2", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_2", 
            "text": "Heading(Degrees)  : int (0 - 359)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\nprint cmp.getHeading()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#nullaccelerometeraxis", 
            "text": "", 
            "title": "nullAccelerometer(axis)"
        }, 
        {
            "location": "/Py_Compass/#definition_3", 
            "text": "This function will calibrate the  X ,  Y  and  Z  values by zeroing them. The  X  and  Y  calibration must be done with the sensor laying flat on the horizon. The  Z  must be calibrated with the sensor held vertical. Allow a minimum of 3 seconds for calibration.  Position for  X  and  Y  axis.   Position for  Z  axis.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_3", 
            "text": "axis  : char ( 'X' , 'Y' , 'Z')", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_3", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_3", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.nullAccelerometer('X')\ncmp.nullAccelerometer('Y')\ncmp.nullAccelerometer('Z')", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#getaccelerometer", 
            "text": "", 
            "title": "getAccelerometer()"
        }, 
        {
            "location": "/Py_Compass/#definition_4", 
            "text": "This function returns the accelerometer values for the  X ,  Y  and  Z  axis.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_4", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_4", 
            "text": "Accelerometer  : int [  X  ,  Y  ,  Z  ] (-32,767 - 32,768)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_4", 
            "text": "The following example returns an array of size  3  and stores it into the variables  X ,  Y , and  Z .  import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\n(X, Y, Z) = cmp.getAccelerometer()\nprint X  To collect a single value instead of the array, reference the index. This will print the  X  value.  import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\nprint cmp.getAccelerometer()[0]", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#tiltup", 
            "text": "", 
            "title": "tiltUp()"
        }, 
        {
            "location": "/Py_Compass/#definition_5", 
            "text": "This function calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 above the horizon during calibration.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_5", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_5", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_5", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.tiltUp()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#tiltdown", 
            "text": "", 
            "title": "tiltDown()"
        }, 
        {
            "location": "/Py_Compass/#definition_6", 
            "text": "This function calculates an offset to compensate for the magnetic field not being perfectly horizontal. The sensor must be held 20\u00b0 below the horizon during calibration.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_6", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_6", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_6", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.tiltDown()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#getmagnetometer", 
            "text": "", 
            "title": "getMagnetometer()"
        }, 
        {
            "location": "/Py_Compass/#definition_7", 
            "text": "This function returns the values of the magnetometer on the  X ,  Y  and  Z  axis.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_7", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_7", 
            "text": "Magnetometer  : int [  X  ,  Y  ,  Z  ] (0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_7", 
            "text": "The following example returns an array of size  3  and stores it into the variables  X ,  Y ,  Z .  import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\n(X, Y, Z) = cmp.getMagnetometer()\nprint X  To collect a single value instead of the array, reference the index. This will print the  X  value.  import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\nprint cmp.getMagnetometer()[0]", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#scaleaccelerometer", 
            "text": "", 
            "title": "scaleAccelerometer()"
        }, 
        {
            "location": "/Py_Compass/#definition_8", 
            "text": "This function is called if the user wants to change the sensitivity of the accelerometer reading. First the sensor must be set vertical (Same position as  Z  calibration) and hold it there for the duration of the calibration. Once the sensor is in position the program may be ran. Once the program is completed, the scaling value will be updated within the Compass.  Postion of sensor during scaling.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Compass/#parameters_8", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Compass/#returns_8", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Compass/#example_8", 
            "text": "import Fusion\nf = Fusion.driver()\ncmp = Fusion.compass(f)\ncmp.scaleAccelerometer()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Compass/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Compass", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Rate_Gyro/", 
            "text": "Rate Gyro (45-2004)\n\n\n\n\nThe Rate Gyro is used to detect the rate of rotation. When the Rate Gyro is completely still, the returned reading is 1.4V which produces a reading of 280\u00b0 \u00b12\u00b0. With the sensor idle at 280\u00b0 a Counter Clockwise (CCW) rotation will increase the value of the reading and then return to 280\u00b0 once movement is stopped. A Clockwise (CW) rotation of the gyro will cause a decrease in the return value and return to 280\u00b0 once the sensor is no longer moving. The readings are accurate to the degree.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V\n\n\nRate Gyro Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\nread()\n\n\n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\n\n\nDefinition\n\n\n\n\nThe following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\nport\n : Analog port the sensor is connected to A0 - A7\n\n\n\n\nReturns\n\n\n\n\nAnalog Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nrate_gyro_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\n\n\nread()\n\n\n\n\nDefinition\n\n\n\n\nReturns the rate of rotation of the sensor. When the sensor stops moving the value will go back to 280.\n\n\n\n\nValue of 280 indicates no rotation detected in either direction.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nRate of Rotation\n : int (0 - 1023)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nrate_gyro_A0 = Fusion.analog(f, f.A0)\nprint rate_gyro_A0.read()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Rate Gyro", 
            "title": "Rate Gyro (45-2004)"
        }, 
        {
            "location": "/Py_Rate_Gyro/#rate-gyro-45-2004", 
            "text": "The Rate Gyro is used to detect the rate of rotation. When the Rate Gyro is completely still, the returned reading is 1.4V which produces a reading of 280\u00b0 \u00b12\u00b0. With the sensor idle at 280\u00b0 a Counter Clockwise (CCW) rotation will increase the value of the reading and then return to 280\u00b0 once movement is stopped. A Clockwise (CW) rotation of the gyro will cause a decrease in the return value and return to 280\u00b0 once the sensor is no longer moving. The readings are accurate to the degree.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V  Rate Gyro Visual Programming Blocks   List of available functions:      Fusion.analog( driver ,  port )  read()", 
            "title": "Rate Gyro (45-2004)"
        }, 
        {
            "location": "/Py_Rate_Gyro/#fusionanalogdriver-port", 
            "text": "", 
            "title": "Fusion.analog(driver, port)"
        }, 
        {
            "location": "/Py_Rate_Gyro/#definition", 
            "text": "The following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Rate_Gyro/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  port  : Analog port the sensor is connected to A0 - A7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Rate_Gyro/#returns", 
            "text": "Analog Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Rate_Gyro/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nrate_gyro_A0 = Fusion.analog(f, f.A0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Rate_Gyro/#read", 
            "text": "", 
            "title": "read()"
        }, 
        {
            "location": "/Py_Rate_Gyro/#definition_1", 
            "text": "Returns the rate of rotation of the sensor. When the sensor stops moving the value will go back to 280.   Value of 280 indicates no rotation detected in either direction.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Rate_Gyro/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Rate_Gyro/#returns_1", 
            "text": "Rate of Rotation  : int (0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Rate_Gyro/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nrate_gyro_A0 = Fusion.analog(f, f.A0)\nprint rate_gyro_A0.read()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Rate_Gyro/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Rate Gyro", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Integrating_Gyro/", 
            "text": "Integrating Gyro (45-2005)\n\n\n\n\nThe Integrating Gyro uses a 3-axis chip to obtain \nX\n, \nY\n and \nZ\n coordinates as well as an integration of the z-axis to provide heading data. The integrated Z value is an integration of the z-axis over time and this value is used internally in heading calculations. The LED will blink at 1Hz during normal operation and will remain on during null operation (calibration). Once the null location is set, the sensor will maintain that reference until the sensor is recalibrated or zeroed.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x20\n\n\nSensor ID Code\n : 0x47\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nIntegrating Gyro Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.intGyro(\ndriver\n, \naddr\n)\n\n\nsetNull()\n\n\nsetZero()\n\n\ngetDegrees()\n\n\ngetAbsolute()\n\n\ngetAxis(\naxis\n)\n\n\nsetScale(\nscale\n)\n\n\n\n\n\n\nFusion.intGyro(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Integrating Gyro and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nIntegrating Gyro Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro1 = Fusion.intGyro(f)\nint_gyro2 = Fusion.intGyro(f, 0x40)\n\n\n\n\n\n\n\nsetNull()\n\n\n\n\nDefinition\n\n\n\n\nSetting the gyro to null will enable the user to calibrate their gyro. The gyro must be kept perfectly still and flat during the null operation. During the null operation, the LED will be on and remain on until calibration is complete. It is recommended that this function be called before starting the main program loop. This function writes to the EEPROM every time it is called. To set the gyro to 0 without writing to the EEPROM, use the \nsetZero()\n function. \n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setNull()\n\n\n\n\n\n\n\nsetZero()\n\n\n\n\nDefinition\n\n\n\n\nSets the current heading to 0. Does not calibrate the gyro.  This is very useful for resetting the returned heading reading without needing to remain still for calibration.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setZero()\n\n\n\n\n\n\n\ngetDegrees()\n\n\n\n\nDefinition\n\n\n\n\nReturns the value of the distance rotated from the null location in degrees. The readings are based on the Cartesian coordinate system of 0\u00b0 - 359\u00b0.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nDegrees\n : int (0 - 359)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nprint int_gyro.getDegrees()\n\n\n\n\n\n\n\ngetAbsolute()\n\n\n\n\nDefinition\n\n\n\n\nReturns the value of the total distance rotated from the null location in degrees. Rotating in a Clockwise fashion will produce increasing negative numbers and rotating in a Counter Clockwise direction will produce increasing positive numbers.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nAbsolute\n : int (-32,767 - 32,768)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nprint int_gyro.getAbsolute()\n\n\n\n\n\n\n\ngetAxis(\naxis\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the rate of rotation for a particular axis in degrees.\n\n\n\n\nParameters\n\n\n\n\naxis\n : char ( '\nX\n' , '\nY\n' , '\nZ\n')\n\n\n\n\nReturns\n\n\n\n\nAxis Rotation\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nprint int_gyro.getAxis('X')\n\n\n\n\n\n\n\nsetScale(\nscale\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function allows for scaling on the z-axis. The z-axis scaling coefficient is a 16-bit value meant to scale the heading reading so that more precise measurements can be made.\n\nThe formula for calculating the z-axis scaling coefficient (\nscale\n):\n\n\n\n\nTherefore if an Integrating Gyro rotates 360\u00b0 but the returned heading values read 380\u00b0, (20\u00b0 if reading in degree mode) which is 20\u00b0 over what was expected, then the formula above can be used to scale the reading.  \n\n\nscale\n = Angle Rotated / Heading Value\n\n\nscale\n = 360 / 380\n\n\nscale\n = .947\n\n\nThen the setScale(\nscale\n) function can be called with the \nscale\n that was found during calculations.\n\n\nint_gyro.setScale(.947)\n\n\nOnce the value is set using this function, it will be saved in EEPROM. Therefore it only needs to be called once to be set and the only way to change the value it to call the function again.\n\n\n\n\nParameters\n\n\n\n\nscale\n : float\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setScale(.947)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Integrating Gyro", 
            "title": "Integrating Gyro (45-2005)"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#integrating-gyro-45-2005", 
            "text": "The Integrating Gyro uses a 3-axis chip to obtain  X ,  Y  and  Z  coordinates as well as an integration of the z-axis to provide heading data. The integrated Z value is an integration of the z-axis over time and this value is used internally in heading calculations. The LED will blink at 1Hz during normal operation and will remain on during null operation (calibration). Once the null location is set, the sensor will maintain that reference until the sensor is recalibrated or zeroed.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x20  Sensor ID Code  : 0x47  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  Integrating Gyro Visual Programming Blocks   List of available functions:      Fusion.intGyro( driver ,  addr )  setNull()  setZero()  getDegrees()  getAbsolute()  getAxis( axis )  setScale( scale )", 
            "title": "Integrating Gyro (45-2005)"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#fusionintgyrodriver-addr", 
            "text": "", 
            "title": "Fusion.intGyro(driver, addr)"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition", 
            "text": "This class contains the necessary drivers for our Integrating Gyro and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns", 
            "text": "Integrating Gyro Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro1 = Fusion.intGyro(f)\nint_gyro2 = Fusion.intGyro(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#setnull", 
            "text": "", 
            "title": "setNull()"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition_1", 
            "text": "Setting the gyro to null will enable the user to calibrate their gyro. The gyro must be kept perfectly still and flat during the null operation. During the null operation, the LED will be on and remain on until calibration is complete. It is recommended that this function be called before starting the main program loop. This function writes to the EEPROM every time it is called. To set the gyro to 0 without writing to the EEPROM, use the  setZero()  function.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setNull()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#setzero", 
            "text": "", 
            "title": "setZero()"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition_2", 
            "text": "Sets the current heading to 0. Does not calibrate the gyro.  This is very useful for resetting the returned heading reading without needing to remain still for calibration.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters_2", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns_2", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setZero()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#getdegrees", 
            "text": "", 
            "title": "getDegrees()"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition_3", 
            "text": "Returns the value of the distance rotated from the null location in degrees. The readings are based on the Cartesian coordinate system of 0\u00b0 - 359\u00b0.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters_3", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns_3", 
            "text": "Degrees  : int (0 - 359)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example_3", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nprint int_gyro.getDegrees()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#getabsolute", 
            "text": "", 
            "title": "getAbsolute()"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition_4", 
            "text": "Returns the value of the total distance rotated from the null location in degrees. Rotating in a Clockwise fashion will produce increasing negative numbers and rotating in a Counter Clockwise direction will produce increasing positive numbers.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters_4", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns_4", 
            "text": "Absolute  : int (-32,767 - 32,768)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example_4", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nprint int_gyro.getAbsolute()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#getaxisaxis", 
            "text": "", 
            "title": "getAxis(axis)"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition_5", 
            "text": "This function returns the rate of rotation for a particular axis in degrees.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters_5", 
            "text": "axis  : char ( ' X ' , ' Y ' , ' Z ')", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns_5", 
            "text": "Axis Rotation", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example_5", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nprint int_gyro.getAxis('X')", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#setscalescale", 
            "text": "", 
            "title": "setScale(scale)"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#definition_6", 
            "text": "This function allows for scaling on the z-axis. The z-axis scaling coefficient is a 16-bit value meant to scale the heading reading so that more precise measurements can be made. \nThe formula for calculating the z-axis scaling coefficient ( scale ):   Therefore if an Integrating Gyro rotates 360\u00b0 but the returned heading values read 380\u00b0, (20\u00b0 if reading in degree mode) which is 20\u00b0 over what was expected, then the formula above can be used to scale the reading.    scale  = Angle Rotated / Heading Value  scale  = 360 / 380  scale  = .947  Then the setScale( scale ) function can be called with the  scale  that was found during calculations.  int_gyro.setScale(.947)  Once the value is set using this function, it will be saved in EEPROM. Therefore it only needs to be called once to be set and the only way to change the value it to call the function again.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#parameters_6", 
            "text": "scale  : float", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#returns_6", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#example_6", 
            "text": "import Fusion\nf = Fusion.driver()\nint_gyro = Fusion.intGyro(f)\nint_gyro.setScale(.947)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Integrating_Gyro/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Integrating Gyro", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/", 
            "text": "Optical Distance Sensor (45-2006)\n\n\n\n\nThe Optical Distance Sensor (ODS) is an analog sensor that uses electro optical proximity detection to calculate distance from an object based on the intensity of the light. This sensor can calculate distances between 1cm to 15cm. Lighter colored objects will return a more accurate and consistent reading, the material also plays a part on the returned value. Try different colors and material to see what works best for you. The ODS can be used for object detection, line detection and the difference between light and dark.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V\n\n\nOptical Distance Sensor Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\nread()\n\n\n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\n\n\nDefinition\n\n\n\n\nThe following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\nport\n : Analog port the sensor is connected to A0 - A7\n\n\n\n\nReturns\n\n\n\n\nAnalog Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nods_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\n\n\nread()\n\n\n\n\nDefinition\n\n\n\n\nThe optical element works by emitting pulsed visible light from on LED and receiving pulsed visible light to the photodiode. The optical value can detect objects within 15cm. As an object approaches the optical element the returned value will increase at an exponential rate.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nProximity\n : int (0 - 1023)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nods_A0 = Fusion.analog(f, f.A0)\nprint ods_A0.read()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Optical Distance Sensor", 
            "title": "Optical Distance Sensor (45-2006)"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#optical-distance-sensor-45-2006", 
            "text": "The Optical Distance Sensor (ODS) is an analog sensor that uses electro optical proximity detection to calculate distance from an object based on the intensity of the light. This sensor can calculate distances between 1cm to 15cm. Lighter colored objects will return a more accurate and consistent reading, the material also plays a part on the returned value. Try different colors and material to see what works best for you. The ODS can be used for object detection, line detection and the difference between light and dark.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V  Optical Distance Sensor Visual Programming Blocks   List of available functions:      Fusion.analog( driver ,  port )  read()", 
            "title": "Optical Distance Sensor (45-2006)"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#fusionanalogdriver-port", 
            "text": "", 
            "title": "Fusion.analog(driver, port)"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#definition", 
            "text": "The following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  port  : Analog port the sensor is connected to A0 - A7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#returns", 
            "text": "Analog Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nods_A0 = Fusion.analog(f, f.A0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#read", 
            "text": "", 
            "title": "read()"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#definition_1", 
            "text": "The optical element works by emitting pulsed visible light from on LED and receiving pulsed visible light to the photodiode. The optical value can detect objects within 15cm. As an object approaches the optical element the returned value will increase at an exponential rate.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#returns_1", 
            "text": "Proximity  : int (0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nods_A0 = Fusion.analog(f, f.A0)\nprint ods_A0.read()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Optical_Distance_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Optical Distance Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Touch_Sensor/", 
            "text": "Touch Sensor (45-2007)\n\n\n\n\nThe Touch Sensor can be used for an array of different tasks including object detection, a counter, a standard push button and many more. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.\n\n\n\n\nSensor Type\n : Three Wire Digital\n\n\nDimensions\n : 36mm x 32mm x 15mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nTouch Sensor Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.digital(\ndriver\n, \nport\n)\n\n\nread()\n\n\n\n\n\n\nFusion.digital(\ndriver\n, \nport\n)\n\n\n\n\nDefinition\n\n\n\n\nThe following class provides a wrapper for the digital function to tie sensor names directly to the port and read all in one simple motion. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\nport\n : Digital port the sensor is connected to D0 - D7\n\n\n\n\nReturns\n\n\n\n\nDigital Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ntouch_D7 = Fusion.digital(f, f.D7)\n\n\n\n\n\n\n\nread()\n\n\n\n\nDefinition\n\n\n\n\nReturns the current digital value of the sensor.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nPressed\n : int (0 - 1)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ntouch_D7 = Fusion.digital(f, f.D7)\nprint touch_D7.read()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Touch Sensor", 
            "title": "Touch Sensor (45-2007)"
        }, 
        {
            "location": "/Py_Touch_Sensor/#touch-sensor-45-2007", 
            "text": "The Touch Sensor can be used for an array of different tasks including object detection, a counter, a standard push button and many more. The sensor can be attached to either an analog or digital port and contains a built-in LED which indicates when the sensor is activated. When the button is pressed, the value returned is 1. When the button is not pressed, the value returned is 0.   Sensor Type  : Three Wire Digital  Dimensions  : 36mm x 32mm x 15mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  Touch Sensor Visual Programming Blocks   List of available functions:      Fusion.digital( driver ,  port )  read()", 
            "title": "Touch Sensor (45-2007)"
        }, 
        {
            "location": "/Py_Touch_Sensor/#fusiondigitaldriver-port", 
            "text": "", 
            "title": "Fusion.digital(driver, port)"
        }, 
        {
            "location": "/Py_Touch_Sensor/#definition", 
            "text": "The following class provides a wrapper for the digital function to tie sensor names directly to the port and read all in one simple motion.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Touch_Sensor/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  port  : Digital port the sensor is connected to D0 - D7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Touch_Sensor/#returns", 
            "text": "Digital Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Touch_Sensor/#example", 
            "text": "import Fusion\nf = Fusion.driver()\ntouch_D7 = Fusion.digital(f, f.D7)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Touch_Sensor/#read", 
            "text": "", 
            "title": "read()"
        }, 
        {
            "location": "/Py_Touch_Sensor/#definition_1", 
            "text": "Returns the current digital value of the sensor.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Touch_Sensor/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Touch_Sensor/#returns_1", 
            "text": "Pressed  : int (0 - 1)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Touch_Sensor/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\ntouch_D7 = Fusion.digital(f, f.D7)\nprint touch_D7.read()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Touch_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Touch Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Range_Sensor/", 
            "text": "Range Sensor (45-2008)\n\n\n\n\nThe Range Sensor combines ultrasonic and optical measuring elements to obtain a reading between 1cm and 255cm. The ultrasonic accurately measures distance to a target up to 255cm away, but it losses accuracy if the object is closer than 5cm. This is where the optical sensor comes into play as it can measure from 1cm out to about 7cm. The target shape and surface material will influence the detectable range.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x28\n\n\nSensor ID Code\n : 0x55\n\n\nDimensions\n : 56mm x 32mm x 17mm\n\n\nMounting Holes\n : 48mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nRange Sensor Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.range(\ndriver\n, \naddr\n)\n\n\nultrasonic()\n\n\noptical()\n\n\n\n\n\n\nFusion.range(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Range Sensor and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nRange Sensor Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nr1 = Fusion.range(f)\nr2 = Fusion.range(f, 0x40)\n\n\n\n\n\n\n\nultrasonic()\n\n\n\n\nDefinition\n\n\n\n\nThe ultrasonic element works by one of the transducers emitting a sound wave and the other receiving the sound wave. This reading is accurate between 5cm and approximately 255cm. The return is linear.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nDistance(cm)\n : int (0 - 255)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nr = Fusion.range(f)\nprint r.ultrasonic()\n\n\n\n\n\n\n\noptical()\n\n\n\n\nDefinition\n\n\n\n\nThe optical element works by emitting infrared light from on LED and receiving infrared light to the other LED. The optical value can detect objects within 15cm. As an object approaches the optical element the returned value will increase at an exponential rate.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nProximity\n : int (0 - 255)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nr = Fusion.range(f)\nprint r.optical()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Range Sensor", 
            "title": "Range Sensor (45-2008)"
        }, 
        {
            "location": "/Py_Range_Sensor/#range-sensor-45-2008", 
            "text": "The Range Sensor combines ultrasonic and optical measuring elements to obtain a reading between 1cm and 255cm. The ultrasonic accurately measures distance to a target up to 255cm away, but it losses accuracy if the object is closer than 5cm. This is where the optical sensor comes into play as it can measure from 1cm out to about 7cm. The target shape and surface material will influence the detectable range.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x28  Sensor ID Code  : 0x55  Dimensions  : 56mm x 32mm x 17mm  Mounting Holes  : 48mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  Range Sensor Visual Programming Blocks   List of available functions:      Fusion.range( driver ,  addr )  ultrasonic()  optical()", 
            "title": "Range Sensor (45-2008)"
        }, 
        {
            "location": "/Py_Range_Sensor/#fusionrangedriver-addr", 
            "text": "", 
            "title": "Fusion.range(driver, addr)"
        }, 
        {
            "location": "/Py_Range_Sensor/#definition", 
            "text": "This class contains the necessary drivers for our Range Sensor and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Range_Sensor/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Range_Sensor/#returns", 
            "text": "Range Sensor Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Range_Sensor/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nr1 = Fusion.range(f)\nr2 = Fusion.range(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Range_Sensor/#ultrasonic", 
            "text": "", 
            "title": "ultrasonic()"
        }, 
        {
            "location": "/Py_Range_Sensor/#definition_1", 
            "text": "The ultrasonic element works by one of the transducers emitting a sound wave and the other receiving the sound wave. This reading is accurate between 5cm and approximately 255cm. The return is linear.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Range_Sensor/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Range_Sensor/#returns_1", 
            "text": "Distance(cm)  : int (0 - 255)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Range_Sensor/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nr = Fusion.range(f)\nprint r.ultrasonic()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Range_Sensor/#optical", 
            "text": "", 
            "title": "optical()"
        }, 
        {
            "location": "/Py_Range_Sensor/#definition_2", 
            "text": "The optical element works by emitting infrared light from on LED and receiving infrared light to the other LED. The optical value can detect objects within 15cm. As an object approaches the optical element the returned value will increase at an exponential rate.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Range_Sensor/#parameters_2", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Range_Sensor/#returns_2", 
            "text": "Proximity  : int (0 - 255)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Range_Sensor/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\nr = Fusion.range(f)\nprint r.optical()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Range_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Range Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_IR_Locator_360/", 
            "text": "IR Locator 360\u00b0 (45-2009)\n\n\n\n\nThe IR Locator 360\u00b0 utilizes an array of 4 photodiodes to detect the direction and distance from a 1200Hz or 600Hz pulsed infrared source with a  5\u00b0resolution. Both the 600Hz and 1200Hz frequencies can be read at the same time allowing up to two directional sources to be used. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. \n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x1C\n\n\nSensor ID Code\n : 0x4C\n\n\nDimensions\n : 56mm x 32mm x 31mm\n\n\nMounting Holes\n : 48mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nIR Locator 360\u00b0 Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.locator360(\ndriver\n, \naddr\n)\n\n\ngetHeading(\nfrequency\n)\n\n\ngetIntensity(\nfrequency\n)\n\n\n\n\n\n\nFusion.locator360(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our IR Locator 360\u00b0 and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nIR Locator 360\u00b0 Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nloc1 = Fusion.range(f)\nloc2 = Fusion.range(f, 0x40)\n\n\n\n\n\n\n\ngetHeading(\nfrequency\n)\n\n\n\n\nDefinition\n\n\n\n\nThe heading value is returned in degrees and ranges from 0 to 71 at a resolution of 5\u00b0. If an object were to circle the sensor in a clockwise direction, the value of degrees will increase from 0. If the object were to circle in a counter-clockwise direction, the value of the heading will decrease from 71. Frequencies of 600Hz and 1200Hz can be read from this sensor.\n\n\n\n\nParameters\n\n\n\n\nfrequency\n : 600Hz or 1200Hz\n\n\n\n\nReturns\n\n\n\n\nHeading\n : int (0 - 71)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nloc = Fusion.locator360(f)\nprint loc.getHeading(1200)\nprint (loc.getHeading(1200) * 5)\n\n\n\n\n\n\n\ngetIntensity(\nfrequency\n)\n\n\n\n\nDefinition\n\n\n\n\nThe intensity value represents the distance of the infrared source. When no infrared source is detected the value of the intensity level approaches 0. As an infrared source get closer to the sensor the value of the intensity increases.\n\n\n\n\nParameters\n\n\n\n\nfrequency\n : 600Hz or 1200Hz\n\n\n\n\nReturns\n\n\n\n\nIntensity\n : int (0 - 255)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nloc = Fusion.locator360(f)\nprint loc.getIntensity(600)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python IR Locator 360", 
            "title": "IR Locator 360\u00b0 (45-2009)"
        }, 
        {
            "location": "/Py_IR_Locator_360/#ir-locator-360-45-2009", 
            "text": "The IR Locator 360\u00b0 utilizes an array of 4 photodiodes to detect the direction and distance from a 1200Hz or 600Hz pulsed infrared source with a  5\u00b0resolution. Both the 600Hz and 1200Hz frequencies can be read at the same time allowing up to two directional sources to be used. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used.    Sensor Type  : Four Wire I2C  Default I2C Address  : 0x1C  Sensor ID Code  : 0x4C  Dimensions  : 56mm x 32mm x 31mm  Mounting Holes  : 48mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  IR Locator 360\u00b0 Visual Programming Blocks   List of available functions:      Fusion.locator360( driver ,  addr )  getHeading( frequency )  getIntensity( frequency )", 
            "title": "IR Locator 360\u00b0 (45-2009)"
        }, 
        {
            "location": "/Py_IR_Locator_360/#fusionlocator360driver-addr", 
            "text": "", 
            "title": "Fusion.locator360(driver, addr)"
        }, 
        {
            "location": "/Py_IR_Locator_360/#definition", 
            "text": "This class contains the necessary drivers for our IR Locator 360\u00b0 and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Locator_360/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Locator_360/#returns", 
            "text": "IR Locator 360\u00b0 Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Locator_360/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nloc1 = Fusion.range(f)\nloc2 = Fusion.range(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Locator_360/#getheadingfrequency", 
            "text": "", 
            "title": "getHeading(frequency)"
        }, 
        {
            "location": "/Py_IR_Locator_360/#definition_1", 
            "text": "The heading value is returned in degrees and ranges from 0 to 71 at a resolution of 5\u00b0. If an object were to circle the sensor in a clockwise direction, the value of degrees will increase from 0. If the object were to circle in a counter-clockwise direction, the value of the heading will decrease from 71. Frequencies of 600Hz and 1200Hz can be read from this sensor.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Locator_360/#parameters_1", 
            "text": "frequency  : 600Hz or 1200Hz", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Locator_360/#returns_1", 
            "text": "Heading  : int (0 - 71)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Locator_360/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nloc = Fusion.locator360(f)\nprint loc.getHeading(1200)\nprint (loc.getHeading(1200) * 5)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Locator_360/#getintensityfrequency", 
            "text": "", 
            "title": "getIntensity(frequency)"
        }, 
        {
            "location": "/Py_IR_Locator_360/#definition_2", 
            "text": "The intensity value represents the distance of the infrared source. When no infrared source is detected the value of the intensity level approaches 0. As an infrared source get closer to the sensor the value of the intensity increases.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Locator_360/#parameters_2", 
            "text": "frequency  : 600Hz or 1200Hz", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Locator_360/#returns_2", 
            "text": "Intensity  : int (0 - 255)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Locator_360/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\nloc = Fusion.locator360(f)\nprint loc.getIntensity(600)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Locator_360/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python IR Locator 360", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Light_Sensor/", 
            "text": "Light Sensor (45-2015)\n\n\n\n\nThe Light Sensor detects the ambient light level using a phototransistor. The value returned is a quasi-logarithmic analog value. This means that the Light Sensor can detect slight changes in light and dark environments. A value of 0 indicates no light and a value of 1023 indicates the sensor is flooded with light.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V\n\n\nLight Sensor Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\nread()\n\n\n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\n\n\nDefinition\n\n\n\n\nThe following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\nport\n : Analog port the sensor is connected to A0 - A7\n\n\n\n\nReturns\n\n\n\n\nAnalog Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nlight_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\n\n\nread()\n\n\n\n\nDefinition\n\n\n\n\nReturns the current analog value read on the sensor.\n\n\n\n\nIdle value changes depending on the amount of ambient light in the environment.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nAmbient Light\n : int (0 - 1023)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nlight_A0 = Fusion.analog(f, f.A0)\nprint light_A0.read()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Light Sensor", 
            "title": "Light Sensor (45-2015)"
        }, 
        {
            "location": "/Py_Light_Sensor/#light-sensor-45-2015", 
            "text": "The Light Sensor detects the ambient light level using a phototransistor. The value returned is a quasi-logarithmic analog value. This means that the Light Sensor can detect slight changes in light and dark environments. A value of 0 indicates no light and a value of 1023 indicates the sensor is flooded with light.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V  Light Sensor Visual Programming Blocks   List of available functions:      Fusion.analog( driver ,  port )  read()", 
            "title": "Light Sensor (45-2015)"
        }, 
        {
            "location": "/Py_Light_Sensor/#fusionanalogdriver-port", 
            "text": "", 
            "title": "Fusion.analog(driver, port)"
        }, 
        {
            "location": "/Py_Light_Sensor/#definition", 
            "text": "The following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Light_Sensor/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  port  : Analog port the sensor is connected to A0 - A7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Light_Sensor/#returns", 
            "text": "Analog Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Light_Sensor/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nlight_A0 = Fusion.analog(f, f.A0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Light_Sensor/#read", 
            "text": "", 
            "title": "read()"
        }, 
        {
            "location": "/Py_Light_Sensor/#definition_1", 
            "text": "Returns the current analog value read on the sensor.   Idle value changes depending on the amount of ambient light in the environment.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Light_Sensor/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Light_Sensor/#returns_1", 
            "text": "Ambient Light  : int (0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Light_Sensor/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nlight_A0 = Fusion.analog(f, f.A0)\nprint light_A0.read()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Light_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Light Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Sound_Generator/", 
            "text": "Sound Generator (45-2016)\n\n\n\n\nThe Sound Generator can generate a sound based on volume, pitch and duration. This sensor also can overwrite settings during a tone to change the pitch, volume, or extend the duration of the tone.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x34\n\n\nSensor ID Code\n : 0x53\n\n\nDimensions\n : 32mm x 32mm x 19mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nSound Generator Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.sound(\ndriver\n, \naddr\n)\n\n\nsetVolume(\nvolume\n)\n\n\nsetPitch(\npitch\n)\n\n\nsetDuration(\nduration\n)\n\n\ngetDuration()\n\n\nsetSound(\nvolume\n, \npitch\n, \nduration\n)\n\n\nsetSoundBlocking(\nvolume\n, \npitch\n, \nduration\n, \npause\n)\n\n\n\n\n\n\nFusion.sound(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Sound Generator and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nSound Generator Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns1 = Fusion.sound(f)\ns2 = Fusion.sound(f, 0x40)\n\n\n\n\n\n\n\nsetVolume(\nvolume\n)\n\n\n\n\nDefinition\n\n\n\n\nControls the amplitude of the output signal from 0 (\nLOW\n) to 3 (\nMAX\n).\n\n\n\n\nConstants\n\n\n\n\n\n\nParameters\n\n\n\n\nvolume\n : int (0 - 3) (\nLOW\n, \nMED\n, \nHIGH\n, \nMAX\n)  \n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setVolume(s.HIGH)\n\n\n\n\n\n\n\nsetPitch(\npitch\n)\n\n\n\n\nDefinition\n\n\n\n\nThe Pitch controls the frequency of the output in increments of 1Hz. The frequencies range from 1Hz to 5kHz. The speaker resonates at about 2kHz, so the speaker will sound much louder at this frequency.\n\n\n\n\nParameters\n\n\n\n\npitch(Hz)\n : int (0 - 5000)  \n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setPitch(2500)\n\n\n\n\n\n\n\nsetDuration(\nduration\n)\n\n\n\n\nDefinition\n\n\n\n\nThe duration controls the length of the tone in increments of 10ms ranging from 10ms \u2013 2.55s. The duration of the tone begins a countdown and will stop when the counter reaches 0. The duration may be updated at anytime to extend the length of a tone past 2.55s.\n\n\n\n\nParameters\n\n\n\n\nduration(ms)\n : int (0 - 2550)  \n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setDuration(1500)\n\n\n\n\n\n\n\ngetDuration()\n\n\n\n\nDefinition\n\n\n\n\nGet the remaining time of the tone being played. This is useful to updated the tone generated just before the current tone is complete so that there is not a gap of sound.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nduration(ms)\n : int (0 - 2550)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setSound(s.MAX, 2500, 2000)\n\nwhile s.getDuration(): pass\ns.setSound(s.MED, 1500, 1000)\n\n\n\n\n\n\n\nsetSound(\nvolume\n, \npitch\n, \nduration\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function allows the user to set the volume, pitch and duration all in a single call. This tone can be interrupted or change before the duration reaches 0.\n\n\n\n\nConstants\n\n\n\n\n\n\nParameters\n\n\n\n\nvolume\n : int (0 - 3) (\nLOW\n, \nMED\n, \nHIGH\n, \nMAX\n)\n\n\npitch (Hz)\n : int (1 - 5000) \nRecommended not to exceed 5,000Hz\n\n\nduration (ms)\n : int (0 - 2550)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setSound(s.MAX, 2500, 1500)\n\n\n\n\n\n\n\nsetSoundBlocking(\nvolume\n, \npitch\n, \nduration\n, \npause\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function allows the user to set the volume, pitch and duration all in a single call with a blocking function feature. What makes this function different from \nsetSound()\n is that this function blocks other actions while a sound is being played, therefore no other code in the program can run. The parameter \npause\n is the time after the tone until the next line of code is executed.\n\n\n\n\nConstants\n\n\n\n\n\n\nParameters\n\n\n\n\nvolume\n : int (0 - 3) (\nLOW\n, \nMED\n, \nHIGH\n, \nMAX\n)\n\n\npitch (Hz)\n : int (1 - 5000) \nRecommended not to exceed 5,000Hz\n\n\nduration (ms)\n : int (0 - 65535)\n\n\npause (ms)\n : int (0 - 65535)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setSoundBlocking(s.MAX, 2500, 4500, 1000)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Sound Generator", 
            "title": "Sound Generator (45-2016)"
        }, 
        {
            "location": "/Py_Sound_Generator/#sound-generator-45-2016", 
            "text": "The Sound Generator can generate a sound based on volume, pitch and duration. This sensor also can overwrite settings during a tone to change the pitch, volume, or extend the duration of the tone.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x34  Sensor ID Code  : 0x53  Dimensions  : 32mm x 32mm x 19mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  Sound Generator Visual Programming Blocks   List of available functions:      Fusion.sound( driver ,  addr )  setVolume( volume )  setPitch( pitch )  setDuration( duration )  getDuration()  setSound( volume ,  pitch ,  duration )  setSoundBlocking( volume ,  pitch ,  duration ,  pause )", 
            "title": "Sound Generator (45-2016)"
        }, 
        {
            "location": "/Py_Sound_Generator/#fusionsounddriver-addr", 
            "text": "", 
            "title": "Fusion.sound(driver, addr)"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition", 
            "text": "This class contains the necessary drivers for our Sound Generator and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns", 
            "text": "Sound Generator Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example", 
            "text": "import Fusion\nf = Fusion.driver()\ns1 = Fusion.sound(f)\ns2 = Fusion.sound(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#setvolumevolume", 
            "text": "", 
            "title": "setVolume(volume)"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition_1", 
            "text": "Controls the amplitude of the output signal from 0 ( LOW ) to 3 ( MAX ).   Constants", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters_1", 
            "text": "volume  : int (0 - 3) ( LOW ,  MED ,  HIGH ,  MAX )", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setVolume(s.HIGH)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#setpitchpitch", 
            "text": "", 
            "title": "setPitch(pitch)"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition_2", 
            "text": "The Pitch controls the frequency of the output in increments of 1Hz. The frequencies range from 1Hz to 5kHz. The speaker resonates at about 2kHz, so the speaker will sound much louder at this frequency.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters_2", 
            "text": "pitch(Hz)  : int (0 - 5000)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns_2", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setPitch(2500)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#setdurationduration", 
            "text": "", 
            "title": "setDuration(duration)"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition_3", 
            "text": "The duration controls the length of the tone in increments of 10ms ranging from 10ms \u2013 2.55s. The duration of the tone begins a countdown and will stop when the counter reaches 0. The duration may be updated at anytime to extend the length of a tone past 2.55s.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters_3", 
            "text": "duration(ms)  : int (0 - 2550)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns_3", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example_3", 
            "text": "import Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setDuration(1500)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#getduration", 
            "text": "", 
            "title": "getDuration()"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition_4", 
            "text": "Get the remaining time of the tone being played. This is useful to updated the tone generated just before the current tone is complete so that there is not a gap of sound.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters_4", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns_4", 
            "text": "duration(ms)  : int (0 - 2550)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example_4", 
            "text": "import Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setSound(s.MAX, 2500, 2000)\n\nwhile s.getDuration(): pass\ns.setSound(s.MED, 1500, 1000)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#setsoundvolume-pitch-duration", 
            "text": "", 
            "title": "setSound(volume, pitch, duration)"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition_5", 
            "text": "This function allows the user to set the volume, pitch and duration all in a single call. This tone can be interrupted or change before the duration reaches 0.   Constants", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters_5", 
            "text": "volume  : int (0 - 3) ( LOW ,  MED ,  HIGH ,  MAX )  pitch (Hz)  : int (1 - 5000)  Recommended not to exceed 5,000Hz  duration (ms)  : int (0 - 2550)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns_5", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example_5", 
            "text": "import Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setSound(s.MAX, 2500, 1500)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#setsoundblockingvolume-pitch-duration-pause", 
            "text": "", 
            "title": "setSoundBlocking(volume, pitch, duration, pause)"
        }, 
        {
            "location": "/Py_Sound_Generator/#definition_6", 
            "text": "This function allows the user to set the volume, pitch and duration all in a single call with a blocking function feature. What makes this function different from  setSound()  is that this function blocks other actions while a sound is being played, therefore no other code in the program can run. The parameter  pause  is the time after the tone until the next line of code is executed.   Constants", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Sound_Generator/#parameters_6", 
            "text": "volume  : int (0 - 3) ( LOW ,  MED ,  HIGH ,  MAX )  pitch (Hz)  : int (1 - 5000)  Recommended not to exceed 5,000Hz  duration (ms)  : int (0 - 65535)  pause (ms)  : int (0 - 65535)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Sound_Generator/#returns_6", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Sound_Generator/#example_6", 
            "text": "import Fusion\nf = Fusion.driver()\ns = Fusion.sound(f)\ns.setSoundBlocking(s.MAX, 2500, 4500, 1000)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Sound_Generator/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Sound Generator", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/", 
            "text": "IR Seeker V3 (45-2017)\n\n\n\n\nThe IR Seeker V3 consists of 2 photodiodes to locate the direction and intensity of an IR source relative to the front of the sensor. The sensor can detect pulsed infrared light at 600Hz and 1200Hz with a 150\u00b0 field of view. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. Overall detection range is based on the intensity of the IR source being used.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x38\n\n\nSensor ID Code\n : 0x49\n\n\nDimensions\n : 32mm x 32mm x 19mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nIR Seeker V3 Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.seekerV3(\ndriver\n, \naddr\n)\n\n\ngetHeading(\nfrequency\n)\n\n\ngetIntensity(\nfrequency\n)\n\n\ngetLeftRaw(\nfrequency\n)\n\n\ngetRightRaw(\nfrequency\n)\n\n\n\n\n\n\nFusion.seekerV3(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our IR Seeker V3 and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nIR Seeker V3 Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nseek1 = Fusion.seekerV3(f)\nseek2 = Fusion.seekerV3(f, 0x40)\n\n\n\n\n\n\n\ngetHeading(\nfrequency\n)\n\n\n\n\nDefinition\n\n\n\n\nThe heading value gives an indication of the source direction. If the value is negative, then the source is to the left of center. If the value is positive, then the source is to the right of center. The magnitude of the values gives an indication of how far off the axis the source is. If the value is 0, then the source is close to the center of the field of view.\n\n\n\n\nParameters\n\n\n\n\nfrequency\n : 600Hz or 1200Hz\n\n\n\n\nReturns\n\n\n\n\nHeading\n : int (0 - 359)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getHeading(1200)\n\n\n\n\n\n\n\ngetIntensity(\nfrequency\n)\n\n\n\n\nDefinition\n\n\n\n\nThe intensity value represents the magnitude of the receive signal. If this value is set to 0, then there is not enough infrared signal available to estimate the heading value. The value of the intensity will increase as an infrared source approaches the sensor.\n\n\n\n\nParameters\n\n\n\n\nfrequency\n : 600Hz or 1200Hz\n\n\n\n\nReturns\n\n\n\n\nIntensity\n : int (0 - 255)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getIntensity(600)\n\n\n\n\n\n\n\ngetLeftRaw(\nfrequency\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the infrared value read by the left photodiode. The value is dependent on both the position of the infrared source and the intensity of the source.\n\n\n\n\nParameters\n\n\n\n\nfrequency\n : 600Hz or 1200Hz\n\n\n\n\nReturns\n\n\n\n\nDirection\n : int (0 - 65535)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getLeftRaw(1200)\n\n\n\n\n\n\n\ngetRightRaw(\nfrequency\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the infrared value read by the right photodiode. The value is dependent on both the position of the infrared source and the intensity of the source.\n\n\n\n\nParameters\n\n\n\n\nfrequency\n : 600Hz or 1200Hz\n\n\n\n\nReturns\n\n\n\n\nDirection\n : int (0 - 65535)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getRightRaw(1200)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python IR Seeker V3", 
            "title": "IR Seeker V3 (45-2017)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#ir-seeker-v3-45-2017", 
            "text": "The IR Seeker V3 consists of 2 photodiodes to locate the direction and intensity of an IR source relative to the front of the sensor. The sensor can detect pulsed infrared light at 600Hz and 1200Hz with a 150\u00b0 field of view. This device is compatible with all legacy IR sources such as the HiTechnic IR Ball, Beacon, and Beacon V2. Overall detection range is based on the intensity of the IR source being used. Overall detection range is based on the intensity of the IR source being used.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x38  Sensor ID Code  : 0x49  Dimensions  : 32mm x 32mm x 19mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  IR Seeker V3 Visual Programming Blocks   List of available functions:      Fusion.seekerV3( driver ,  addr )  getHeading( frequency )  getIntensity( frequency )  getLeftRaw( frequency )  getRightRaw( frequency )", 
            "title": "IR Seeker V3 (45-2017)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#fusionseekerv3driver-addr", 
            "text": "", 
            "title": "Fusion.seekerV3(driver, addr)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#definition", 
            "text": "This class contains the necessary drivers for our IR Seeker V3 and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#returns", 
            "text": "IR Seeker V3 Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nseek1 = Fusion.seekerV3(f)\nseek2 = Fusion.seekerV3(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#getheadingfrequency", 
            "text": "", 
            "title": "getHeading(frequency)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#definition_1", 
            "text": "The heading value gives an indication of the source direction. If the value is negative, then the source is to the left of center. If the value is positive, then the source is to the right of center. The magnitude of the values gives an indication of how far off the axis the source is. If the value is 0, then the source is close to the center of the field of view.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#parameters_1", 
            "text": "frequency  : 600Hz or 1200Hz", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#returns_1", 
            "text": "Heading  : int (0 - 359)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getHeading(1200)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#getintensityfrequency", 
            "text": "", 
            "title": "getIntensity(frequency)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#definition_2", 
            "text": "The intensity value represents the magnitude of the receive signal. If this value is set to 0, then there is not enough infrared signal available to estimate the heading value. The value of the intensity will increase as an infrared source approaches the sensor.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#parameters_2", 
            "text": "frequency  : 600Hz or 1200Hz", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#returns_2", 
            "text": "Intensity  : int (0 - 255)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getIntensity(600)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#getleftrawfrequency", 
            "text": "", 
            "title": "getLeftRaw(frequency)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#definition_3", 
            "text": "This function returns the infrared value read by the left photodiode. The value is dependent on both the position of the infrared source and the intensity of the source.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#parameters_3", 
            "text": "frequency  : 600Hz or 1200Hz", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#returns_3", 
            "text": "Direction  : int (0 - 65535)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#example_3", 
            "text": "import Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getLeftRaw(1200)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#getrightrawfrequency", 
            "text": "", 
            "title": "getRightRaw(frequency)"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#definition_4", 
            "text": "This function returns the infrared value read by the right photodiode. The value is dependent on both the position of the infrared source and the intensity of the source.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#parameters_4", 
            "text": "frequency  : 600Hz or 1200Hz", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#returns_4", 
            "text": "Direction  : int (0 - 65535)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#example_4", 
            "text": "import Fusion\nf = Fusion.driver()\nseek = Fusion.seekerV3(f)\nprint seek.getRightRaw(1200)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_IR_Seeker_V3/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python IR Seeker V3", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Color_Sensor/", 
            "text": "Color Sensor (45-2018)\n\n\n\n\nThe Color Sensor is used to detect the color of an object or a visible light source. Along with raw and adjusted RGB values, the device can also return a color number corresponding to a the colors listed below in the documentation. Calibration steps must be taken as needed based on the environment and ambient lighting for the most accurate readings. Maximum detection distance of the color sensor is approximately 7cm and it is recommended that during active mode the device is placed at a slight angle to avoid white light reflecting from the LED. \n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x3C\n\n\nSensor ID Code\n : 0x67\n\n\nDimensions\n : 32mm x 32mm x 11mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nColor Sensor Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.color(\ndriver\n, \naddr\n)\n\n\ncolorSetup(\nmode\n, \nrate\n)\n\n\ngetColorNumber()\n\n\ngetRGBIndex()\n\n\ngetColorValue())\n\n\ngetColorIndex())\n\n\ngetColorReading()\n\n\ngetColorNormalized()\n\n\nblackBalance()\n\n\nwhiteBalance()\n\n\n\n\n\n\nFusion.color(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Color Sensor and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nColor Sensor Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncolor1 = Fusion.color(f)\ncolor2 = Fusion.color(f, 0x40)\n\n\n\n\n\n\n\ncolorSetup(\nmode\n, \nrate\n)\n\n\n\n\nDefinition\n\n\n\n\nThis function sets the mode and rate at which the readings are taken. The mode can be either \nActive\n or \nPassive\n.\n\nIn \nActive\n mode, the white LED on the sensor is used to illuminate the surface that it is trying to detect. \nActive\n mode works best when the sensor is looking at an object at a slight angle so that the white light is not picked up by the sensor thus distorting the readings.\n\nIn \nPassive\n mode, the sensor takes readings without the use of the white LED. \nPassive\n mode works best for detecting colored light much like that produced by the \nColor Beacon\n. The rate sets the operational frequency of the sensor that can be either 50Hz or 60Hz. The purpose of this is to eliminate any flickering from ambient light.\n\n\n\n\nConstants\n\n\n\n\n\n\nParameters\n\n\n\n\nmode\n : ACTIVE or PASSIVE \n\n\nrate\n : FIFTY_HZ or SIXTY_HZ\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\ncolor.colorSetup(color.ACTIVE, color.FIFTY_HZ)\n\n\n\n\n\n\n\ngetColorNumber()\n\n\n\n\nDefinition\n\n\n\n\nThis function returns the color number that was read by the sensor. The color number corresponds to the color line below. Some materials or the angle of incidence may affect the results. Test the sensor in your environment thoroughly before applying it to a design.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nColor Number\n : int (0 - 16)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorNumber()\n\n\n\n\n\n\n\ngetRGBIndex()\n\n\n\n\nDefinition\n\n\n\n\nThis function gets the analog values of the three primary color channels with an intensity correction whereby 0xFF is the strongest signal.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nRGB Index\n : int [red, green, blue]\n\n\n\n\nExample\n\n\n\n\nThe following example returns an array of size \n3\n and stores it into the variables \nred\n, \ngreen\n and \nblue\n.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue) = color.getRGBIndex()\nprint red\n\n\n\nTo collect a single value instead of the array, reference the index. This will print the \nred\n value.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getRGBIndex()[0]\n\n\n\n\n\n\n\ngetColorValue()\n\n\n\n\nDefinition\n\n\n\n\nThe color values are returned separately as red, green, blue and white. The color value is a measure of the current detection levels for each primary color.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nColor Value\n : int [red, green, blue, white]\n\n\n\n\nExample\n\n\n\n\nThe following example returns an array of size \n3\n and stores it into the variables \nred\n, \ngreen\n, \nblue\n and \nwhite\n.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue, white) = color.getColorValue()\nprint red\n\n\n\nTo collect a single value instead of the array, reference the index. This will print the \nred\n value.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorValue()[0]\n\n\n\n\n\n\n\ngetColorIndex()\n\n\n\n\nDefinition\n\n\n\n\nThe color index number is a single 6 bit number. Bits (5:4) encode the red signal level, bits (3:2) encode the green signal level and bits (1:0) encode the blue signal levels.\n\n\n\n\n\n\n\n\nD7\n\n\nD6\n\n\nD5\n\n\nD4\n\n\nD3\n\n\nD2\n\n\nD1\n\n\nD0\n\n\n\n\n\n\n\n\n\n\n0\n\n\n0\n\n\nRed 1\n\n\nRed 0\n\n\nGreen 1\n\n\nGreen 0\n\n\nBlue 1\n\n\nBlue 0\n\n\n\n\n\n\n\n\n\n\nRed\n = 0x30\n\n\nGreen\n = 0x0C\n\n\nBlue\n = 0x03\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nColor Index\n : int (0 - 63)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorIndex()\n\n\n\n\n\n\n\ngetColorReading()\n\n\n\n\nDefinition\n\n\n\n\nThis function gets the analog value of the color channels in a 16-bit format. Therefore there is much more detail in the reading as compared to the index reading.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nColor Reading\n : int (0 - 65535)\n\n\n\n\nExample\n\n\n\n\nThe following example returns an array of size \n3\n and stores it into the variables \nred\n, \ngreen\n, \nblue\n and \nwhite\n.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue, white) = color.getColorReading()\nprint red\n\n\n\nTo collect a single value instead of the array, reference the index. This will print the \nred\n value.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorReading()[0]\n\n\n\n\n\n\n\ngetColorNormalized()\n\n\n\n\nDefinition\n\n\n\n\nThis function gets the analog value of the color channel adjusted by the calibration values.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nColor Normalized\n : int [red, green, blue, white]\n\n\n\n\nExample\n\n\n\n\nThe following example returns an array of size \n3\n and stores it into the variables \nred\n, \ngreen\n, \nblue\n and \nwhite\n.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue, white) = color.getColorNormalized()\nprint red\n\n\n\nTo collect a single value instead of the array, reference the index. This will print the \nred\n value.\n\n\nimport Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorNormalized()[0]\n\n\n\n\n\n\n\nblackBalance()\n\n\n\n\nDefinition\n\n\n\n\nThis function gathers data and calculates an average value for each of the three color channels. To calibrate the black balance, point the sensor so that there is no object within 5 feet (1.5m) forward of the sensor. Calibration takes approximately 1.5 seconds. This function must be called before the \nwhiteBalance()\n function because the white balance calculations are dependent on the black balance values.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\ncolor = Fusion.color(f)\ncolor.blackBalance()\ntime.sleep(2)\n\n\n\n\n\n\n\nwhiteBalance()\n\n\n\n\nDefinition\n\n\n\n\nThis function gathers data and calculates and average value for each of the three color channels. Then the values are adjusted based on the readings from the \nblackBalance()\n function. When calibrating, hold the sensor no more than 2 inches (5cm) away from a white target. The target must be very white, using a white board or 3 layers of high quality copy paper. Calibration takes approximately 1.5 seconds.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\ncolor = Fusion.color(f)\ncolor.blackBalance()\ntime.sleep(2)\ncolor.whiteBalance()\ntime.sleep(2)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Color Sensor", 
            "title": "Color Sensor (45-2018)"
        }, 
        {
            "location": "/Py_Color_Sensor/#color-sensor-45-2018", 
            "text": "The Color Sensor is used to detect the color of an object or a visible light source. Along with raw and adjusted RGB values, the device can also return a color number corresponding to a the colors listed below in the documentation. Calibration steps must be taken as needed based on the environment and ambient lighting for the most accurate readings. Maximum detection distance of the color sensor is approximately 7cm and it is recommended that during active mode the device is placed at a slight angle to avoid white light reflecting from the LED.    Sensor Type  : Four Wire I2C  Default I2C Address  : 0x3C  Sensor ID Code  : 0x67  Dimensions  : 32mm x 32mm x 11mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  Color Sensor Visual Programming Blocks   List of available functions:      Fusion.color( driver ,  addr )  colorSetup( mode ,  rate )  getColorNumber()  getRGBIndex()  getColorValue())  getColorIndex())  getColorReading()  getColorNormalized()  blackBalance()  whiteBalance()", 
            "title": "Color Sensor (45-2018)"
        }, 
        {
            "location": "/Py_Color_Sensor/#fusioncolordriver-addr", 
            "text": "", 
            "title": "Fusion.color(driver, addr)"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition", 
            "text": "This class contains the necessary drivers for our Color Sensor and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns", 
            "text": "Color Sensor Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example", 
            "text": "import Fusion\nf = Fusion.driver()\ncolor1 = Fusion.color(f)\ncolor2 = Fusion.color(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#colorsetupmode-rate", 
            "text": "", 
            "title": "colorSetup(mode, rate)"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_1", 
            "text": "This function sets the mode and rate at which the readings are taken. The mode can be either  Active  or  Passive . \nIn  Active  mode, the white LED on the sensor is used to illuminate the surface that it is trying to detect.  Active  mode works best when the sensor is looking at an object at a slight angle so that the white light is not picked up by the sensor thus distorting the readings. \nIn  Passive  mode, the sensor takes readings without the use of the white LED.  Passive  mode works best for detecting colored light much like that produced by the  Color Beacon . The rate sets the operational frequency of the sensor that can be either 50Hz or 60Hz. The purpose of this is to eliminate any flickering from ambient light.   Constants", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_1", 
            "text": "mode  : ACTIVE or PASSIVE   rate  : FIFTY_HZ or SIXTY_HZ", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\ncolor.colorSetup(color.ACTIVE, color.FIFTY_HZ)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#getcolornumber", 
            "text": "", 
            "title": "getColorNumber()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_2", 
            "text": "This function returns the color number that was read by the sensor. The color number corresponds to the color line below. Some materials or the angle of incidence may affect the results. Test the sensor in your environment thoroughly before applying it to a design.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_2", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_2", 
            "text": "Color Number  : int (0 - 16)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_2", 
            "text": "import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorNumber()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#getrgbindex", 
            "text": "", 
            "title": "getRGBIndex()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_3", 
            "text": "This function gets the analog values of the three primary color channels with an intensity correction whereby 0xFF is the strongest signal.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_3", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_3", 
            "text": "RGB Index  : int [red, green, blue]", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_3", 
            "text": "The following example returns an array of size  3  and stores it into the variables  red ,  green  and  blue .  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue) = color.getRGBIndex()\nprint red  To collect a single value instead of the array, reference the index. This will print the  red  value.  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getRGBIndex()[0]", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#getcolorvalue", 
            "text": "", 
            "title": "getColorValue()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_4", 
            "text": "The color values are returned separately as red, green, blue and white. The color value is a measure of the current detection levels for each primary color.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_4", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_4", 
            "text": "Color Value  : int [red, green, blue, white]", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_4", 
            "text": "The following example returns an array of size  3  and stores it into the variables  red ,  green ,  blue  and  white .  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue, white) = color.getColorValue()\nprint red  To collect a single value instead of the array, reference the index. This will print the  red  value.  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorValue()[0]", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#getcolorindex", 
            "text": "", 
            "title": "getColorIndex()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_5", 
            "text": "The color index number is a single 6 bit number. Bits (5:4) encode the red signal level, bits (3:2) encode the green signal level and bits (1:0) encode the blue signal levels.     D7  D6  D5  D4  D3  D2  D1  D0      0  0  Red 1  Red 0  Green 1  Green 0  Blue 1  Blue 0      Red  = 0x30  Green  = 0x0C  Blue  = 0x03", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_5", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_5", 
            "text": "Color Index  : int (0 - 63)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_5", 
            "text": "import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorIndex()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#getcolorreading", 
            "text": "", 
            "title": "getColorReading()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_6", 
            "text": "This function gets the analog value of the color channels in a 16-bit format. Therefore there is much more detail in the reading as compared to the index reading.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_6", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_6", 
            "text": "Color Reading  : int (0 - 65535)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_6", 
            "text": "The following example returns an array of size  3  and stores it into the variables  red ,  green ,  blue  and  white .  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue, white) = color.getColorReading()\nprint red  To collect a single value instead of the array, reference the index. This will print the  red  value.  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorReading()[0]", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#getcolornormalized", 
            "text": "", 
            "title": "getColorNormalized()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_7", 
            "text": "This function gets the analog value of the color channel adjusted by the calibration values.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_7", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_7", 
            "text": "Color Normalized  : int [red, green, blue, white]", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_7", 
            "text": "The following example returns an array of size  3  and stores it into the variables  red ,  green ,  blue  and  white .  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\n(red, green, blue, white) = color.getColorNormalized()\nprint red  To collect a single value instead of the array, reference the index. This will print the  red  value.  import Fusion\nf = Fusion.driver()\ncolor = Fusion.color(f)\nprint color.getColorNormalized()[0]", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#blackbalance", 
            "text": "", 
            "title": "blackBalance()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_8", 
            "text": "This function gathers data and calculates an average value for each of the three color channels. To calibrate the black balance, point the sensor so that there is no object within 5 feet (1.5m) forward of the sensor. Calibration takes approximately 1.5 seconds. This function must be called before the  whiteBalance()  function because the white balance calculations are dependent on the black balance values.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_8", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_8", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_8", 
            "text": "import Fusion\nimport time\nf = Fusion.driver()\ncolor = Fusion.color(f)\ncolor.blackBalance()\ntime.sleep(2)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#whitebalance", 
            "text": "", 
            "title": "whiteBalance()"
        }, 
        {
            "location": "/Py_Color_Sensor/#definition_9", 
            "text": "This function gathers data and calculates and average value for each of the three color channels. Then the values are adjusted based on the readings from the  blackBalance()  function. When calibrating, hold the sensor no more than 2 inches (5cm) away from a white target. The target must be very white, using a white board or 3 layers of high quality copy paper. Calibration takes approximately 1.5 seconds.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Sensor/#parameters_9", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Sensor/#returns_9", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Sensor/#example_9", 
            "text": "import Fusion\nimport time\nf = Fusion.driver()\ncolor = Fusion.color(f)\ncolor.blackBalance()\ntime.sleep(2)\ncolor.whiteBalance()\ntime.sleep(2)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Color Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Color_Beacon/", 
            "text": "Color Beacon (45-2019)\n\n\n\n\nThe Color Beacon is used to display one of seven colors or any set custom color based on RGB values.\n\nThe beacon can also indicate \nRed\n/\nBlue\n team colors with the use of a magnet. There is no code or setup needed to operate as a team indicator. There is a Hall Effect sensor located on the left side of the sensors (wire pointed toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to \nRed\n, \nBlue\n or \nOff\n. This can be done at any time and will overwrite any custom color or color number. When the beacon is \nRed\n or \nBlue\n from the Hall Effect sensor, it will be locked in that mode until turned \nOff\n using a magnet or disconnecting the sensor.\n\n\n\n\nSensor Type\n : Four Wire I2C\n\n\nDefault I2C Address\n : 0x4C\n\n\nSensor ID Code\n : 0x75\n\n\nDimensions\n : 56mm x 32mm x 17mm\n\n\nMounting Holes\n : 48mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Logic 0 - 0V, Logic 1 - 5V\n\n\nI2C Bus Speed\n : 100kHz max\n\n\nI2C Address Change Option\n : Yes (Even Number 0x10 - 0xEE)\n\n\nLED Brightness\n : 840 Red, 1680 Green, 420 Blue mcd (millicandela)\n\n\nColor Beacon Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.ColorBeacon(\ndriver\n, \naddr\n)\n\n\nsetColor(\ncolor\n)\n\n\nsetCustomColor(\nred\n, \ngreen\n, \nblue\n)\n\n\n\n\n\n\nFusion.colorBeacon(\ndriver\n, \naddr\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Color Beacon and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\naddr\n : Enter an I2C address in hexadecimal if different from default \n\n\n\n\nReturns\n\n\n\n\nColor Beacon Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nbeacon1 = Fusion.colorBeacon(f)\nbeacon2 = Fusion.colorBeacon(f, 0x40)\n\n\n\n\n\n\n\nsetColor(\ncolor\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the color of the LED using the number of the color.\n\n\n\n\n\n\n\n    \nNumber\nColor\n\n    \n0\nOff\n\n    \n1\nRed\n\n    \n2\nGreen\n\n    \n3\nYellow\n\n    \n4\nBlue\n\n    \n5\nPurple\n\n    \n6\nTeal\n\n    \n7\nWhite\n\n\n\n\n\n\n\nParameters\n\n\n\n\ncolor\n : int (0 - 7)  \n\n\n\n\nReturns\n\n\n\n\nNone\n  \n\n\n\n\nExample\n\n\n\n\nimport Fusion  \nimport time  \nf = Fusion.driver()  \nbeacon = Fusion.colorBeacon(f)\n\n\n\n\n\n\n\nbeacon.setColor(1)  \ntime.sleep(1)  \nbeacon.setColor(2)  \ntime.sleep(1)  \nbeacon.setColor(4)  \ntime.sleep(1)\n\n\n\nsetCustomColor(\nred\n, \ngreen\n, \nblue\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the color of the LED using a value 0-255 for \nRed\n, \nGreen\n and \nBlue\n.\n\n\n\n\nParameters\n\n\n\n\nred\n : int (0 - 255)\n\n\ngreen\n : int (0 - 255)\n\n\nblue\n : int (0 - 255)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nimport time\nf = Fusion.driver()\nbeacon = Fusion.colorBeacon(f)\n\n\n\n\n\n\n\nbeacon.setCustomColor(255, 0, 0)\ntime.sleep(1)\nbeacon.setCustomColor(0, 255, 0)\ntime.sleep(1)\nbeacon.setCustomColor(0, 0, 255)\ntime.sleep(1)\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Color Beacon", 
            "title": "Color Beacon (45-2019)"
        }, 
        {
            "location": "/Py_Color_Beacon/#color-beacon-45-2019", 
            "text": "The Color Beacon is used to display one of seven colors or any set custom color based on RGB values. \nThe beacon can also indicate  Red / Blue  team colors with the use of a magnet. There is no code or setup needed to operate as a team indicator. There is a Hall Effect sensor located on the left side of the sensors (wire pointed toward you). By holding a magnet over the top of the sensor it will blink green. After the green blink the beacon will be set to  Red ,  Blue  or  Off . This can be done at any time and will overwrite any custom color or color number. When the beacon is  Red  or  Blue  from the Hall Effect sensor, it will be locked in that mode until turned  Off  using a magnet or disconnecting the sensor.   Sensor Type  : Four Wire I2C  Default I2C Address  : 0x4C  Sensor ID Code  : 0x75  Dimensions  : 56mm x 32mm x 17mm  Mounting Holes  : 48mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Logic 0 - 0V, Logic 1 - 5V  I2C Bus Speed  : 100kHz max  I2C Address Change Option  : Yes (Even Number 0x10 - 0xEE)  LED Brightness  : 840 Red, 1680 Green, 420 Blue mcd (millicandela)  Color Beacon Visual Programming Blocks   List of available functions:      Fusion.ColorBeacon( driver ,  addr )  setColor( color )  setCustomColor( red ,  green ,  blue )", 
            "title": "Color Beacon (45-2019)"
        }, 
        {
            "location": "/Py_Color_Beacon/#fusioncolorbeacondriver-addr", 
            "text": "", 
            "title": "Fusion.colorBeacon(driver, addr)"
        }, 
        {
            "location": "/Py_Color_Beacon/#definition", 
            "text": "This class contains the necessary drivers for our Color Beacon and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Beacon/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  addr  : Enter an I2C address in hexadecimal if different from default", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Beacon/#returns", 
            "text": "Color Beacon Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Beacon/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nbeacon1 = Fusion.colorBeacon(f)\nbeacon2 = Fusion.colorBeacon(f, 0x40)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Beacon/#setcolorcolor", 
            "text": "", 
            "title": "setColor(color)"
        }, 
        {
            "location": "/Py_Color_Beacon/#definition_1", 
            "text": "Set the color of the LED using the number of the color.    \n     Number Color \n     0 Off \n     1 Red \n     2 Green \n     3 Yellow \n     4 Blue \n     5 Purple \n     6 Teal \n     7 White", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Beacon/#parameters_1", 
            "text": "color  : int (0 - 7)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Beacon/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Beacon/#example_1", 
            "text": "import Fusion  \nimport time  \nf = Fusion.driver()  \nbeacon = Fusion.colorBeacon(f)    beacon.setColor(1)  \ntime.sleep(1)  \nbeacon.setColor(2)  \ntime.sleep(1)  \nbeacon.setColor(4)  \ntime.sleep(1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Beacon/#setcustomcolorred-green-blue", 
            "text": "", 
            "title": "setCustomColor(red, green, blue)"
        }, 
        {
            "location": "/Py_Color_Beacon/#definition_2", 
            "text": "Set the color of the LED using a value 0-255 for  Red ,  Green  and  Blue .", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Color_Beacon/#parameters_2", 
            "text": "red  : int (0 - 255)  green  : int (0 - 255)  blue  : int (0 - 255)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Color_Beacon/#returns_2", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Color_Beacon/#example_2", 
            "text": "import Fusion\nimport time\nf = Fusion.driver()\nbeacon = Fusion.colorBeacon(f)    beacon.setCustomColor(255, 0, 0)\ntime.sleep(1)\nbeacon.setCustomColor(0, 255, 0)\ntime.sleep(1)\nbeacon.setCustomColor(0, 0, 255)\ntime.sleep(1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Color_Beacon/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Color Beacon", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/", 
            "text": "Magnetic Sensor (45-2020)\n\n\n\n\nThe Magnetic Sensor detects a magnetic field and returns the strength based on the distance between the sensor element and the magnet. The default returned by the sensor when no magnetic field is present is approximately 340. When the returned value is increasing, the sensor is detecting the \"North Pole\" of the magnet. If the value returned is decreasing, then the sensor is detecting the \"South Pole\" of the magnet.\n\n\n\n\nSensor Type\n : Three Wire Analog\n\n\nDimensions\n : 32mm x 32mm x 12mm\n\n\nMounting Holes\n : 24mm x 24mm\n\n\nPower\n : 5V DC, 22mA Max\n\n\nSignal Logic Levels\n : Analog 0V - 5V\n\n\nMagnetic Sensor Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\nread()\n\n\n\n\n\n\nFusion.analog(\ndriver\n, \nport\n)\n\n\n\n\nDefinition\n\n\n\n\nThe following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion. \n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nf\n)\n\n\nport\n : Analog port the sensor is connected to A0 - A7\n\n\n\n\nReturns\n\n\n\n\nAnalog Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmag_A0 = Fusion.analog(f, f.A0)\n\n\n\n\n\n\n\nread()\n\n\n\n\nDefinition\n\n\n\n\nReturns the current magnetic intensity in the North or South direction.\n\n\n\n\nValue of 340 indicates no magnetic field detected.\n\n\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nMagnetic Strength\n : int (0 - 1023) \u2248(0 - 700)\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nmag_A0 = Fusion.analog(f, f.A0)\nprint mag_A0.read()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Magnetic Sensor", 
            "title": "Magnetic Sensor (45-2020)"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#magnetic-sensor-45-2020", 
            "text": "The Magnetic Sensor detects a magnetic field and returns the strength based on the distance between the sensor element and the magnet. The default returned by the sensor when no magnetic field is present is approximately 340. When the returned value is increasing, the sensor is detecting the \"North Pole\" of the magnet. If the value returned is decreasing, then the sensor is detecting the \"South Pole\" of the magnet.   Sensor Type  : Three Wire Analog  Dimensions  : 32mm x 32mm x 12mm  Mounting Holes  : 24mm x 24mm  Power  : 5V DC, 22mA Max  Signal Logic Levels  : Analog 0V - 5V  Magnetic Sensor Visual Programming Blocks   List of available functions:      Fusion.analog( driver ,  port )  read()", 
            "title": "Magnetic Sensor (45-2020)"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#fusionanalogdriver-port", 
            "text": "", 
            "title": "Fusion.analog(driver, port)"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#definition", 
            "text": "The following class provides a wrapper for the analog function to tie sensor names directly to the port and read all in one simple motion.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( f )  port  : Analog port the sensor is connected to A0 - A7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#returns", 
            "text": "Analog Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nmag_A0 = Fusion.analog(f, f.A0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#read", 
            "text": "", 
            "title": "read()"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#definition_1", 
            "text": "Returns the current magnetic intensity in the North or South direction.   Value of 340 indicates no magnetic field detected.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#returns_1", 
            "text": "Magnetic Strength  : int (0 - 1023) \u2248(0 - 700)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#example_1", 
            "text": "import Fusion\nf = Fusion.driver()\nmag_A0 = Fusion.analog(f, f.A0)\nprint mag_A0.read()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Magnetic_Sensor/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Magnetic Sensor", 
            "title": "Questions?"
        }, 
        {
            "location": "/Core_Control_Topic/", 
            "text": "Core Control Module Reference\n\n\n\n\nThe Core Control Modules bring a powerful 12V system to the Fusion Controller to control bigger and stronger robots.", 
            "title": "Core Control Modules"
        }, 
        {
            "location": "/Core_Control_Topic/#core-control-module-reference", 
            "text": "The Core Control Modules bring a powerful 12V system to the Fusion Controller to control bigger and stronger robots.", 
            "title": "Core Control Module Reference"
        }, 
        {
            "location": "/Core_Motor_Controller/", 
            "text": "Core Motor Controller (45-2203)\n\n\n\n\nThe Core Motor Controller has two motor channels to connect 9V \u2013 15V DC motors. Through the Motor Controller functions, you can control the speed and direction of each motor. Each motor channel port has an encoder for feedback. The Core Motor Controller is powered by the Core Power Distribution Module using the supplied power cable.\n\nThe Motor Controller has three models for motor control and each channel can be independently controlled by the user program. The three modes of operation are;\n\n\n\n\nRun with Constant Power\n \u2013 Set the motor speed and direction.  \n\n\nRun at Constant Speed\n \u2013 Set the desired motor speed and the controller will maintain that speed, even if there is a change of load on the motor.  \n\n\nRun to Position\n \u2013 Set the desired encoder position and the controller will move the motor until the target position is reached and then it will maintain that motor position.\n\n\n\n\n\n\nMotor channels can be set to reverse so that motors on the left and right side of the robot drive forwards when both given a positive power.  \n\n\n\n\nPower\n : 9V - 15V DC, 10A max\n\n\nMotor Power\n : 9V - 15V DC, 5A max\n\n\nMotor Encoder\n : Two phase, 5V DC, 50mA max\n\n\nUSB Driver\n : FTDI VCP\n\n\nUSB Connection\n : USB-Mini\n\n\nConstant Power\n : -100% - +100%\n\n\nConstant Speed\n : -100% - +100%\n\n\nTo Position\n : Constant Speed to position with 32 bit value\n\n\nBrake Mode\n : FLOAT or BRAKE\n\n\nBattery Voltage Monitoring\n : 0V - 20V with 20mV resolution\n\n\nDimensions\n : 72mm x 88mm x 24mm\n\n\nWeight\n : 67 grams  \n\n\nCore Motor Controller Visual Programming Blocks\n\n\nCore Motor Controller Python Library Information\n  \n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Core Motor Controller", 
            "title": "Core Motor Controller"
        }, 
        {
            "location": "/Core_Motor_Controller/#core-motor-controller-45-2203", 
            "text": "The Core Motor Controller has two motor channels to connect 9V \u2013 15V DC motors. Through the Motor Controller functions, you can control the speed and direction of each motor. Each motor channel port has an encoder for feedback. The Core Motor Controller is powered by the Core Power Distribution Module using the supplied power cable. \nThe Motor Controller has three models for motor control and each channel can be independently controlled by the user program. The three modes of operation are;   Run with Constant Power  \u2013 Set the motor speed and direction.    Run at Constant Speed  \u2013 Set the desired motor speed and the controller will maintain that speed, even if there is a change of load on the motor.    Run to Position  \u2013 Set the desired encoder position and the controller will move the motor until the target position is reached and then it will maintain that motor position.    Motor channels can be set to reverse so that motors on the left and right side of the robot drive forwards when both given a positive power.     Power  : 9V - 15V DC, 10A max  Motor Power  : 9V - 15V DC, 5A max  Motor Encoder  : Two phase, 5V DC, 50mA max  USB Driver  : FTDI VCP  USB Connection  : USB-Mini  Constant Power  : -100% - +100%  Constant Speed  : -100% - +100%  To Position  : Constant Speed to position with 32 bit value  Brake Mode  : FLOAT or BRAKE  Battery Voltage Monitoring  : 0V - 20V with 20mV resolution  Dimensions  : 72mm x 88mm x 24mm  Weight  : 67 grams    Core Motor Controller Visual Programming Blocks  Core Motor Controller Python Library Information", 
            "title": "Core Motor Controller (45-2203)"
        }, 
        {
            "location": "/Core_Motor_Controller/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Core Motor Controller", 
            "title": "Questions?"
        }, 
        {
            "location": "/Core_Servo_Controller/", 
            "text": "Core Servo Controller (45-2204)\n\n\n\n\nThe Core Servo Controller has six (6) servo ports to connect 6V digital or analog servos. The position of each servo can be independently set and once set the servo will move to the desired position.\n\n\n\n\nPower\n : 9V - 15V DC, 4A max\n\n\nServo Power Limit - Continuous\n : 6V DC, 5A\n\n\nServo Power Limit - Peak\n : 6V DC, 6A\n\n\nUSB Driver\n : FTDI VCP\n\n\nUSB Connection\n : USB-Mini\n\n\nServo Logic Level\n : 5V TTL\n\n\nServo Range\n : 750uS - 2250uS\n\n\nServo Extended Range\n : 500uS - 2500uS\n\n\nSeries Resistor\n : 470 ohm\n\n\nDimensions\n : 72mm x 88mm x 24mm\n\n\nWeight\n : 70 grams \n\n\nCore Servo Controller Visual Programming Blocks\n\n\nCore Servo Controller Python Library Information\n  \n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Core Servo Controller", 
            "title": "Core Servo Controller"
        }, 
        {
            "location": "/Core_Servo_Controller/#core-servo-controller-45-2204", 
            "text": "The Core Servo Controller has six (6) servo ports to connect 6V digital or analog servos. The position of each servo can be independently set and once set the servo will move to the desired position.   Power  : 9V - 15V DC, 4A max  Servo Power Limit - Continuous  : 6V DC, 5A  Servo Power Limit - Peak  : 6V DC, 6A  USB Driver  : FTDI VCP  USB Connection  : USB-Mini  Servo Logic Level  : 5V TTL  Servo Range  : 750uS - 2250uS  Servo Extended Range  : 500uS - 2500uS  Series Resistor  : 470 ohm  Dimensions  : 72mm x 88mm x 24mm  Weight  : 70 grams   Core Servo Controller Visual Programming Blocks  Core Servo Controller Python Library Information", 
            "title": "Core Servo Controller (45-2204)"
        }, 
        {
            "location": "/Core_Servo_Controller/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Core Servo Controller", 
            "title": "Questions?"
        }, 
        {
            "location": "/Core_Device_Interface/", 
            "text": "Core Device Interface (45-2201)\n\n\n\n\nThe Core Device Interface (CDI) connects external sensors and other devices. With a total of 26 port connections divided into 5 general classes, the CDI gives a convenient way to attach a wide range of our sensors, or brew your own devices and control your world.\n\n\n\n\nPower\n : 5V DC, 200mA max\n\n\nTotal Port Power\n : 5V DC, 150mA max\n\n\nUSB Driver\n : FTDI VCP\n\n\nUSB Connection\n : USB-Mini\n\n\nDigital Logic Level\n : 5V TTL\n\n\nDigital Series Resistor\n : 220 ohm\n\n\nDigital Current Limit\n : 22mA\n\n\nAnalog Voltage Levels\n : 0V - 5V DC\n\n\nAnalog Resolution\n : 10 bit\n\n\nAnalog Output Voltage Levels\n : -4V - +4V\n\n\nAnalog Output Modes\n : DC, Sine, Square or Triangle\n\n\nAnalog Output Frequency\n : 0Hz - 8kHz\n\n\nAnalog Output Current Limit\n : 4mA\n\n\nI2C Bus\n : 100kHz with 27 Byte buffer\n\n\nI2C Logic Level\n : 5V TTL\n\n\nI2C Pull-Up Resistor\n : 47k ohm\n\n\nI2C Series Resistor\n : 47 ohm\n\n\nPWM Logic Level\n : 5V TTL\n\n\nPWM Output Frequency\n : 1uS - 65,535uS\n\n\nPWM Series Resistor\n : 220 ohm\n\n\nPWM Current Limit\n : 22mA\n\n\nDimensions\n : 72mm x 73mm x 16.2mm\n\n\nWeight\n : 45 grams\n\n\nCore Device Interface Visual Programming Blocks\n\n\nCore Device Interface Python Library Information\n  \n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Core Device Interface", 
            "title": "Core Device Interface"
        }, 
        {
            "location": "/Core_Device_Interface/#core-device-interface-45-2201", 
            "text": "The Core Device Interface (CDI) connects external sensors and other devices. With a total of 26 port connections divided into 5 general classes, the CDI gives a convenient way to attach a wide range of our sensors, or brew your own devices and control your world.   Power  : 5V DC, 200mA max  Total Port Power  : 5V DC, 150mA max  USB Driver  : FTDI VCP  USB Connection  : USB-Mini  Digital Logic Level  : 5V TTL  Digital Series Resistor  : 220 ohm  Digital Current Limit  : 22mA  Analog Voltage Levels  : 0V - 5V DC  Analog Resolution  : 10 bit  Analog Output Voltage Levels  : -4V - +4V  Analog Output Modes  : DC, Sine, Square or Triangle  Analog Output Frequency  : 0Hz - 8kHz  Analog Output Current Limit  : 4mA  I2C Bus  : 100kHz with 27 Byte buffer  I2C Logic Level  : 5V TTL  I2C Pull-Up Resistor  : 47k ohm  I2C Series Resistor  : 47 ohm  PWM Logic Level  : 5V TTL  PWM Output Frequency  : 1uS - 65,535uS  PWM Series Resistor  : 220 ohm  PWM Current Limit  : 22mA  Dimensions  : 72mm x 73mm x 16.2mm  Weight  : 45 grams  Core Device Interface Visual Programming Blocks  Core Device Interface Python Library Information", 
            "title": "Core Device Interface (45-2201)"
        }, 
        {
            "location": "/Core_Device_Interface/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Core Device Interface", 
            "title": "Questions?"
        }, 
        {
            "location": "/Core_Legacy_Module/", 
            "text": "Core Legacy Module (45-2202)\n\n\n\n\nOur Core Legacy Module provides backward compatibility to enable LEGO NXT devices. The Legacy Module has six (6) ports and virtually any combination of devices can be connected to the module. The Legacy module firmware supports all NXT LEGO sensors, HiTechnic sensors, Matrix controllers as well as the HiTechnic Tetrix motor and servo controllers. The Fusion can read and write each device separately and by utilizing the speed of the USB connection, a program can read all 6 ports at once. The Legacy Module is powered from the USB connection. Each Legacy Module port can operate in digital as well as analog modes. In digital mode, legacy connector pins 5 and 6 can be set to logic 0 or logic 1. In analog mode, the voltage on legacy connector pin 1 is measured using a 10 bit analog to digital converter. Additionally, pins 5 and 6 can be set to logic 0 or logic 1 for control of the attached device, such as a LEGO light sensor which uses pin 5 to turn the sensor LED on and off. In I2C mode, legacy connector pins 5 and 6 are used to communicate with I2C devices in accordance with the LEGO interpretation of I2C. Ports 4 and 5 can additionally be switched into pin 1 9V supply mode to permit LEGO ultrasonic range sensors to be used.\n\n\n\n\nPower\n : 5V DC, 200mA max\n\n\nSupported Devices\n : LEGO NXT sensors, HiTechnic sensors and controllers\n\n\nUSB Driver\n : FTDI VCP\n\n\nUSB Connection\n : USB-Mini\n\n\nAnalog and Digital Ports\n : 5V TTL with 9V option on S4 and S5\n\n\nI2C\n : 27 Byte data buffer per port\n\n\nDimensions\n : 72mm x 73mm x 73mm \n\n\nWeight\n : 53 grams\n\n\nCore Legacy Module Visual Programming Blocks\n\n\nCore Legacy Module Python Library Information\n  \n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Core Legacy Module", 
            "title": "Core Legacy Module"
        }, 
        {
            "location": "/Core_Legacy_Module/#core-legacy-module-45-2202", 
            "text": "Our Core Legacy Module provides backward compatibility to enable LEGO NXT devices. The Legacy Module has six (6) ports and virtually any combination of devices can be connected to the module. The Legacy module firmware supports all NXT LEGO sensors, HiTechnic sensors, Matrix controllers as well as the HiTechnic Tetrix motor and servo controllers. The Fusion can read and write each device separately and by utilizing the speed of the USB connection, a program can read all 6 ports at once. The Legacy Module is powered from the USB connection. Each Legacy Module port can operate in digital as well as analog modes. In digital mode, legacy connector pins 5 and 6 can be set to logic 0 or logic 1. In analog mode, the voltage on legacy connector pin 1 is measured using a 10 bit analog to digital converter. Additionally, pins 5 and 6 can be set to logic 0 or logic 1 for control of the attached device, such as a LEGO light sensor which uses pin 5 to turn the sensor LED on and off. In I2C mode, legacy connector pins 5 and 6 are used to communicate with I2C devices in accordance with the LEGO interpretation of I2C. Ports 4 and 5 can additionally be switched into pin 1 9V supply mode to permit LEGO ultrasonic range sensors to be used.   Power  : 5V DC, 200mA max  Supported Devices  : LEGO NXT sensors, HiTechnic sensors and controllers  USB Driver  : FTDI VCP  USB Connection  : USB-Mini  Analog and Digital Ports  : 5V TTL with 9V option on S4 and S5  I2C  : 27 Byte data buffer per port  Dimensions  : 72mm x 73mm x 73mm   Weight  : 53 grams  Core Legacy Module Visual Programming Blocks  Core Legacy Module Python Library Information", 
            "title": "Core Legacy Module (45-2202)"
        }, 
        {
            "location": "/Core_Legacy_Module/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Core Legacy Module", 
            "title": "Questions?"
        }, 
        {
            "location": "/Core_Power_Distribution_Module/", 
            "text": "Core Power Distribution Module (45-2200)\n\n\n\n\nOur Core Power Distribution Module incorporates a 7 port USB 2.0 hub and 6 x 12V power distribution terminals with Anderson PowerPole\u00ae connectors. The Power Distribution Module offers a convenient and safe way to wire your robot's 12V supply from the battery to all motor, servo and other modules that require 12V. All modules are protected by a 20A replaceable fuse and an integrated on/off switch.\n\nIncluded with the Power Distribution Module is 1 On-The-Go cable to connect the module to an Android device. The OTG cable is USB-Micro to USB-Mini.\n\n\n\n\nPower\n : 9V- 15V DC, 20A max\n\n\nTotal Port Power Limit\n : 9V - 15V DC, 18A max (sum of all ports not to exceed max power limit)\n\n\nIndividual USB Hub Current Limit\n : 500mA max\n\n\nTotal USB Hub Current Limit\n : 4A max\n\n\nUSB Control Connection\n : USB-Mini, no 5V connection\n\n\nUSB Hub Connection\n : 7 Ports, USB-A \n\n\nNumber of Power Ports\n : 6 Ports max\n\n\nDimensions\n : 96mm x 105mm x 24mm\n\n\nWeight\n : 138 grams   \n\n\n\n\n\n\n12V\n \u2013 Indicates 12v supply is connected and the power switch is on.\n\n\n5V\n \u2013 Indicates the 5v power supply is operating and supplying 5v to the USB ports.\n\n\n3.3V\n \u2013 Indicates the 3.3 volt supply to the internal electronics is operating.\n\n\nUSB Enabled\n \u2013 Indicates a host device is connected to the USB input port.\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Core Power Distribution Module", 
            "title": "Core Power Distribution Module"
        }, 
        {
            "location": "/Core_Power_Distribution_Module/#core-power-distribution-module-45-2200", 
            "text": "Our Core Power Distribution Module incorporates a 7 port USB 2.0 hub and 6 x 12V power distribution terminals with Anderson PowerPole\u00ae connectors. The Power Distribution Module offers a convenient and safe way to wire your robot's 12V supply from the battery to all motor, servo and other modules that require 12V. All modules are protected by a 20A replaceable fuse and an integrated on/off switch. \nIncluded with the Power Distribution Module is 1 On-The-Go cable to connect the module to an Android device. The OTG cable is USB-Micro to USB-Mini.   Power  : 9V- 15V DC, 20A max  Total Port Power Limit  : 9V - 15V DC, 18A max (sum of all ports not to exceed max power limit)  Individual USB Hub Current Limit  : 500mA max  Total USB Hub Current Limit  : 4A max  USB Control Connection  : USB-Mini, no 5V connection  USB Hub Connection  : 7 Ports, USB-A   Number of Power Ports  : 6 Ports max  Dimensions  : 96mm x 105mm x 24mm  Weight  : 138 grams       12V  \u2013 Indicates 12v supply is connected and the power switch is on.  5V  \u2013 Indicates the 5v power supply is operating and supplying 5v to the USB ports.  3.3V  \u2013 Indicates the 3.3 volt supply to the internal electronics is operating.  USB Enabled  \u2013 Indicates a host device is connected to the USB input port.", 
            "title": "Core Power Distribution Module (45-2200)"
        }, 
        {
            "location": "/Core_Power_Distribution_Module/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Core Power Distribution Module", 
            "title": "Questions?"
        }, 
        {
            "location": "/CoreControlDriver/", 
            "text": "Core Control Module Driver\n\n\n\n\nThe Core Control Driver is used to set up all the Core Control Modules and read which modules are connected to the Fusion.\n\n\nList of available Python functions:\n  \n\n\n\n\nCoreControl.driver()\n\n\nprintDevices()\n\n\n\n\nList of available Blockly blocks:\n  \n\n\n\n\nPrint Devices\n\n\n\n\nPython\n\n\n\n\nCoreControl.driver()\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Core Control Modules and must be called at the beginning of the program before using any other class functions. \n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nCore Control Object\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\n\n\n\n\n\n\n\nprintDevices()\n\n\n\n\nDefinition\n\n\n\n\nPrint a list of attached Core Control Modules showing the ttyl port, modules type and FTDI serial number. The serial number is used to indentify a specific controller in programming.  \n\n\nDevice IDs for modules:\n\n\nCore Device Interface\n - USBAMUX\n\n\nCore Legacy Module\n - USBLSMUX\n\n\nCore Motor Controller\n - USBMCON\n\n\nCore Servo Controller\n - USBSCON\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nc.printDevices()\n\n\n\n\n\n\n\n\n\nBlockly\n\n\n\n\nPrint Devices\n\n\n\n\nPrint a list of attached Core Control Modules showing the ttyl port, modules type and FTDI serial number. The serial number is used to indentify a specific controller in programming.\n\n\nDevice IDs for modules:\n\n\nCore Device Interface\n - USBAMUX\n\n\nCore Legacy Module\n - USBLSMUX\n\n\nCore Motor Controller\n - USBMCON\n\n\nCore Servo Controller\n - USBSCON\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\n\nc.printDevices\n\n\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Core Control Modules Driver", 
            "title": "Core Control Driver"
        }, 
        {
            "location": "/CoreControlDriver/#core-control-module-driver", 
            "text": "The Core Control Driver is used to set up all the Core Control Modules and read which modules are connected to the Fusion.  List of available Python functions:      CoreControl.driver()  printDevices()   List of available Blockly blocks:      Print Devices", 
            "title": "Core Control Module Driver"
        }, 
        {
            "location": "/CoreControlDriver/#python", 
            "text": "", 
            "title": "Python"
        }, 
        {
            "location": "/CoreControlDriver/#corecontroldriver", 
            "text": "", 
            "title": "CoreControl.driver()"
        }, 
        {
            "location": "/CoreControlDriver/#definition", 
            "text": "This class contains the necessary drivers for our Core Control Modules and must be called at the beginning of the program before using any other class functions.", 
            "title": "Definition"
        }, 
        {
            "location": "/CoreControlDriver/#parameters", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/CoreControlDriver/#returns", 
            "text": "Core Control Object", 
            "title": "Returns"
        }, 
        {
            "location": "/CoreControlDriver/#example", 
            "text": "import CoreControl\nc = CoreControl.driver()", 
            "title": "Example"
        }, 
        {
            "location": "/CoreControlDriver/#printdevices", 
            "text": "", 
            "title": "printDevices()"
        }, 
        {
            "location": "/CoreControlDriver/#definition_1", 
            "text": "Print a list of attached Core Control Modules showing the ttyl port, modules type and FTDI serial number. The serial number is used to indentify a specific controller in programming.    Device IDs for modules:  Core Device Interface  - USBAMUX  Core Legacy Module  - USBLSMUX  Core Motor Controller  - USBMCON  Core Servo Controller  - USBSCON", 
            "title": "Definition"
        }, 
        {
            "location": "/CoreControlDriver/#parameters_1", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/CoreControlDriver/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/CoreControlDriver/#example_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\nc.printDevices()", 
            "title": "Example"
        }, 
        {
            "location": "/CoreControlDriver/#blockly", 
            "text": "", 
            "title": "Blockly"
        }, 
        {
            "location": "/CoreControlDriver/#print-devices", 
            "text": "Print a list of attached Core Control Modules showing the ttyl port, modules type and FTDI serial number. The serial number is used to indentify a specific controller in programming.  Device IDs for modules:  Core Device Interface  - USBAMUX  Core Legacy Module  - USBLSMUX  Core Motor Controller  - USBMCON  Core Servo Controller  - USBSCON", 
            "title": "Print Devices"
        }, 
        {
            "location": "/CoreControlDriver/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/CoreControlDriver/#code", 
            "text": "import CoreControl\nc = CoreControl.driver()\n\nc.printDevices", 
            "title": "Code:"
        }, 
        {
            "location": "/CoreControlDriver/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Core Control Modules Driver", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/", 
            "text": "Core Device Interface (45-2201)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Device Interface Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSetup\n\n\nSet LED\n\n\nAnalog Read\n\n\nAnalog Output Write\n\n\nDigital Read\n\n\nDigital Write\n\n\nSet PWM\n\n\nI2C Read\n\n\nI2C Write\n\n\n\n\nSetup\n\n\n\n\nThis block contains the necessary drivers for our Core Device Interface and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\n\n\n\n\n\n\nSet LED\n\n\n\n\nTurn on or off the on-board LEDs. There is a \nRED\n and \nBLUE\n LED at the top of the module.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setLED(cdi1.RED, 1)\n\n\n\n\n\n\n\nAnalog Read\n\n\n\n\nRead from an analog device attached to the corresponding port.  \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.analogRead(cdi1.A0)\n\n\n\n\n\n\n\nAnalog Output Write\n\n\n\n\nOutput a wave form at a set voltage and frequency from one of the analog output ports. The output can be DC, Sine, Square and Triangle wave forms.  \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.analogOutputWrite(cdi1.AO0, 2, 2000, 1)\n\n\n\n\n\n\n\nDigital Read\n\n\n\n\nRead from a digital device attached to the corresponding port.  \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D0, cdi1.INPUT)\n\nprint cdi1.digitalRead(cdi1.D0)\n\n\n\n\n\n\n\nDigital Write\n\n\n\n\nWrite to a digital device attached to the corresponding port.  \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D0, cdi1.OUTPUT)\n\nprint cdi1.digitalWrite(cdi1.D0, 0)\n\n\n\n\n\n\n\nSet PWM\n\n\n\n\nSet a PWM output to a specific port. This port cannot operate servos. The \non time\n parameter sets the pulse width for the channel output in units of 1\u00b5S. Setting a value greater than \nperiod\n will result in the output being set to 1. The \nperiod\n parameter sets the pulse repetition period for the channel output in units of 1\u00b5S. \n\n\n    \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setPWM(cdi1.P0, 500, 1000)\n\n\n\n\n\n\n\nI2C Read\n\n\n\n\nRead data from an I2C device based on the \naddress\n of the device, the \nregister\n location and the \nlength\n of values to be read. \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.i2cRead(0x4C, 0x02, 1)\n\n\n\n\n\n\n\nI2C Write\n\n\n\n\nWrite data to an I2C device based on the \naddress\n of the device, the \nregister\n location a \nvalue\n.  \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.i2cWrite(0x4C, 0x04, [2])\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Core Device Interface", 
            "title": "Core Device Interface"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#core-device-interface-45-2201", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Device Interface Python Library Information      List of available blocks:      Setup  Set LED  Analog Read  Analog Output Write  Digital Read  Digital Write  Set PWM  I2C Read  I2C Write", 
            "title": "Core Device Interface (45-2201)"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#setup", 
            "text": "This block contains the necessary drivers for our Core Device Interface and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Setup"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#set-led", 
            "text": "Turn on or off the on-board LEDs. There is a  RED  and  BLUE  LED at the top of the module. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Set LED"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setLED(cdi1.RED, 1)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#analog-read", 
            "text": "Read from an analog device attached to the corresponding port.   \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Analog Read"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.analogRead(cdi1.A0)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#analog-output-write", 
            "text": "Output a wave form at a set voltage and frequency from one of the analog output ports. The output can be DC, Sine, Square and Triangle wave forms.   \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Analog Output Write"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.analogOutputWrite(cdi1.AO0, 2, 2000, 1)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#digital-read", 
            "text": "Read from a digital device attached to the corresponding port.   \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Digital Read"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_4", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D0, cdi1.INPUT)\n\nprint cdi1.digitalRead(cdi1.D0)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#digital-write", 
            "text": "Write to a digital device attached to the corresponding port.   \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Digital Write"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_5", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_5", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D0, cdi1.OUTPUT)\n\nprint cdi1.digitalWrite(cdi1.D0, 0)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#set-pwm", 
            "text": "Set a PWM output to a specific port. This port cannot operate servos. The  on time  parameter sets the pulse width for the channel output in units of 1\u00b5S. Setting a value greater than  period  will result in the output being set to 1. The  period  parameter sets the pulse repetition period for the channel output in units of 1\u00b5S.        \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Set PWM"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_6", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_6", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setPWM(cdi1.P0, 500, 1000)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#i2c-read", 
            "text": "Read data from an I2C device based on the  address  of the device, the  register  location and the  length  of values to be read.  \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "I2C Read"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_7", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_7", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.i2cRead(0x4C, 0x02, 1)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#i2c-write", 
            "text": "Write data to an I2C device based on the  address  of the device, the  register  location a  value .   \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "I2C Write"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#block_8", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#code_8", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.i2cWrite(0x4C, 0x04, [2])", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Device_Interface/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Core Device Interface", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Core_Device_Interface/", 
            "text": "Core Device Interface (45-2201)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Device Interface Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\ncoreDeviceInterface(\ndriver\n, \nserial\n)\n\n\nsetLED(\nled\n, \nvalue\n)\n\n\nanalogRead(\nanalog_port\n)\n\n\ndigitalState(\nport\n, \nstate\n)\n\n\ndigitalRead(\nport\n)\n\n\ndigitalWrite(\nport\n, \nvalue\n)\n\n\nanalogOutputWrite(\nport\n, \nvoltage\n, \nfrequency\n, \nmode\n)\n\n\nsetPWM(\nport\n, \non_time\n, \nperiod\n)\n\n\ngetAddresses()\n\n\ni2cRead(\naddress\n, \nregister\n, \nlength\n)\n\n\ni2cWrite(\naddress\n, \nregister\n, \nbuffer\n)\n\n\n\n\ncoreDeviceInterface(\ndriver\n, \nserial\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Core Device Interface and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nc\n)\n\n\nserial\n : Enter the FTDI serial number of the module. \n\n\n\n\nReturns\n\n\n\n\nCore Device Interface Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\n\n\n\n\n\n\nsetLED(\nled\n, \nvalue\n)\n\n\n\n\nDefinition\n\n\n\n\nTurn on or off the on-board LEDs.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nled\n : RED or BLUE\n\n\nvalue\n : 0 or 1\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setLED(cdi1.RED, 1)\n\n\n\n\n\n\n\nanalogRead(\nanalog_port\n)\n\n\n\n\nDefinition\n\n\n\n\nRead from an analog device attached to the corresponding port.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nanalog port\n : A0 - A7\n\n\n\n\nReturns\n\n\n\n\nanalog reading\n : int(0 - 1023)\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.analogRead(cdi1.A0)\n\n\n\n\n\n\n\ndigitalState(\nport\n, \nstate\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the digital port to be either an INPUT or an OUTPUT.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : D0 - D7\n\n\nstate\n : INPUT(0) or OUTPUT(1)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.digitalState(cdi1.D0, cdi1.INPUT)\ncdi1.digitalState(cdi1.D1, cdi1.OUTPUT)\n\n\n\n\n\n\n\ndigitalRead(\nport\n)\n\n\n\n\nDefinition\n\n\n\n\nRead from a digital device attached to the corresponding port.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : D0 - D7  \n\n\n\n\nReturns\n\n\n\n\ndigital reading\n : 0 or 1\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D0, cdi1.INPUT)\n\nprint cdi1.digitalRead(cdi1.D0)\n\n\n\n\n\n\n\ndigitalWrite(\nport\n, \nvalue\n)\n\n\n\n\nDefinition\n\n\n\n\nWrite to a digital device attached to the corresponding port.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : D0 - D7\n\n\nvalue\n : 0 or 1\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D1, cdi1.OUTPUT)\n\ncdi1.digitalWrite(cdi1.D1, 1)\n\n\n\n\n\n\n\nanalogOutputWrite(\nport\n, \nvoltage\n, \nfrequency\n, \nmode\n)\n\n\n\n\nDefinition\n\n\n\n\nOutput a wave form at a set voltage and frequency from one of the analog output ports.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : AO0 or AO1\n\n\nvoltage\n :\n\n\n\n\nDC\n : -1024 - +1023 (-4V - +4V)\n\n\nOther\n : 0 - 1023 (0V - 8V)\n\n\n\n\nfrequency\n : 0Hz to 5000Hz (0 in DC mode)\n\n\nmode\n : DC(0), Sine(1), Square(2), Triangle(3)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\n# Output a DC voltage at +4V\ncdi1.analogOutputWrite(cdi1.AO0, 1023, 0, 0)\n# Output a Sine wave with pk-pk of 4V at a frequency of 2000Hz\ncdi1.analogOutputWrite(cdi1.AO1, 512, 2000, 1)\n\n\n\n\n\n\n\nsetPWM(\nport\n, \non_time\n, \nperiod\n)\n\n\n\n\nDefinition\n\n\n\n\nSet a PWM output to a specific port. This port cannot operate servos. The \non time\n parameter sets the pulse width for the channel output in units of 1\u00b5S. Setting a value greater than \nperiod\n will result in the output being set to 1. The \nperiod\n parameter sets the pulse repetition period for the channel output in units of 1\u00b5S. \n\n\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : P0 or P1\n\n\non time\n : 0 - 65,535 (\u00b5S) \n\nperiod\n : 0 - 65,535 (\u00b5S)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setPWM(cdi1.P0, 500, 1000)\n\n\n\n\n\n\n\ngetAddresses()\n\n\n\n\nDefinition\n\n\n\n\nReturn a list of connected I2C devices.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\naddresses\n : A buffer of connected I2C addresses in hexadecimal\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.getAddresses()\n\n\n\n\n\n\n\ni2cRead(\naddress\n, \nregister\n, \nlength\n)\n\n\n\n\nDefinition\n\n\n\n\nRead data from an I2C device based on the \naddress\n of the device, the \nregister\n location and the \nlength\n of values to be read.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\naddress\n : The current I2C address of the sensor connected\n\n\nregister\n :  The register location within the sensor to start reading from\n\n\nlength\n :  The number of registers to read starting from the \nregister\n location\n\n\n\n\nReturns\n\n\n\n\nI2C value(s)\n : A buffer of values starting with the value in the \nregister\n location to the set \nlength\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.i2cRead(0x4C, 0x01, 2)\n\n\n\n\n\n\n\ni2cWrite(\naddress\n, \nregister\n, \nbuffer\n)\n\n\n\n\nDefinition\n\n\n\n\nWrite data to an I2C device based on the \naddress\n of the device, the \nregister\n location with a \nbuffer\n of values.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\naddress\n : The current I2C address of the sensor connected\n\n\nregister\n :  The register location within the sensor to start writing to\n\n\nbuffer\n :  An array of values to be written to the I2C device\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.i2cWrite(0x4C, 0x04, [7])\ncdi1.i2cWrite(0x20, 0x10, [2, 1])\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Core Device Interface", 
            "title": "Core Device Interface"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#core-device-interface-45-2201", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Device Interface Visual Programming Blocks   List of available functions:      coreDeviceInterface( driver ,  serial )  setLED( led ,  value )  analogRead( analog_port )  digitalState( port ,  state )  digitalRead( port )  digitalWrite( port ,  value )  analogOutputWrite( port ,  voltage ,  frequency ,  mode )  setPWM( port ,  on_time ,  period )  getAddresses()  i2cRead( address ,  register ,  length )  i2cWrite( address ,  register ,  buffer )", 
            "title": "Core Device Interface (45-2201)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#coredeviceinterfacedriver-serial", 
            "text": "", 
            "title": "coreDeviceInterface(driver, serial)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition", 
            "text": "This class contains the necessary drivers for our Core Device Interface and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( c )  serial  : Enter the FTDI serial number of the module.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns", 
            "text": "Core Device Interface Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#setledled-value", 
            "text": "", 
            "title": "setLED(led, value)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_1", 
            "text": "Turn on or off the on-board LEDs. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_1", 
            "text": "led  : RED or BLUE  value  : 0 or 1", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setLED(cdi1.RED, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#analogreadanalog_port", 
            "text": "", 
            "title": "analogRead(analog_port)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_2", 
            "text": "Read from an analog device attached to the corresponding port. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_2", 
            "text": "analog port  : A0 - A7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_2", 
            "text": "analog reading  : int(0 - 1023)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.analogRead(cdi1.A0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#digitalstateport-state", 
            "text": "", 
            "title": "digitalState(port, state)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_3", 
            "text": "Set the digital port to be either an INPUT or an OUTPUT. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_3", 
            "text": "port  : D0 - D7  state  : INPUT(0) or OUTPUT(1)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_3", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.digitalState(cdi1.D0, cdi1.INPUT)\ncdi1.digitalState(cdi1.D1, cdi1.OUTPUT)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#digitalreadport", 
            "text": "", 
            "title": "digitalRead(port)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_4", 
            "text": "Read from a digital device attached to the corresponding port. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_4", 
            "text": "port  : D0 - D7", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_4", 
            "text": "digital reading  : 0 or 1", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_4", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D0, cdi1.INPUT)\n\nprint cdi1.digitalRead(cdi1.D0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#digitalwriteport-value", 
            "text": "", 
            "title": "digitalWrite(port, value)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_5", 
            "text": "Write to a digital device attached to the corresponding port. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_5", 
            "text": "port  : D0 - D7  value  : 0 or 1", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_5", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_5", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\ncdi1.digitalState(cdi1.D1, cdi1.OUTPUT)\n\ncdi1.digitalWrite(cdi1.D1, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#analogoutputwriteport-voltage-frequency-mode", 
            "text": "", 
            "title": "analogOutputWrite(port, voltage, frequency, mode)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_6", 
            "text": "Output a wave form at a set voltage and frequency from one of the analog output ports. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_6", 
            "text": "port  : AO0 or AO1  voltage  :   DC  : -1024 - +1023 (-4V - +4V)  Other  : 0 - 1023 (0V - 8V)   frequency  : 0Hz to 5000Hz (0 in DC mode)  mode  : DC(0), Sine(1), Square(2), Triangle(3)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_6", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_6", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\n# Output a DC voltage at +4V\ncdi1.analogOutputWrite(cdi1.AO0, 1023, 0, 0)\n# Output a Sine wave with pk-pk of 4V at a frequency of 2000Hz\ncdi1.analogOutputWrite(cdi1.AO1, 512, 2000, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#setpwmport-on_time-period", 
            "text": "", 
            "title": "setPWM(port, on_time, period)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_7", 
            "text": "Set a PWM output to a specific port. This port cannot operate servos. The  on time  parameter sets the pulse width for the channel output in units of 1\u00b5S. Setting a value greater than  period  will result in the output being set to 1. The  period  parameter sets the pulse repetition period for the channel output in units of 1\u00b5S.   \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_7", 
            "text": "port  : P0 or P1  on time  : 0 - 65,535 (\u00b5S)  period  : 0 - 65,535 (\u00b5S)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_7", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_7", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.setPWM(cdi1.P0, 500, 1000)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#getaddresses", 
            "text": "", 
            "title": "getAddresses()"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_8", 
            "text": "Return a list of connected I2C devices. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_8", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_8", 
            "text": "addresses  : A buffer of connected I2C addresses in hexadecimal", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_8", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.getAddresses()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#i2creadaddress-register-length", 
            "text": "", 
            "title": "i2cRead(address, register, length)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_9", 
            "text": "Read data from an I2C device based on the  address  of the device, the  register  location and the  length  of values to be read. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_9", 
            "text": "address  : The current I2C address of the sensor connected  register  :  The register location within the sensor to start reading from  length  :  The number of registers to read starting from the  register  location", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_9", 
            "text": "I2C value(s)  : A buffer of values starting with the value in the  register  location to the set  length", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_9", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\nprint cdi1.i2cRead(0x4C, 0x01, 2)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#i2cwriteaddress-register-buffer", 
            "text": "", 
            "title": "i2cWrite(address, register, buffer)"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#definition_10", 
            "text": "Write data to an I2C device based on the  address  of the device, the  register  location with a  buffer  of values. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#parameters_10", 
            "text": "address  : The current I2C address of the sensor connected  register  :  The register location within the sensor to start writing to  buffer  :  An array of values to be written to the I2C device", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#returns_10", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#example_10", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncdi1 = CoreControl.coreDeviceInterface(c, 'A900VGFC')\n\ncdi1.i2cWrite(0x4C, 0x04, [7])\ncdi1.i2cWrite(0x20, 0x10, [2, 1])", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Device_Interface/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Core Device Interface", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/", 
            "text": "Core Legacy Module (45-2202)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Legacy Module Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSetup\n\n\nSet LED\n\n\nAnalog Read\n\n\nI2C Read\n\n\nI2C Write\n\n\n\n\nSetup\n\n\n\n\nThis block contains the necessary drivers for our Core Legacy Module and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\n\n\n\n\n\n\nSet LED\n\n\n\n\nTurn on or off any of the four green on-board LEDs.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.setLED(1, clm1.ON)\n\n\n\n\n\n\n\nAnalog Read\n\n\n\n\nRead from an analog device attached to the corresponding port.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.analogRead(clm1.S0)\n\n\n\n\n\n\n\nI2C Read\n\n\n\n\nRead data from an I2C device connected to a specified \nport\n based on the \naddress\n of the device, the \nregister\n location and the \nlength\n of values to be read. \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.i2cRead(clm1.S0, 0x02, 0x42, 1)\n\n\n\n\n\n\n\nI2C Write\n\n\n\n\nWrite data to an I2C device connected to a specified \nport\n based on the \naddress\n of the device, the \nregister\n location with a \nbuffer\n of values. \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.i2cWrite(clm1.S0, 0x02, 0x42, [1])\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Core Legacy Module", 
            "title": "Core Legacy Module"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#core-legacy-module-45-2202", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Legacy Module Python Library Information      List of available blocks:      Setup  Set LED  Analog Read  I2C Read  I2C Write", 
            "title": "Core Legacy Module (45-2202)"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#setup", 
            "text": "This block contains the necessary drivers for our Core Legacy Module and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Setup"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#code", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#set-led", 
            "text": "Turn on or off any of the four green on-board LEDs. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Set LED"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#code_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.setLED(1, clm1.ON)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#analog-read", 
            "text": "Read from an analog device attached to the corresponding port. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Analog Read"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#code_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.analogRead(clm1.S0)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#i2c-read", 
            "text": "Read data from an I2C device connected to a specified  port  based on the  address  of the device, the  register  location and the  length  of values to be read.  \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "I2C Read"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#code_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.i2cRead(clm1.S0, 0x02, 0x42, 1)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#i2c-write", 
            "text": "Write data to an I2C device connected to a specified  port  based on the  address  of the device, the  register  location with a  buffer  of values.  \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "I2C Write"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#code_4", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.i2cWrite(clm1.S0, 0x02, 0x42, [1])", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Legacy_Module/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Core Legacy Module", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/", 
            "text": "Core Legacy Module (45-2202)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Legacy Module Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\ncoreLegacyModule(\ndriver\n, \nserial\n)\n\n\nsetLED(\nled\n, \nvalue\n)\n\n\nanalogRead(\nport\n)\n\n\ngetAddress(\nport\n)\n\n\ni2cRead(\nport\n, \naddress\n, \nregister\n, \nlength\n)\n\n\ni2cWrite(\nport\n, \naddress\n, \nregister\n, \nbuffer\n)\n\n\nenable9V(\nport\n, \nstate\n)\n\n\ndigitalEnable(\nport\n, \npin\n, \nvalue\n)\n\n\n\n\ncoreLegacyModule(\ndriver\n, \nserial\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Core Legacy Module and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nc\n)\n\n\nserial\n : Enter the FTDI serial number of the module. \n\n\n\n\nReturns\n\n\n\n\nCore Legacy Module Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\n\n\n\n\n\n\nsetLED(\nled\n, \nvalue\n)\n\n\n\n\nDefinition\n\n\n\n\nTurn on or off any of the four green on-board LEDs.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nled\n : 0 - 3\n\n\nvalue\n : ON(1) or OFF(0)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.setLED(0, 1)\nclm1.setLED(2, clm1.ON)\n\n\n\n\n\n\n\nanalogRead(\nport\n)\n\n\n\n\nDefinition\n\n\n\n\nRead from an analog device attached to the corresponding port.  \n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : S0 - S5  \n\n\n\n\nReturns\n\n\n\n\nvalue\n : 0 - 1023\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.setLED(clm1.S0)\n\n\n\n\n\n\n\ngetAddress(\nport\n)\n\n\n\n\nDefinition\n\n\n\n\nReturn the I2C address of the sensors connected to the selected port.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nNone\n\n\n\n\nReturns\n\n\n\n\naddress\n : The I2C address in hexadecimal\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.getAddresses()\n\n\n\n\n\n\n\ni2cRead(\nport\n, \naddress\n, \nregister\n, \nlength\n)\n\n\n\n\nDefinition\n\n\n\n\nRead data from an I2C device connected to a specified \nport\n based on the \naddress\n of the device, the \nregister\n location and the \nlength\n of values to be read.  \n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : S0 - S5\n\n\naddress\n : The current I2C address of the sensor connected\n\n\nregister\n :  The register location within the sensor to start reading from\n\n\nlength\n :  The number of registers to read starting from the \nregister\n location\n\n\n\n\nReturns\n\n\n\n\nvalue\n : Dependent on sensor type\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.i2cRead(clm1.S0, 0x02, 0x42, 1)\n\n\n\n\n\n\n\ni2cWrite(\nport\n, \naddress\n, \nregister\n, \nbuffer\n)\n\n\n\n\nDefinition\n\n\n\n\nWrite data to an I2C device connected to a specified \nport\n based on the \naddress\n of the device, the \nregister\n location with a \nbuffer\n of values.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : S0 - S5\n\n\naddress\n : The current I2C address of the sensor connected\n\n\nregister\n :  The register location within the sensor to start reading from\n\n\nbuffer\n :  An array of values to be written to the I2C device\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.i2cWrite(clm1.S0, 0x02, 0x42, [1, 0])\n\n\n\n\n\n\n\nenable9V(\nport\n, \nstate\n)\n\n\n\n\nDefinition\n\n\n\n\nPorts \nS4\n and \nS5\n have a feature that enable a 9V output. This is useful when using the Ultrasonic sensor to get the full range of readings.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : S4 or S5\n\n\nstate\n : True(1) or False(0)  \n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\nclm1.enable9V(clm1.S4, True)\n\n\n\n\n\n\n\ndigitalEnable(\nport\n, \npin\n, \nvalue\n)\n\n\n\n\nDefinition\n\n\n\n\nTurn digital pin \n0\n or \n1\n to a state of ON or OFF. These is typically used to control the LEGO light sensor LED. In I2C mode, this function is ignored.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nport\n : S0 - S5\n\n\npin\n : 0 or 1\n\n\nvalue\n : 0 or 1  \n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\nclm1.digitalEnable(clm1.S1, 0, 1)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Core Legacy Module", 
            "title": "Core Legacy Module"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#core-legacy-module-45-2202", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Legacy Module Visual Programming Blocks   List of available functions:      coreLegacyModule( driver ,  serial )  setLED( led ,  value )  analogRead( port )  getAddress( port )  i2cRead( port ,  address ,  register ,  length )  i2cWrite( port ,  address ,  register ,  buffer )  enable9V( port ,  state )  digitalEnable( port ,  pin ,  value )", 
            "title": "Core Legacy Module (45-2202)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#corelegacymoduledriver-serial", 
            "text": "", 
            "title": "coreLegacyModule(driver, serial)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition", 
            "text": "This class contains the necessary drivers for our Core Legacy Module and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( c )  serial  : Enter the FTDI serial number of the module.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns", 
            "text": "Core Legacy Module Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#setledled-value", 
            "text": "", 
            "title": "setLED(led, value)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_1", 
            "text": "Turn on or off any of the four green on-board LEDs. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_1", 
            "text": "led  : 0 - 3  value  : ON(1) or OFF(0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.setLED(0, 1)\nclm1.setLED(2, clm1.ON)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#analogreadport", 
            "text": "", 
            "title": "analogRead(port)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_2", 
            "text": "Read from an analog device attached to the corresponding port.   \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_2", 
            "text": "port  : S0 - S5", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_2", 
            "text": "value  : 0 - 1023", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.setLED(clm1.S0)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#getaddressport", 
            "text": "", 
            "title": "getAddress(port)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_3", 
            "text": "Return the I2C address of the sensors connected to the selected port. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_3", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_3", 
            "text": "address  : The I2C address in hexadecimal", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.getAddresses()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#i2creadport-address-register-length", 
            "text": "", 
            "title": "i2cRead(port, address, register, length)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_4", 
            "text": "Read data from an I2C device connected to a specified  port  based on the  address  of the device, the  register  location and the  length  of values to be read.   \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_4", 
            "text": "port  : S0 - S5  address  : The current I2C address of the sensor connected  register  :  The register location within the sensor to start reading from  length  :  The number of registers to read starting from the  register  location", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_4", 
            "text": "value  : Dependent on sensor type", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_4", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nprint clm1.i2cRead(clm1.S0, 0x02, 0x42, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#i2cwriteport-address-register-buffer", 
            "text": "", 
            "title": "i2cWrite(port, address, register, buffer)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_5", 
            "text": "Write data to an I2C device connected to a specified  port  based on the  address  of the device, the  register  location with a  buffer  of values. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_5", 
            "text": "port  : S0 - S5  address  : The current I2C address of the sensor connected  register  :  The register location within the sensor to start reading from  buffer  :  An array of values to be written to the I2C device", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_5", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_5", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\n\nclm1.i2cWrite(clm1.S0, 0x02, 0x42, [1, 0])", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#enable9vport-state", 
            "text": "", 
            "title": "enable9V(port, state)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_6", 
            "text": "Ports  S4  and  S5  have a feature that enable a 9V output. This is useful when using the Ultrasonic sensor to get the full range of readings. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_6", 
            "text": "port  : S4 or S5  state  : True(1) or False(0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_6", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_6", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\nclm1.enable9V(clm1.S4, True)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#digitalenableport-pin-value", 
            "text": "", 
            "title": "digitalEnable(port, pin, value)"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#definition_7", 
            "text": "Turn digital pin  0  or  1  to a state of ON or OFF. These is typically used to control the LEGO light sensor LED. In I2C mode, this function is ignored. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#parameters_7", 
            "text": "port  : S0 - S5  pin  : 0 or 1  value  : 0 or 1", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#returns_7", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#example_7", 
            "text": "import CoreControl\nc = CoreControl.driver()\nclm1 = CoreControl.coreLegacyModule(c, 'AL00VCO2')\nclm1.digitalEnable(clm1.S1, 0, 1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Legacy_Module/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Core Legacy Module", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/", 
            "text": "Core Motor Controller (45-2203)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Motor Controller Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSetup\n\n\nMotor Speed\n\n\nMotor Power\n\n\nRun To Position\n\n\nRead Encoder\n\n\nRead Battery Voltage\n\n\n\n\nSetup\n\n\n\n\nThis block contains the necessary drivers for our Core Motor Controller and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\n\n\n\n\n\n\nMotor Speed\n\n\n\n\nSet the speed of a motor connected to one of the motor ports. This block will maintain speed of the motors which means that 100% motor speed being applied only runs around 80% of maximum efficiency. Therefore if the motor encounters additional friction more power to the motor can be applied to maintain the speed.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantSpeed(cmc1.M1, 100)\n\n\n\n\n\n\n\nMotor Power\n\n\n\n\nSet the power of a motor connected to one of the motor ports.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantPower(cmc1.M1, 100)\n\n\n\n\n\n\n\nRun To Position\n\n\n\n\nRun the motor to a specific encoder count at a set power. Motors vary with encoder counts per revolution which could create different results.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.runToPosition(cmc1.M1, 60, 5000)\n\n\n\n\n\n\n\nRead Encoder\n\n\n\n\nRun the current encoder count of a motor. \n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readEncoder(cmc1.M1)\n\n\n\n\n\n\n\nRead Battery Voltage\n\n\n\n\nRun the current battery voltage of the 12V battery powering the Core Motor Controller. The value return is returned in 20mV increments.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\nFor example a returned value of 601 gives a voltage of (601 x .02) = \n12.02V\n   \n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readBattVoltage()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Core Motor Controller", 
            "title": "Core Motor Controller"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#core-motor-controller-45-2203", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Motor Controller Python Library Information      List of available blocks:      Setup  Motor Speed  Motor Power  Run To Position  Read Encoder  Read Battery Voltage", 
            "title": "Core Motor Controller (45-2203)"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#setup", 
            "text": "This block contains the necessary drivers for our Core Motor Controller and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Setup"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#code", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#motor-speed", 
            "text": "Set the speed of a motor connected to one of the motor ports. This block will maintain speed of the motors which means that 100% motor speed being applied only runs around 80% of maximum efficiency. Therefore if the motor encounters additional friction more power to the motor can be applied to maintain the speed. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Motor Speed"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#code_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantSpeed(cmc1.M1, 100)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#motor-power", 
            "text": "Set the power of a motor connected to one of the motor ports. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Motor Power"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#block_2", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#code_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantPower(cmc1.M1, 100)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#run-to-position", 
            "text": "Run the motor to a specific encoder count at a set power. Motors vary with encoder counts per revolution which could create different results. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Run To Position"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#block_3", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#code_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.runToPosition(cmc1.M1, 60, 5000)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#read-encoder", 
            "text": "Run the current encoder count of a motor.  \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Read Encoder"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#block_4", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#code_4", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readEncoder(cmc1.M1)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#read-battery-voltage", 
            "text": "Run the current battery voltage of the 12V battery powering the Core Motor Controller. The value return is returned in 20mV increments. \nMust have the  Setup  block at the start of your program for this block to work. \nFor example a returned value of 601 gives a voltage of (601 x .02) =  12.02V", 
            "title": "Read Battery Voltage"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#block_5", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#code_5", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readBattVoltage()", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Motor_Controller/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Core Motor Controller", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/", 
            "text": "Core Motor Controller (45-2203)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Motor Controller Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\ncoreMotorController(\ndriver\n, \nserial\n)\n\n\nconstantSpeed(\nmotor\n, \nspeed\n)\n\n\nconstantPower(\nmotor\n, \npower\n)\n\n\nrunToPosition(\nmotor\n, \npower\n, \ntarget\n)\n\n\nreadEncoder(\nmotor\n)\n\n\nreadBattVoltage()\n\n\n\n\ncoreMotorController(\ndriver\n, \nserial\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Core Motor Controller and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nc\n)\n\n\nserial\n : Enter the FTDI serial number of the module. \n\n\n\n\nReturns\n\n\n\n\nCore Motor Controller Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\n\n\n\n\n\n\nconstantSpeed(\nmotor\n, \nspeed\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the speed of a motor connected to one of the motor ports. This function will maintain speed of the motors which means that 100% motor speed being applied only runs around 80% of maximum efficiency. Therefore if the motor encounters additional friction more power to the motor can be applied to maintain the speed.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nmotor\n : M1 or M2\n\n\nspeed\n : int (\u00b1100)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantSpeed(cmc1.M1, 50)\n\n\n\n\n\n\n\nconstantPower(\nmotor\n, \npower\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the power of a motor connected to one of the motor ports.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nmotor\n : M1 or M2\n\n\npower\n : int (\u00b1100)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantPower(cmc1.M1, 50)\n\n\n\n\n\n\n\nrunToPosition(\nmotor\n, \npower\n, \ntarget\n)\n\n\n\n\nDefinition\n\n\n\n\nRun the motor to a specific encoder count at a set power. Motors vary with encoder counts per revolution which could create different results.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nmotor\n : M1 or M2\n\n\npower\n : int (\u00b1100)\n\n\ntarget\n : int (-\u202d2,147,483,648 - +\u202d2,147,483,647\u202c)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.runToPosition(cmc1.M1, 50, 10000)\n\n\n\n\n\n\n\nreadEncoder(\nmotor\n)\n\n\n\n\nDefinition\n\n\n\n\nRun the current encoder count of a motor.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nmotor\n : M1 or M2   \n\n\n\n\nReturns\n\n\n\n\ntarget\n : int (-\u202d2,147,483,648 - +\u202d2,147,483,647\u202c)\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readEncoder(cmc1.M1)\n\n\n\n\n\n\n\nreadBattVoltage()\n\n\n\n\nDefinition\n\n\n\n\nRun the current battery voltage of the 12V battery powering the Core Motor Controller. The value return is returned in 20mV increments.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\nFor example a returned value of 601 gives a voltage of (601 x .02) = \n12.02V\n\n\n\n\nParameters\n\n\n\n\nNone\n   \n\n\n\n\nReturns\n\n\n\n\nBattery Voltage Multiplier\n : int ()\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readBattVoltage()\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Core Motor Controller", 
            "title": "Core Motor Controller"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#core-motor-controller-45-2203", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Motor Controller Visual Programming Blocks   List of available functions:      coreMotorController( driver ,  serial )  constantSpeed( motor ,  speed )  constantPower( motor ,  power )  runToPosition( motor ,  power ,  target )  readEncoder( motor )  readBattVoltage()", 
            "title": "Core Motor Controller (45-2203)"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#coremotorcontrollerdriver-serial", 
            "text": "", 
            "title": "coreMotorController(driver, serial)"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#definition", 
            "text": "This class contains the necessary drivers for our Core Motor Controller and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( c )  serial  : Enter the FTDI serial number of the module.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#returns", 
            "text": "Core Motor Controller Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#constantspeedmotor-speed", 
            "text": "", 
            "title": "constantSpeed(motor, speed)"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#definition_1", 
            "text": "Set the speed of a motor connected to one of the motor ports. This function will maintain speed of the motors which means that 100% motor speed being applied only runs around 80% of maximum efficiency. Therefore if the motor encounters additional friction more power to the motor can be applied to maintain the speed. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#parameters_1", 
            "text": "motor  : M1 or M2  speed  : int (\u00b1100)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#example_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantSpeed(cmc1.M1, 50)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#constantpowermotor-power", 
            "text": "", 
            "title": "constantPower(motor, power)"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#definition_2", 
            "text": "Set the power of a motor connected to one of the motor ports. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#parameters_2", 
            "text": "motor  : M1 or M2  power  : int (\u00b1100)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#returns_2", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#example_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.constantPower(cmc1.M1, 50)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#runtopositionmotor-power-target", 
            "text": "", 
            "title": "runToPosition(motor, power, target)"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#definition_3", 
            "text": "Run the motor to a specific encoder count at a set power. Motors vary with encoder counts per revolution which could create different results. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#parameters_3", 
            "text": "motor  : M1 or M2  power  : int (\u00b1100)  target  : int (-\u202d2,147,483,648 - +\u202d2,147,483,647\u202c)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#returns_3", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#example_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\ncmc1.runToPosition(cmc1.M1, 50, 10000)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#readencodermotor", 
            "text": "", 
            "title": "readEncoder(motor)"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#definition_4", 
            "text": "Run the current encoder count of a motor. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#parameters_4", 
            "text": "motor  : M1 or M2", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#returns_4", 
            "text": "target  : int (-\u202d2,147,483,648 - +\u202d2,147,483,647\u202c)", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#example_4", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readEncoder(cmc1.M1)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#readbattvoltage", 
            "text": "", 
            "title": "readBattVoltage()"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#definition_5", 
            "text": "Run the current battery voltage of the 12V battery powering the Core Motor Controller. The value return is returned in 20mV increments. \nMust have the  Setup  function at the start of your program for this function to work. \nFor example a returned value of 601 gives a voltage of (601 x .02) =  12.02V", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#parameters_5", 
            "text": "None", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#returns_5", 
            "text": "Battery Voltage Multiplier  : int ()", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#example_5", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncmc1 = CoreControl.coreMotorController(c, 'AL00VVPP')\n\nprint cmc1.readBattVoltage()", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Motor_Controller/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Core Motor Controller", 
            "title": "Questions?"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/", 
            "text": "Core Servo Controller (45-2204)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Servo Controller Python Library Information\n  \n\n\n\n\nList of available blocks:\n  \n\n\n\n\nSetup\n\n\nServo Target\n\n\n\n\nSetup\n\n\n\n\nThis block contains the necessary drivers for our Core Servo Controller and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\n\n\n\n\n\n\nServo Target\n\n\n\n\nSet the target position of a servo on the selected port. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.\n\nMust have the \nSetup\n block at the start of your program for this block to work.\n\n\nBlock:\n\n\n\n\nCode:\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\ncsc1.servoTarget(csc1.S1, 128)\n\n\n\n\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Blockly Core Servo Controller", 
            "title": "Core Servo Controller"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#core-servo-controller-45-2204", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Servo Controller Python Library Information      List of available blocks:      Setup  Servo Target", 
            "title": "Core Servo Controller (45-2204)"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#setup", 
            "text": "This block contains the necessary drivers for our Core Servo Controller and must be called at the beginning of the program. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Setup"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#block", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#code", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\ncsc1 = CoreControl.coreServoController(c, 'A0000000')", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#servo-target", 
            "text": "Set the target position of a servo on the selected port. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits. \nMust have the  Setup  block at the start of your program for this block to work.", 
            "title": "Servo Target"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#block_1", 
            "text": "", 
            "title": "Block:"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#code_1", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\ncsc1.servoTarget(csc1.S1, 128)", 
            "title": "Code:"
        }, 
        {
            "location": "/Blk_Core_Servo_Controller/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Blockly Core Servo Controller", 
            "title": "Questions?"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/", 
            "text": "Core Servo Controller (45-2204)\n\n\n\n\nBefore running the program, be sure to identify each module's FTDI serial number by running the \nPrint Devices\n function.\n\n\n\n\nCore Servo Controller Visual Programming Blocks\n\n\n\n\nList of available functions:\n  \n\n\n\n\ncoreServoController(\ndriver\n, \nserial\n)\n\n\npwmEnable(\nenable\n)\n\n\nservoTarget(\nservo\n, \ntarget\n)\n\n\nextendedModeEnable(\nservo\n, \nmode\n)\n\n\n\n\ncoreServoController(\ndriver\n, \nserial\n)\n\n\n\n\nDefinition\n\n\n\n\nThis class contains the necessary drivers for our Core Servo Controller and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.\n\n\n\n\nParameters\n\n\n\n\ndriver\n : Main driver object so the class can call driver functions (\nc\n)\n\n\nserial\n : Enter the FTDI serial number of the module. \n\n\n\n\nReturns\n\n\n\n\nCore Servo Controller Object\n\n\n\n\nExample\n\n\n\n\nimport Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()\n\n\n\n\n\n\n\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\n\n\npwmEnable(\nenable\n)\n\n\n\n\nDefinition\n\n\n\n\nTurn all the servo ports on or off. This function must be called in order for the servos to operate. \n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nenable\n : True(1) or False(0)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\n\n\n\n\n\n\ncsc1.pwmEnable(True)\n\n\n\nservoTarget(\nservo\n, \ntarget\n)\n\n\n\n\nDefinition\n\n\n\n\nSet the target position of a servo on the selected port. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nservo\n : S1 - S6\n\n\ntarget\n : int (0 - 255)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\n\n\n\n\n\n\ncsc1.servoTarget(csc1.S1, 128)\n\n\n\nextendedModeEnable(\nservo\n, \nmode\n)\n\n\n\n\nDefinition\n\n\n\n\nExtend the range on the servo port from \n750us - 2250us\n to \n500us - 2500us\n. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits.\n\nMust have the \nSetup\n function at the start of your program for this function to work.\n\n\n\n\nParameters\n\n\n\n\nservo\n : S1 - S6\n\n\nmode\n : True(1) or False(0)\n\n\n\n\nReturns\n\n\n\n\nNone\n\n\n\n\nExample\n\n\n\n\nimport CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')\n\n\n\n\n\n\n\ncsc1.extendedModeEnable(csc1.S1, True)\n\n\n\nQuestions?\n\n\n\n\nContact Boxlight Robotics at \nsupport@BoxlightRobotics.com\n with a detailed description of the steps you have taken and observations you have made.\n\n\nEmail Subject\n: Fusion Python Core Servo Controller", 
            "title": "Core Servo Controller"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#core-servo-controller-45-2204", 
            "text": "Before running the program, be sure to identify each module's FTDI serial number by running the  Print Devices  function.   Core Servo Controller Visual Programming Blocks   List of available functions:      coreServoController( driver ,  serial )  pwmEnable( enable )  servoTarget( servo ,  target )  extendedModeEnable( servo ,  mode )", 
            "title": "Core Servo Controller (45-2204)"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#coreservocontrollerdriver-serial", 
            "text": "", 
            "title": "coreServoController(driver, serial)"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#definition", 
            "text": "This class contains the necessary drivers for our Core Servo Controller and must be called at the beginning of the program before using any other class functions. The FTDI serial number is used for identifying a Core Control Module and must be entered as shown in the example.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#parameters", 
            "text": "driver  : Main driver object so the class can call driver functions ( c )  serial  : Enter the FTDI serial number of the module.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#returns", 
            "text": "Core Servo Controller Object", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#example", 
            "text": "import Fusion\nf = Fusion.driver()\nimport CoreControl\nc = CoreControl.driver()    csc1 = CoreControl.coreServoController(c, 'A0000000')", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#pwmenableenable", 
            "text": "", 
            "title": "pwmEnable(enable)"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#definition_1", 
            "text": "Turn all the servo ports on or off. This function must be called in order for the servos to operate.  \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#parameters_1", 
            "text": "enable  : True(1) or False(0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#returns_1", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#example_1", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')    csc1.pwmEnable(True)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#servotargetservo-target", 
            "text": "", 
            "title": "servoTarget(servo, target)"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#definition_2", 
            "text": "Set the target position of a servo on the selected port. Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#parameters_2", 
            "text": "servo  : S1 - S6  target  : int (0 - 255)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#returns_2", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#example_2", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')    csc1.servoTarget(csc1.S1, 128)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#extendedmodeenableservo-mode", 
            "text": "", 
            "title": "extendedModeEnable(servo, mode)"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#definition_3", 
            "text": "Extend the range on the servo port from  750us - 2250us  to  500us - 2500us . Be careful as Boxlight Robotics is not responsible for damaged servos due to exceeding mechanical limits. \nMust have the  Setup  function at the start of your program for this function to work.", 
            "title": "Definition"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#parameters_3", 
            "text": "servo  : S1 - S6  mode  : True(1) or False(0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#returns_3", 
            "text": "None", 
            "title": "Returns"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#example_3", 
            "text": "import CoreControl\nc = CoreControl.driver()\ncsc1 = CoreControl.coreServoController(c, 'A0000000')    csc1.extendedModeEnable(csc1.S1, True)", 
            "title": "Example"
        }, 
        {
            "location": "/Py_Core_Servo_Controller/#questions", 
            "text": "Contact Boxlight Robotics at  support@BoxlightRobotics.com  with a detailed description of the steps you have taken and observations you have made.  Email Subject : Fusion Python Core Servo Controller", 
            "title": "Questions?"
        }, 
        {
            "location": "/Trouble_Step1/", 
            "text": "Getting Started Trouble Shooting - Step 1: Attach\n\n\nIf the Green LED near the microUSB connector does not light when the cable is connected between your computer and the Fusion, please check the following:  \n\n\n\n\n\n\n\n\nIs the cable good?  It is possible that the cable is damaged and power is not being transferred to the Fusion Controller.  Please try a known good cable of good quality.  \n\n\n\n\n\n\nIs the USB Port on the computer working properly and able to supply 5v @ 500mA?  Some computers limit the power available via USB ports and will not be able to power the Fusion Controller.  Please try connecting your Fusion to a different device or USB Power supply rated for at least 5v @ 500mA.  \n\n\n\n\n\n\nDoes the light 'flicker', especially if the microUSB connector is tapped or \ngently\n wiggled?  This is an indication that the microUSB cable on the connector may be damaged and cannot make reliable contact.  Please try a new, known good cable.", 
            "title": "Troubleshooting Step 1"
        }, 
        {
            "location": "/Trouble_Step1/#getting-started-trouble-shooting-step-1-attach", 
            "text": "If the Green LED near the microUSB connector does not light when the cable is connected between your computer and the Fusion, please check the following:       Is the cable good?  It is possible that the cable is damaged and power is not being transferred to the Fusion Controller.  Please try a known good cable of good quality.      Is the USB Port on the computer working properly and able to supply 5v @ 500mA?  Some computers limit the power available via USB ports and will not be able to power the Fusion Controller.  Please try connecting your Fusion to a different device or USB Power supply rated for at least 5v @ 500mA.      Does the light 'flicker', especially if the microUSB connector is tapped or  gently  wiggled?  This is an indication that the microUSB cable on the connector may be damaged and cannot make reliable contact.  Please try a new, known good cable.", 
            "title": "Getting Started Trouble Shooting - Step 1: Attach"
        }, 
        {
            "location": "/Trouble_Step3/", 
            "text": "Getting Started Trouble Shooting - Step 3: Connect\n\n\nIf your computer/device is not able to connect to the Fusion's Access Point, please check these items:  \n\n\n\n\n\n\n\n\nMake sure you are connected to the correct Access Point.  Confirm that you have entered the proper Passkey and that the computer has finished the negotiation process of connecting to the wireless network.\n\n\n\n\n\n\nIf you are unable to find or identify the Fusion Access Point:  \n\n\n\n\n\n\nCheck with your robot administrator to make sure the SSID and Passkey have not been changed.  \n\n\n\n\n\n\nConfirm that the WiFi in your computer is compatible with IEEE-802.11b, g, or n.  802.11ac is not supported.  \n\n\n\n\n\n\nConfirm that a Mimio MicroCloud or MyBot Classroom Server is running in your vicinity.  One way is to look for a WiFi network called \"MyBot Community WiFi\".  This would indicate that a  Mimio MicroCloud or MyBot Classroom Server \nis active\n in your vicinity.  Check with your robot administrator to get the credentials to login to the MyBot Community Network to access the Fusion.  \n(If these devices are operating near the Fusion Controller, it will detect them and will use its internal WiFi interface to connect to the MyBot Community WiFi Network and cannot activate the internal Access Point.)", 
            "title": "Troubleshooting Step 3"
        }, 
        {
            "location": "/Trouble_Step3/#getting-started-trouble-shooting-step-3-connect", 
            "text": "If your computer/device is not able to connect to the Fusion's Access Point, please check these items:       Make sure you are connected to the correct Access Point.  Confirm that you have entered the proper Passkey and that the computer has finished the negotiation process of connecting to the wireless network.    If you are unable to find or identify the Fusion Access Point:      Check with your robot administrator to make sure the SSID and Passkey have not been changed.      Confirm that the WiFi in your computer is compatible with IEEE-802.11b, g, or n.  802.11ac is not supported.      Confirm that a Mimio MicroCloud or MyBot Classroom Server is running in your vicinity.  One way is to look for a WiFi network called \"MyBot Community WiFi\".  This would indicate that a  Mimio MicroCloud or MyBot Classroom Server  is active  in your vicinity.  Check with your robot administrator to get the credentials to login to the MyBot Community Network to access the Fusion.   (If these devices are operating near the Fusion Controller, it will detect them and will use its internal WiFi interface to connect to the MyBot Community WiFi Network and cannot activate the internal Access Point.)", 
            "title": "Getting Started Trouble Shooting - Step 3: Connect"
        }, 
        {
            "location": "/Trouble_Step4/", 
            "text": "Getting Started Trouble Shooting - Step 4: Launch\n\n\nIf your device's browser is not able to access the Fusion Interface, please check these items:  \n\n\n\n\n\n\n\n\nIf you are unable to access the Fusion Interface using the \nmy.bot\n URL, please check to see if your computer/device has any other active network connections.  Generally, when another network connection is active, (particularly a \nwired\n connection to the Internet), the computer tries to use that connection to convert the URL to an IP Address.  If this is the case, enter the IP Address for the Fusion Controller directly:  \nhttp://192.168.50.1:8080\n.  \n\n\n\n\n\n\nIf neither the \nmy.bot\n URL nor the IP Address http://192.168.50.1:8080 will open the Fusion Interface, check to see if you have any anti-malware software that is providing a local firewall installed on your device.  Very often, local firewalls are set to aggressively protect your computer and will block access on non-standard ports.  Check with your computer administrator to see if port 8080 can be opened to allow communication with the Fusion.  \n\n\n\n\n\n\nIf your browser reports a security error when trying to access the Fusion, it suggests that your computer administrator may have set a policy that requires a \nsecure\n connection.  Look at the address bar to see if you are still trying to access http://192.168.50.1:8080, or if the address bar now reads http\ns\n:192.168.50.1:8080.  If the browser has changed http:// to https://, it indicates that the computer is configured to only allow secure connections.  The Fusion does not support https connections at this time.", 
            "title": "Troubleshooting Step 4"
        }, 
        {
            "location": "/Trouble_Step4/#getting-started-trouble-shooting-step-4-launch", 
            "text": "If your device's browser is not able to access the Fusion Interface, please check these items:       If you are unable to access the Fusion Interface using the  my.bot  URL, please check to see if your computer/device has any other active network connections.  Generally, when another network connection is active, (particularly a  wired  connection to the Internet), the computer tries to use that connection to convert the URL to an IP Address.  If this is the case, enter the IP Address for the Fusion Controller directly:   http://192.168.50.1:8080 .      If neither the  my.bot  URL nor the IP Address http://192.168.50.1:8080 will open the Fusion Interface, check to see if you have any anti-malware software that is providing a local firewall installed on your device.  Very often, local firewalls are set to aggressively protect your computer and will block access on non-standard ports.  Check with your computer administrator to see if port 8080 can be opened to allow communication with the Fusion.      If your browser reports a security error when trying to access the Fusion, it suggests that your computer administrator may have set a policy that requires a  secure  connection.  Look at the address bar to see if you are still trying to access http://192.168.50.1:8080, or if the address bar now reads http s :192.168.50.1:8080.  If the browser has changed http:// to https://, it indicates that the computer is configured to only allow secure connections.  The Fusion does not support https connections at this time.", 
            "title": "Getting Started Trouble Shooting - Step 4: Launch"
        }, 
        {
            "location": "/About/", 
            "text": "About Boxlight Robotics\n\n\n\n\nBoxlight Robotics is a leading supplier of educational robotic systems for STEM learning with an emphasis on Scientific Principles and real-world applications.  Boxlight Robotics also supplies advanced system controllers for building sophisticated mechatronic systems.  \n\n\nFormerly known as \nModern Robotics, Inc.\n, Boxlight Robotics is a member of the Boxlight Corporation, a global provider of interactive technology solutions to the 21st century education market.  \n\n\nFor more information visit \nwww.BoxlightRobotics.com\n and \nwww.Boxlight.com\n.\n\n\nContact Information\n\n\nTechnical Support\n\n\n\n\nSupport@BoxlightRobotics.com\n\nBoxlight Robotics\n\n901 Broad Street, Suite 305\n\nUtica, NY 13501\n\n\n+1 (678) 367-0809 x111\n\n\n\n\nSales Support\n\n\n\n\nSales@BoxlightRobotics.com\n\n\n+1 (678) 367-0809 x102\n  \n\n\n\n\n\n\nThe Fusion Operating System, Fusion Graphical User Interface, and Fusion Libraries are Copyright 2018-2019 by Modern Robotics Incorporated, and Copyright 2019-2022 by Boxlight Robotics. All Rights Reserved.\n  \n\n\nPortions of this software may also be covered by one or more of the following licenses: PSF, GPLv2.0, Apache 2.0, MIT, and New BSD.  \n\n\nThis document is published by Boxlight Robotics. No part of this document may be copied,\npublished in print, shared online, or otherwise publicly released without the express written\nconsent of Boxlight Robotics.  \n\n\nSpecifications subject to change without notice.", 
            "title": "About Modern Robotics Inc"
        }, 
        {
            "location": "/About/#about-boxlight-robotics", 
            "text": "Boxlight Robotics is a leading supplier of educational robotic systems for STEM learning with an emphasis on Scientific Principles and real-world applications.  Boxlight Robotics also supplies advanced system controllers for building sophisticated mechatronic systems.    Formerly known as  Modern Robotics, Inc. , Boxlight Robotics is a member of the Boxlight Corporation, a global provider of interactive technology solutions to the 21st century education market.    For more information visit  www.BoxlightRobotics.com  and  www.Boxlight.com .", 
            "title": "About Boxlight Robotics"
        }, 
        {
            "location": "/About/#contact-information", 
            "text": "", 
            "title": "Contact Information"
        }, 
        {
            "location": "/About/#technical-support", 
            "text": "Support@BoxlightRobotics.com \nBoxlight Robotics \n901 Broad Street, Suite 305 \nUtica, NY 13501  +1 (678) 367-0809 x111", 
            "title": "Technical Support"
        }, 
        {
            "location": "/About/#sales-support", 
            "text": "Sales@BoxlightRobotics.com  +1 (678) 367-0809 x102       The Fusion Operating System, Fusion Graphical User Interface, and Fusion Libraries are Copyright 2018-2019 by Modern Robotics Incorporated, and Copyright 2019-2022 by Boxlight Robotics. All Rights Reserved.     Portions of this software may also be covered by one or more of the following licenses: PSF, GPLv2.0, Apache 2.0, MIT, and New BSD.    This document is published by Boxlight Robotics. No part of this document may be copied,\npublished in print, shared online, or otherwise publicly released without the express written\nconsent of Boxlight Robotics.    Specifications subject to change without notice.", 
            "title": "Sales Support"
        }
    ]
}